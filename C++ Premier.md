# Primier C++

## 第1章 开始 
1. 除了cin、cout，还有两个标准输出对象为cerr(错误输出)和clog(日志输出)；
2. 提出了“流刷新”的概念，类似sql数据库的commit，如果一直不进行刷新，可能信息就会一直在内存中而没有显示出来；
3. 形如以下形式：    
```
while (std::cin >> value)
    sum += value;
```   
其实while后括号判断的是等式的最终结果，即std::cin的内容，一般输入一个合法结果，则返回为真，输入一个错误结果（例如回车符号），则返回为假；   

## 第2章 变量和基本类型
1. 基本类型中，比较少用的有wchar_t(宽字符，16位，对应1字节的char)，还有unicode字符char16_t和char32_t；（分别为16位和32位的Unicode字符）
2. 应该养成习惯，在明确知道数值不可能为负的情况下，应当选用无符号整形；   
3. 当给一个无符号数赋予一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数，例如``unsigned char c = -1  //char占8bit的情况下，c的值为255``，这意味着无符号数和有符号数一定不能够混用：   
```
uint u = 10;
int i = -42;
std::cout << u + i << std::endl; //结果为4294967264
```
4. 指定字面值类型：   
字符和字符串面值
| 前缀 | 含义 | 类型 |
| ---  | --- | --- |
| u    | Unicode16字符 | char16_t |
| U    | Unicode32字符 | char32_t |
| L    | 宽字符        | wchar_t  |
| u8   | UTF-8         | char     |   
整形字面值
|后缀|最小匹配类型|
|--|--|
|u or U|unsigned|
|l or L|long|
|ll or LL|long long|   
浮点型字面值
|--|--|
|f或F|float|
|l或L|long double|   
以上字面值都可以混合使用   
5. C++11新标准，确立了可以用花括号来初始化变量，这种初始化可以称为**列表初始化**，例如以下四个句子效果是一样的：   
```
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```   
这种初始化方式的一个特点在于，如果列表初始化中的数据有丢失信息的风险，则编译器就会报错，相反的，如果只是单纯的赋值，则会自动强制转换（伴随的就是精度丢失）
```
long double ld = 3.1415926;
int a{ld}, b = {ld}; //报错，因为存在信息丢失风险
int c(ld), d = ld; //正确，但丢失了精度
```    
6. 变量声明和定义中，如果想要声明一个变量而非定义它，则需要加extern关键字，并且不要显式的初始化变量，因为任何包含显式初始化的声明即会变成定义（C++使用分离式编译的原则，将声明和定义区分开来）
> 变量只能被定义一次，但是可以被多次声明。   
看上去丝毫不重要的声明和定义也许微不足道，但是非常重要。**如果要在多个文件中使用同一个变量，则必须将声明和定义分离**。此时变量的定义必须且只能出现在一个文件中，而其他用到该变量的文件必须进行声明，但是绝不能重复定义。   
7. 标识符：C++规定了用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外在函数体外的标识符不能以下划线开头。   
8. C++11使用nullptr来初始化指针，替代了原先的NULL；
9. void *指针可以存放任意对象的地址，但是并不能知晓对象的类型；   
10. 指向指针的引用：   
```
int i = 42;
int *p;       //p是一个int型指针
int *&r = p;  //r是一个对指针p的引用

r = &i;       //r引用了一个指针
*r = 0;
```
要理解r的类型到底是什么，最简单的办法是**从右至左阅读r的定义**。离变量名最近的符号（此例中为&）对变量类型有着最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中*说明&引用的是一个指针。最后，声明的基本数据类型部分指出r是一个int型指针。   
