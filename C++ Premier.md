# Primier C++

## 第1章 开始 
1. 除了cin、cout，还有两个标准输出对象为cerr(错误输出)和clog(日志输出)；
2. 提出了“流刷新”的概念，类似sql数据库的commit，如果一直不进行刷新，可能信息就会一直在内存中而没有显示出来；
3. 形如以下形式：    
```
while (std::cin >> value)
    sum += value;
```   
其实while后括号判断的是等式的最终结果，即std::cin的内容，一般输入一个合法结果，则返回为真，输入一个错误结果（例如回车符号），则返回为假；   

## 第2章 变量和基本类型
1. 基本类型中，比较少用的有wchar_t(宽字符，16位，对应1字节的char)，还有unicode字符char16_t和char32_t；（分别为16位和32位的Unicode字符）
2. 应该养成习惯，在明确知道数值不可能为负的情况下，应当选用无符号整形；   
3. 当给一个无符号数赋予一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数，例如``unsigned char c = -1  //char占8bit的情况下，c的值为255``，这意味着无符号数和有符号数一定不能够混用：   
```
uint u = 10;
int i = -42;
std::cout << u + i << std::endl; //结果为4294967264
```
4. 指定字面值类型：   
字符和字符串面值
| 前缀 | 含义 | 类型 |
| ---  | --- | --- |
| u    | Unicode16字符 | char16_t |
| U    | Unicode32字符 | char32_t |
| L    | 宽字符        | wchar_t  |
| u8   | UTF-8         | char     |   
整形字面值
|后缀|最小匹配类型|
|--|--|
|u or U|unsigned|
|l or L|long|
|ll or LL|long long|   
浮点型字面值
|--|--|
|f或F|float|
|l或L|long double|   
以上字面值都可以混合使用   
5. C++11新标准，确立了可以用花括号来初始化变量，这种初始化可以称为**列表初始化**，例如以下四个句子效果是一样的：   
```
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```   
这种初始化方式的一个特点在于，如果列表初始化中的数据有丢失信息的风险，则编译器就会报错，相反的，如果只是单纯的赋值，则会自动强制转换（伴随的就是精度丢失）
```
long double ld = 3.1415926;
int a{ld}, b = {ld}; //报错，因为存在信息丢失风险
int c(ld), d = ld; //正确，但丢失了精度
```    
6. 变量声明和定义中，如果想要声明一个变量而非定义它，则需要加extern关键字，并且不要显式的初始化变量，因为任何包含显式初始化的声明即会变成定义（C++使用分离式编译的原则，将声明和定义区分开来）
> 变量只能被定义一次，但是可以被多次声明。   
看上去丝毫不重要的声明和定义也许微不足道，但是非常重要。**如果要在多个文件中使用同一个变量，则必须将声明和定义分离**。此时变量的定义必须且只能出现在一个文件中，而其他用到该变量的文件必须进行声明，但是绝不能重复定义。   
7. 标识符：C++规定了用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外在函数体外的标识符不能以下划线开头。   
8. C++11使用nullptr来初始化指针，替代了原先的NULL；
9. void *指针可以存放任意对象的地址，但是并不能知晓对象的类型；   
10. 指向指针的引用：   
```
int i = 42;
int *p;       //p是一个int型指针
int *&r = p;  //r是一个对指针p的引用

r = &i;       //r引用了一个指针
*r = 0;
```
要理解r的类型到底是什么，最简单的办法是**从右至左阅读r的定义**。离变量名最近的符号（此例中为&）对变量类型有着最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中*说明&引用的是一个指针。最后，声明的基本数据类型部分指出r是一个int型指针。   
11. const限定符: 
```
int i = 42;
const int ci = i;
int j = ci;
```
const类型可以直接赋给非const的原因在于,ci的常量特性只在执行改变ci的操作中才会发挥作用，拷贝一个对象并不会改变它。   
另一个值得注意的是，const对象仅仅在文件内有效，事实上，编译使用了类似define的方法，将const类变量先用数值进行替代，因此每个用到的const变量都应该有所定义（有初始值）。   
有一种特殊情况在于需要共享const变量，做法是在一个.h和.cpp文件中进行定义即可： 
```
//file_1.h 
extern const int bufSize;
//file_1.cc
extern const int bufSize = fcn();
```   
12. const引用（常引用）： 常引用非常类似普通变量的常指针   
```
int i = 0;
const int &ip = i;
```
一般情况下，引用的类型必须和其所引用的对象类型一致，但是有两种特殊情况：1) 初始化常量引用时允许任意表达式作为初始值，只要表达式的结果能够转换为引用结果即可；   
```
int i = 42;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 * 2; //正确，为一常量引用
int &r4 = r1 * 2; //错误
```
这样能够产生的原因是因为编译器引入了**临时量**对象，即编译器用一个空间来暂存表达式的求职结果时临时创建的一个未命名的对象。
```
double dval = 3.14;
const int &ri = dval;

//编译器处理为
const int temp = dval;
const int &ri = temp;
```   

13. const指针：指针是对象，而引用不是，因此指针就和其他对象类型一样，可以把指针视作为常量。**常量指针**必须进行初始化，而且一旦完成，和其他常量一样，就无法改变了（即存放在常量指针中的地址无法改变了）。把*放在const之前说明指针是一个常量，这里暗含着不变的是指针本身的值而不是指向的那个值：   
```
int errNumb = 0;
int *const curErr = &errNumb;   //curErr将一直指向errNumb
const double pi = 3.14159;
const double *const pip = &pi; //pip是一个指向常量对象的常量指针
```   
如果先前所讲，判断复杂的变量类型依然遵循**由右向左**的阅读顺序。此例中，离curErr最近的是const，意味着本身是一个常量对象，对象的类型由声明符的其余部分决定，下一个符号是*，意思是curErr是一个常量指针。最后，声明语句的基础数据部分类型指明了它指向一个int对象。    
另一个注意点是指针本身是个常量并不意味着不能通过指针修改其所指向的对象的值。例如：    
```
if (*curErr)
{
    errorHandler();
    *curErr = 0;
}
```   

14. 顶层const：指针本身就是一个对象，而它又可以指向另一个对象，因此这是两个独立的问题。用名词**顶层const(top-level const)** 来表示指针本身是一个常量，而用名称**底层const(low-level const)** 表示指针所指向的对象是一个常量。更一般的，顶层const可以表示任何对象是常量，这一点对于任何数据类型适用。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类既可以是顶层const也可以是底层const,这一点和其他类型区别相比明显：    
```
int i = 0;
int *const p1 = &i;  //p1值不能被改变，是一个顶层const
const int ci = 42;  //ci值不能被改变，是一个顶层const
const int *p2 = &ci;  //p2的值可以被改变,是一个底层const
const int *const p3 = p2;  //靠右的const是顶层const,靠左的const是底层const   
const int &r = ci; //用于声明引用的const都是底层const
```    
顶层const有什么用呢？当执行对象拷贝操作时，常量是顶层还是底层区别明显，其中顶层const不受太多影响：   
```
i = ci;  //正确：ci是一个顶层const，无影响
p2 = p3; //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响
```   
另一方面，底层的const的限制却不容忽视，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的const资格，或者两个对象的数据类型必须能够相互转换。一般来说，非常量可以向常量转换，但是反之不行：   
```
int *p = p3;   //错误：p3包含了底层const定义，而p没有
p2 = p3;  //正确:p2和p3都是底层const（注意，这里把一个常指针赋给了非常指针，没有问题）
p2 = &i;  //正确：int*能够转换为const int*
int &r = ci; //错误:普通的int&不能够绑定到int常量上去   
const int &r2 = i;  //正确：const int&可以绑定到一个普通的int上
```   
p3既是顶层const又是底层const,拷贝p3时可以不在乎它是一个顶层const，但是必须清楚它指向的对象是一个常量。因此不能用p3去初始化p，因为p指向的是一个（非常量）整数，另一方面，p3的值也可以赋给p2，是因为这两个指针都是底层const，尽管p3本身是一个常量指针（顶层const），但是就这次赋值而言，不会有什么影响。

15. 新特性constexpr和常量表达式：常量表达式指的是值不变且在编译过程中就能得到计算结果的表达式，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。一个对象（或表达式）是不是常量表达式是由它的数据类型和初始值共同决定的，例如：   
```
const int max_files = 20;  //max_files是常量表达式
const int limit = max_files + 1;  //limits是常量表达式   
int staff_size = 27; //staff_size不是常量表达式
const int sz = get_size();  //sz不是常量表达式
```
尽管staff_size的初始值是个字面值常量，但是其数据本身只是一个普通非const int。而sz本身是一个常量，但是其具体值需要运行时才能获取，所以也不是常量表达式。   
引入constexpr变量的原因在于，在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式，实际使用中即使定义了一个const变量并且将其设定为一个我们认为是常量表达式的值，但实际使用过程中并非如此。   
C++11新标准规定，允许声明变量为constexpr类型以便由编译器来验证变量值是否为一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：    
```
constexpr int mf = 20; //20是常量表达式
constexpr int limit = mf + 1; //mf+1是常量表达式
constexpr int sz = size(); //只有当size是一个constexpr函数时才是一条正确的声明语句
```   
尽管不能使用普通函数作为constexpr变量的初始值，但是新标准允许一种特殊的constexpr函数，应该足够简单到编译时就可以计算它的结果，也就能用constexpr函数去初始化constexpr变量了。   

16. 字面值类型：类型简单，值显而易见的类型被称为“字面值类型”(literal type)。目前接触的数据类型中，算数类型、引用和指针都属于字面值类型，string\IO库和自定义类则不属于，也就不能被定义为constexpr。这里值得注意的是，尽管指针和引用都能被定义为cosntexpr，但是他们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或是存储于某个固定地址中的对象。
Tip:函数体内的变量一般来说并非存在固定的地址中，因此constexpr指针不能指向这样的变量。相反，定义于函数体外的对象其固定地址不变，则能够用来初始化constexpr指针。但是，C++允许函数定义一类超出函数本身的变量，这些变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的指针。   

17. 指针和constexpr:const和constexpr区别在哪儿？如果使用了constexpr定义了一个指针，那么constexpr仅对指针有效，而对指针所指的对象无关（这一点和const相反）：   
```
const int *p = nullptr; //p是一个指向整形常量的指针
constexpr int *q = nullptr; //q是一个指向整数的常量指针
```   
p和q的类型相差甚远，关键就在于constexpr是把它所定义的对象定义为了顶层const，这样意味着它可以随便指向常量或者非常量:   
```
constexpr int *np = nullptr;  
int j = 0;
constexpr int i = 42;  //i的类型是整形常量
//i和j都必须定义在函数体之外
constexpr const int *p = &i; //p是常量指针，指向整形常量i 
constexpr int *p1 = &j; //p1是常量指针，指向整数j
```   

18. 类型别名（type alias）: 有两种方法实现类型别名。一种方法是使用传统的``typedef``：
```
typedef double wages;  
typedef wages base, *p; //base是double的同义词，p是double*的同义词
```
C++11新的声明方法，使用别名声明（alias declaration）来定义类型别名:   
```
using SI= Sales_item;  //SI是Sales_item的同义词
```    

19. 指针、常量和类型别名：   
如果某个类型别名指代的是复合类型或者常量，那么把它运用到声明语句里就会产生意想不到的后果，例如下个例子当中的pstring实际上是char*的别名：   
```
typedef char *pstring; 
const pstring cstr = 0; //cstr是指向char的常量指针
const pstring *ps; //ps是一个指针，它的对象是指向char的常量指针
```   
这里极其容易混淆的是，pstring实际上是指向char的指针，因此const pstring指的是指向char的常量指针（**因为const是对给定类型的修饰符**）, 而非指向常量字符的指针。   
遇到一条使用了类型别名的声明语句，人们往往会错误地尝试把别名替换成它本来的样子，来理解该语句的含义：   
```
const char *cstr = 0;
```
而这样的展开或者替换完全错误，这是因为const char连写注定了后面的*修饰的是这个整体；   

20. auto类型说明符：
auto让编译器通过初始值来推断变量的类型，显然，**auto定义的变量必须有初始值**：
```
auto item = val1 + val2; //item初始化为val1和val2相加的结果
```   
使用auto也能在一条语句中声明多个变量，但是同一个声明语句中只能有一个基本数据类型，所有该语句中所有变量的初始基本数据类型都必须一样：   
```
auto i = 0, *p = &i;  //正确：皆为整形数据或指针
auto sz = 0, pi = 3.14; //错误：sz和pi类型不一致
```    
编译器推断出的auto类型有时候和初始值类型会不完全一样。
首先，由于使用引用时直接使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：   
```
int i = 0, &r = i;
auto a = r; //a是一个整数
```
其次，auto一般会忽略顶层const，同时底层const会保留下来，例如初始值是一个指向常量的指针时：   
```
const int ci = i, &cr = ci;
auto b = ci; //b是一个整数（ci顶层const特性被忽略）
auto c = cr; //c是一个整数（cr是别名，ci本身是一个顶层const）
auto d = &i; //d是一个整形指针（整数的地址就是指向整数的指针）
auto e = &ci; //e是一个指向整数常量的指针（对常量对象取地址是一种底层的const）
```   
(这里从b可以看出顶层const既可以是指针，还可以是引用的形式)   
如果希望推断的auto类型是一个顶层const，则需要进行明确指出：   
```
const auto f = ci;  //f是const int
```   
还可以将引用的类型设定为auto，此时原来的初始化规则依然适用：   
```
auto &g = ci;   //g是个整形常量引用，绑定到ci
auto &h = 42;   //错误：不能将非常量引用绑定字面值
const auto &j = 42; //正确：可以为常量引用绑定字面值
```   
设定一个类型为auto引用时，初始值中的顶层常量属性依然保留。和往常一样，**如果我们给初始值绑定一个引用，此时的常量就不是顶层常量了**（说白了最后发现auto引用是整体引用，和auto本身有一定差别）。   
同上，如果要在一个语句中定义多个变量，需要记住&和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一个类型：   
```
auto k = ci, &l = i;  //k为整数，l为整形引用   
auto &m = ci, *p = &ci; //m是对整形常量的引用，p是指向整形常量的指针
auto &n = i, *p2 = &ci; //错误，因为i的类型为int而&ci的类型为const int
```   

21. decltype类型指示符：有时候会遇到希望从表达式类型推断出要定义的变量的类型，但是又不想用该表达式的值初始化变量的情况。这里C++11引入``decltype``作为返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，但是却不计算表达式的值：   
```
decltype(f()) sum = x; //sum的类型就是函数f返回的类型
```   
编译器并不会直接调用函数f，而是使用当调用发生时f的返回类型作为sum的类型。   
decltype处理顶层const和引用方式和auto略有不同，如果decltype使用的表达式是一个变量的话，那么decltype返回该变量的类型（包含顶层const和引用在内）：   
const int ci = 0, &cj = ci;
decltype(ci) x = 0;  //x类型为const int
decltype(cj) y = x;  //y类型为const int&, 绑定到变量x
decltype(cj) z;  //错误：z是一个引用，必须进行初始化处理
```    
需要指出的一点是，引用从来都是作为其所指向的对象的同义词出现，只有在decltype处是一个例外，下面会进行解释。   
如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。而有些表达式会返回一个引用类型，一把来说这种情况发生时，意味着该表达式的结果对象能够作为一条赋值语句的左值：   
```
//decltype的结果可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; //正确：加法结果为0，所以b为一个int（没有初始化）
decltype(*p)       //错误：？c是int&,必须进行初始化
```
因为r是一个引用，因此decltype(r)的结果是引用类型。如果想让结果类型是r所指向的类型，可以将r作为表达式的一部分，例如r + 0。这样就巧妙的将表达式的结果表示为一个具体值而不是一个引用。    
另一方面，如果表达式内容**是解引用操作, 则decltype将得到引用类型**，正如我们熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，所以decltype(*p)的结果类型就是int&而非int。   
> Tip: 解引用操作符指的是\*在C++中，用于得到操作数所指向变量的引用（这说明\*不是单纯的指向原操作数，而是一个引用）   
decltype和auto另一处区别在于变量加上括号后可能结果类型会发生改变：   
```
decltype((i)) d;  //错误：d是int&,必须初始化
decltype(i) e;    //正确：e是一个未初始化的int
```   
原因在于给变量套上括号后，编译器就会把它当做一个表达式。   

22. 自定义数据结构：   
如果数据结构一上来就准备好使用对应的变量，一般可以写成：   
```
struct Sales_data {/**/} accum, trans, *salesptr;
//也可以写成
struct Sales_data {/**/};
Sales_data accum, trans, *salesptr;
```   
C++11规定，可以为数据成员提供一个**类内初始值**。   
    
## 第3章 字符串、向量和数组    
1. using形式不仅可以使用整个命名空间，更可以单独指定某个符号：   
```
using std::cout; 
using std::endl;
```   
Tip:头文件不应该包含using声明，这是因为头文件的内容会被拷贝到所有引用它的文件中去。如果头文件中有某个using声明，则会导致所有使用该头文件的文件都有这个声明，这样就会导致可能的冲突。    

2. 直接初始化和拷贝初始化：使用等号，即为拷贝初始化，如果不使用等号，则执行的是直接初始化。   

3. 使用getline读取一整行数据：   
```
int main()
{
    string line;
    //每次读入一整行，直到到达文件末尾
    while (getline(cin, line))
        cout << line << endl;
    return 0;
}
```    
注意，保存到line当中的对象并不包括换行符，哪怕一开始为换行符（这种情况下为空）   

4. string::size_type:这体现了标准库类型是与机器无关的特性，如果一条表达式中已经有了size()函数就不要再使用int了，可以避免混用int和unsigned可能带来的问题。 可以使用decltype来解决这个问题  
```
for (decltype(s.size()) index = 0; index != s.size() && isspace(s[index]); ++index)
    s[index] = toupper(s[index]); //将当前字符改成大写形式
```

5. 字面值不可以直接相加：   
```
string s7 = "hello" + "," + s2; //字面值必须和string类型相邻相加才可以继续进行
```   

6. 新的for使用准则：C++11中引入了新范围语句    
```
for (declaration: expression)
    statement
```   
例如：    
```
string str("some string");
//每行输入str中的一个字符
for (auto c : str)
    cout << c << endl;
```    

7. vector对象初始化： C++11支持使用花括号来进行vector对象初始化：   
```
vector<string> articles = {"a", "an", "the"};
vector<string> v0{"a", "an", "the"};
```   
使用花括号或者圆括号来区分列表初始值还是元素数量：    
```
vector<int> v1(10);  //v1有10个元素，每个值都是0
vector<int> v2{10};  //v2有1个元素，值为10
vector<int> v3(10, 1); //v3有10个值为1的元素
vector<int> v4{10, 1}; //v4有2个元素，值分别为10为1
```   
某些操作可能会让迭代器操作失效（pushback在遇到一定体量后，会重新修改了迭代器所指的空间内容）   

8. 迭代器的运算：迭代器可以和一个整数值相加（或相减），其返回值为一个移动了若干位置的迭代器。例如要获得一个指向vector对象中间位置的元素：    
```
//计算得到最接近vi中间元素的一个迭代器
auto mid = vi.begin() + vi.size() / 2;
```    
两个迭代器类型相减，得到的类型是名为**difference_type**的带符号整数型。   
这里给出一个迭代器用于二分搜索：   
```
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg) / 2;
while (mid != end && *mid != sought)
{
    if (sought < *mid)
        end = mid;
    else 
        beg = mid + 1;
    mid = beg + (end - beg) / 2; 
}
```

9. 数组：大小不变的存储结构，可用花括号进行初始化。**并且不支持拷贝给其他数组或者赋值**（有些支持该操作的编译器称之为编译器扩展，应当避免使用）；   
复杂数组声明的例子：   
```
int *ptrs[10];   //ptrs是含有10个整形指针的数组
int &refs[10] = /*?*/; //错误，不存在引用的数组
int (*Parray)[10] = &arr;  //Parray是指向一个含有10个整数的数组
int (&arrRef)[10] = arr;   //arr引用一个含有10个整数的数组
```   
一般的，依据**类型符由右向左绑定**的规律。例如ptrs由右向左：首先是一个10大小的数组，它的名字是ptrs，然后知道其指向类型为指向int的指针。   
特例在于Parray，由右向左理解似乎不太合理，更合理的方式在于**由内向外的顺序**。首先*Parray意味着Parray是一个指针，接下来看右侧，知道Parray是个指向大小为10的数组的指针。最后观察左边，可以知道数组中的元素是int。   
总结：判断数据类型由**先由内至外，后从右至左**来进行判断。    
```
int *(&arry)[10] = ptrs; //arry是数组的引用，该数组有10个指针
```    

10. size_t:使用数组下标时，通常定义为size_t类型，它是一种及其相关的无符号类型(类似difference_type)，它被设计得足够大来表示内存中任意对象大小。    
同样可以使用新for语句适用于数组的遍历：   
```
for (auto i : scores)
    cout << i << " ";
```

11. 指针和数组：首先auto是支持指针的
```
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia); //ia2是一个整形指针，指向ia第一个元素
ia2 = 42; //错误：ia2作为一个指针，不可以用int值给指针赋值
```   
必须支出的是，如果使用decltype关键字时上述转换不会发生，decltype(ia)返回的是10个整数构成的数组:   
```
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
ia3 = p; //错误：不能将整形指针给数组赋值
ia3[4] = i; //正确：吧i赋值给ia3的一个元素
```   
总结：decltype覆盖范围没有auto大    

12. 指针也是迭代器：虽然说我们一般不会使用指向尾元素的下一个元素，但是可以用于模仿迭代器模式对数组进行遍历
```
int *e = &arr[10]; //指向arr尾元素的下一个位置的指针
for (int *b = arr; b != e; ++b)
    cout << *b << endl;
```   

13. 标准库函数begin和end：为了减少尾后指针极可能使用出错的情况，C++11引入了标准库函数begin和end，包含在iterator头文件中：    
```
int ia[] = {0,1,2,3,4,5,7,8,9};
int *beg = begin(ia); //指向ia首元素
int *last = end(ia); //指向arr尾元素下一位置的指针
```    
例如寻找到一个数组中的第一个负数：   
```
int *pbeg = begin(arr), *pend = end(arr);
while (pbeg != pend && *pbeg >= 0)
    ++pbeg;
```   

14. 指针运算：众所周知指针可以进行运算。和迭代器的difference_type不同，两个指针相减结果是一种名为**ptrdiff_t**的标准库类型：   
```
auto n = end(arr) - begin(arr); 
```   
和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中机器相关的类型，因为其差值可能为一个负数，所以ptrdiff_t是一个带符号类型。     
只要两个指针指向同一个数组的元素（或者尾元素的下一个元素），就能利用关系运算符对其进行比较，例如下面这个遍历数组中元素的例子：       
```
int *b = arr, *e = arr + sz;
while (b < e) {
    //使用*b
    ++b;
}
```

15. 下标和指针：下标也可以及其自由的使用，例如：   
```
int ia[] = {0,2,4,6,8};
int *p = &ia[2];
int j = p[1];   //指向ia[3]
int k = p[-2];  //指向ia[0]
```
虽然string和vector也能执行下标运算，但是还是略有不同，标准库类型都限定了下标必须是无符号类型，而内置的下标没有这个限制。   

16. 与旧代码的接口：   
1) 混用string对象和C风格字符串：string提供了c_str()函数来转化为c风格的字符串类型：   
```
const char *str = s.c_str();
```   
2) 使用数组初始化vector对象：   
vector的初始化其实不用逐一赋值，用迭代器(指针)的方法非常便捷：   
```
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));
```   
这种方法另一个好处是可以提出中间一部分对象：   
```
vector<int> subVec(int_arr + 1, int_arr + 4); //拷贝了三个元素，分别为1、2、3
```     
> 建议：尽量使用标准库类型而非数组，例如C++程序应尽量使用vector和迭代器而非使用内置数组和指针，使用string而非c风格基于数组的字符串；   

17. 多维数组：严格来说C++语言中没有多维数组，通常说的多维数组本质是数组的数组，理解这一点对日后使用多维数组大有裨益。   
```
int ia[3][4];  //大小为3的数组，每个元素时含有4个整数的数组
int arr[10][20][30] = {0}; //大小为10的数组，每个元素为大小为20的数组，而这些数组元素是含有30个整数的数组，最终将每个元素初始化为0
```   
阅读顺序依然遵照由内而外的规律，例如ia是一个3个元素的数组，同时这每一个元素本身都是含有4个元素的数组。   
多维数组的初始化类似普通数组，每一行都用花括号括了起来：   
```
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
};
```   
而事实上内嵌花括号并非必须，同样可以使用一位数组形式以更简洁的方式完成以上的初始化工作（前提是没有错误）：   
```
int ia[3][4] =  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
```    
也可以显示的初始化每行首元素（仅仅）：   
```
int ia[3][4] = {{0} , {4}, {8}};
```   
如果只是显式的初始化第一行元素，其它元素被初始化为0：    
```
int ix[3][4] = {0, 3, 4, 9};
```   
下标引用：**如果表达式含有的下标运算符和数组维度一样多，该表达式的结果将是给定类型的元素，如果比数组维度小，则将是返回一个给定索引处的一个内层数组**:   
```
ia[2][3] = arr[0][0][0]; //首元素赋给ia最后一个元素
int (&row)[4] = ia[1]; //将row绑定到ia的第二个4元素数组上
```   
另一个例子，常用两层嵌套来处理多维数组:   
```
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt]; 
for (size_t i = 0; i != rowCnt; ++i) //对于每一行
{
    for (size_t j = 0; j != colCnt; ++j)  //对于每一列
    {
        ia[i][j] = i * colCnt + j;
    }
}
```   
更简洁的，使用C++11的范围语句，可以简化为：   
```
size_t cnt = 0;   
for (auto &row : ia)
    for (auto &col : row) {
        col = cnt;
        cnt++;
    }
```   
这里有个很有意思的地方，为什么要强制使用引用？本质在于避免自动转化为指针：如果不使用引用类型，循环形式如下：
```   
for (auto row : ia)
    for (auto col : row)
```    
程序将会无法通过编译，这是因为，第一个循环ia所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类型，编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转换为指向给数组内首元素的指针，那么得到的row类型就是int*，因此内存循环就不合法了（编译器将试图在一个int*内进行遍历）   
> Note:要使用范围for语句处理更多的多维数组，除了最内层的循环外，其他所有的循环的控制变量都应该是引用类型。    
指针和多维数组：当程序使用多维数组的名字时，也会自动将其转换为指向数组首元素的指针。   
```
int ia[3][4];    //大小为3的数组，每个元素是含有4个整数的数组
int (*p)[4] = ia; //p指向含有4个整数的数组
p = &ia[2];  //p指向ia的尾元素
```  
> Note: 上述声明中，圆括号必不可少
> int *ip[4]; //包含4个整形指针的数组
> int (*ip)[4]; //指向包含4个整数的数组的指针    
C++11新标准可以使用auto或者decltype来避免对指针遍历时再定义一个指针类型了：   
```
for (auto p = ia; p != ia + 3; ++p)
    for (auto q = *q; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
```    
使用标准库函数begin和end可以获得同样的功能，而且形式表达上更加简洁：   
```
for (auto p = begin(ia); p != end(ia); ++p)
    for (auto q = begin(*p); q != end(*p); ++q)
        cout << *q << ' ';
    cout << endl;
```   
这样就既不用在乎size也不用在乎类型。如果需要更进一步，使用类型别名可以使这个过程更加简单一些，例如：   
```
using int_array = int[4]; //C++11新标准声明别名的形式
//或者使用
typedef int int_array[4]; 

for (int_array *p = ia; p != ia + 3; ++p)
    for (int *q = *p; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
```   

## 第4章 表达式
1. 基础：   
C++定义了一元(取地址符&/解引用符*)、二元、三元（A?B:C）运算符
左值右值：
C中，单纯的指左值只能位于赋值表达式的左侧，右值只能位于赋值表达式的右侧；   
C++中，当一个对象被用作右值时，用的是对象的内容（值）；而当对象被用作左值时，用的是对象的身份（在内存中的位置）；   
和C比起来，左值一方面在为常量时，并不能作为赋值语句的左侧运算对象，另一方面，虽然有些表达式求值结果是对象，但是它们是右值而非左值。   
运算符操作的一个重要原则在于**需要右值的地方，可以用左值代替，但是反之不成立**，并且当一个左值被当成右值使用时，实际使用的就是它的值（内容）。   
> Tip: 使用关键字decltype时，左值和右值也略有不同，如果求值结果为左值，则decltype作用于该表达式（非变量）得到一个引用类型。例如p的类型为int*,因为解引用符生成左值，故decltype(*p)得到一个int&。另一方面取地址运算符生成右值，故decltype(&p)的结果是int**, 也就是一个指向整形指针的指针。   
求值顺序：运算符的优先级决定了运算对象的组合方式，但是没有框定运算对象按什么顺序求值。**大多数情况下不会明确指定求值的顺序**，例如：   
```
int i = f1() * f2();
```   
这里对于不同的编译器来说，就无法判断是f1先调用还是f2先调用。还有例如：  
```
int i = 0; 
cout << i << " " << ++i << endl; //未定义
```
这种输入结果各种编译器也会有很大区别，完全不可预知。所以编程中尽量避免这种写法。**这给我们的启示是尽量在复杂的表达式中对同一个对象进行多次操作（至多一次）**，如果实在是需要，请用括号加以限制。  
但是有4种运算符明确了其运算对象的求值顺序，&&（逻辑与）规定了先求左侧并且只有左侧为真时才能继续求右侧（**这个很有用，尤其在判断输入变量是否满足标准的情况下**），另三种分别为逻辑或(||)、条件(?:)与逗号(,);   
2. 取余运算：取余运算的定义为，如果m和n是整数且n并非0，则m = (m/n) * n + m % n。其隐含意思为，**如果m % n不等于0，那么其结果应该始终和m的符号相同**，根据这个原则，我们不难求出：   
```
-21 % 8 = -5; -21 / -8 = 2;
21 % -5 = 1;  -21 / 5 = -4;
```   

3. 逻辑运算符：上面提过，对于逻辑与和逻辑或（&&和||）都是先求左侧对象值再求右侧对象之（除非左侧运算对象无法确定表达式才会计算右侧运算对象的值），这种策略称为短路求值（short-circuit evaluation）,一个示范可以用于指针为空和size的判断，这样可以显得语法更加简洁：   
```
bool isTen(QVector<int> *iptr){
    if (iptr && iptr->size() == 10)
        return true;
    return false;
}
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    qDebug() << isTen(Q_NULLPTR);
    return a.exec();
}
```   

4. 赋值运算符：赋值运算符合右结合律，这一点和其他的二元运算符不太一样，最常见的就是**多重赋值**，当然，这种语句必须类型转换正确：   
```
int ival, jval;
ival = jval = 0;  
```   
较低优先级的赋值运算带来的写法变换：**赋值语句经常出现在条件中**，这是因为赋值运算优先级低，通常需要给赋值语句加上括号来使得其符合我们的原意。下面给一个例子说明赋值语句放在条件语句中有什么用处，它的目的是反复调用一个函数直到返回期望的值为止：   
```
//以下为一个形式繁琐，易出错的写法
int i = get_value();   
while (i != 42)
{
    //其它处理...
    i = get_value(); //得到下一个值，继续判断
}
```   
实际上可以简化为：   
```
int i;
while ((i = get_value()) != 42)
{
    //其他处理...
}
```
这个处理更加简洁，也证明了赋值运算符本身较低的运算符。   
复合赋值运算符：+=、-=、*=、/=、%=、<<=、>>=、&=、^=、|=，其本质和其本身表达式只是稍有区别``a = a op b``，其实在很多地方，这种区别对于程序的影响几乎可以忽略不计。   

5. 递增与递减运算符（++/--）：除非必须，一般不使用递增递减运算符的后置版本，这里从另一个方面揭示了**为什么前置++的效率比后置++高？**，这是因为**前置直接返回了这个数自身+1的内容，而后置版本还需要先把原始值存储下来，用于返回这个未修改的内容**，如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。   
当然任何问题都不是绝对的，如果我们遇到在一条复合表达式中既将变量+1或减-1又能使用其原始值，这时候就可以使用递增和递减运算符的后置版本，例如以下这个例子：   
```
auto pbeg = v.begin();
while (pbeg != v.end() && *pbeg >= 0)
    cout << *pbeg++ << endl;
```   
> Tip: 虽然*pbeg++的表达式可能不太一定容易理解，但是其实这是一种更有效的写法，远比书写**cout << *pbgeg << endl; ++pbeg;**要更加简洁非，并且也更少出错。大多数C++程序追求简洁、摒弃冗长，应该习惯于这种写法。    
> Tip: 注意++极容易引起任意求值顺序问题的错误；   

6. 条件运算符：条件运算符(?:)已经非常常用，这里有两点注意点：   
1) 嵌套使用：
```
finalgrade = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : "pass";
```   
不过注意，如果超过两层，代码的可读性急剧下降；   
2) 在输出表达式中使用条件运算符：这里极其容易造成问题的原因是因为条件运算符的优先级很低，应该加以括号进行限制；   
```
cout << ((grade < 60) ? "fail" : "pass"); //输出pass或fail
cout << (grade < 60) ? "fail" : "pass"; //输出1或者0
cout << grade < 60 ? "fail" : "pass"; //错误，因为试图比较cout和60
```   

7. 位移运算符：位运算符作用于整数类型运算对象，并把运算对象看成是二进制位的集合。同时C++提供了bitset类（标准库）可以表示任意大小的二进制位集合，所以位运算符同样能用于bitset类型。   
有两个平时用的比较少的位运算符：**~求反运算符、^异或运算符**
> Warning: 位运算没有规定只能使用于有符号整形还是无符号整形，一般推荐仅将位运算符用于处理无符号整形。   
求反运算符:会将char类型的运算对象提升为int类型（向高位添加0即可），然后逐位求反。   
移位运算符（又叫IO运算符）满足左结合律，例如：   
```
cout << "hi" << "there" << endl;
```
等同于：   
```
((cout << "hi") << " there") << endl);
```     
移位运算符优先级不高不低，介于中间：比算术运算符优先级低，但是比关系运算符、赋值运算符和条件运算符的优先级高。    
```
cout << 42 + 10; //52
cout << (10 < 42); //1
cout << 10 < 42; //错误：试图比较cout和42
```   

8. sizeof运算符：返回一个表达式或者一个类型名字所占的字节数，其使用形式有两种：   
```
sizeof(type)
sizeo expr
```  
第二种形式中，sizeof返回的是表达式结果类型的大小，稍微不一样的是，sizeof并不计算其运算对象的值：   
```
Sales_data data, *p;  
sizeof(Sales_data); //存储Sales_data类型对象所占的空间大小   
sizeof data;        //data的类型大小，即sizeof p;           //指针所占空间大小
sizeof *p;          //p所指类型的空间大小，即sizeof(Sales_data)    
sizeof data.revenue;  //成员对应类型大小
sizeof Sales_data::revenue; //另一种获取revenue大小的方式
```   
其中最有意思的就是``sizeof *p``,其中即使p为空指针也不会影响最终的结果，因为sizeof根本也不需要通过运算值就可以知道类型的大小。   
最后一个例子则揭示了，C++11新标准中，使用了作用域运算符来获取类成员的大小。   
9. 逗号运算符：逗号运算符经常被人忽略。其运算遵循：先对左侧的表达式求值，然后将求值最终结果丢掉。逗号运算符的真正结果是右侧表达式的值，如果右侧表达式是一个左值，那么最终的求值结果就是个左值；   
最常见的逗号运算符的使用见于for循环中：     
```
vector<int>::size_type cnt = ivec.size();   
for (vector<int>::size_type ix = 0;ix != ivec.size(); ++ix, --cnt)
    ivec[ix] = cnt;
```   

10. 类型转换：任何编程语言都无法避免类型转换这个话题。首先最简单的是隐式转换（implicit conversion）。其次是算数转换。    
整形提升：false提升为0，true提升为1；小char型（bool、char、short等）都会转换为int，其余的提升为unsigned int。   
较大的char类型（wchar_t、char16_t、char32_t）提升为int、unsigned int、long、unsigned long、long long和unsigned long long中的最小的一种类型。

11. 显式转换：   
命名强制转换具有以下形式：   
```
cast-name<type>(expression);
```   
其中type是目标类型而expression是要转换的值，如果type是引用，则结果是左值。而cast-name会从**static_cast、dynamic_cast、const_cast和reinterpret_cast**
static_cast:    
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。例如：   
```
int i, j;
double slope = static_cast<double>(j) / i;
```   
当需要把一个较大的算数类型赋值给较小的类型时，static_cast非常有用。此时强制类型告诉程序阅读者和编译器：这里机器知道并且不在乎潜在的精度损失（这可以避免一大批warning）；     
static_cast对于编译器无法自动执行的类型转换也非常有用，例如找回存在于void*的指针：   
```
void *p = &d;   //正确：任何非常量对象的地址都能存入void*   
double *dp = static_cast<double*>(p); //转换为double类型指针
```     

const_cast:     
const_cast只能改变运算对象是底层const，例如：    
```
const char *pc;
char *p = const_cast<char*>(pc); //正确：但是通过p改变值是未定义的行为
```    
这样把常量对象转换为非常量对象的行为，我们一般称为去掉const性质，编译器也就不会再组织我们对该对象进行写操作。如果对象本身不是一个常量，这样的行为就是合法的，但是如果是一个常量，就容易会产生未定义的后果。    
const_cast的特殊之处就在于只有它能够改变表达式的常量属性，其他cast—name强制类型转换表达式的常量属性都会导致编译器错误。同理，也不能用const_cast改变表达式的类型：   
```
const char *cp;
char *q = static_cast<char*>(cp); //错误：static_cast不能转换掉const性质   
static_cast<string>(cp); //正确：将字符串字面值换为string类型
const_cast<string>(cp);  //错误：const_cast只能改变常量属性，而不能改变类型
```   
> Tip:const_cast常常用于有函数重载的上下文中，下文将会进行介绍   

reinterpret_cast:     
reinterpret_cast通常为对象的位模式提供较低层次上的重新解释，例如有以下转换：   
```
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```   
这里需要牢记pc所指向的真实对象是一个int而非字符，如果把pc当成普通的字符指针就可能在运行时发生错误。例如：   
```
string str(pc);
```     
可能导致异常的运行时行为。

> Suggestion:避免强制类型转换时对于检查类型的建议，这个建议对于reinterpret_cast尤其适用，因为这种类型转换总是充满了风险。比较无可厚非的使用是在有重载函数的上下文中使用const_cast，但是在其它情况下使用const_cast也就意味着程序存在某种设计缺陷。其它强制类型转换，例如static_cast和dynamic_cast，都不应该频繁使用。每书写一条强制类型转换语句，都应该反复斟酌是否能以其它方式事项相同目标。    
**应摒弃早期的强制转换写法**，即type(expr)或者(type)expr，因为这样的类型转换会带来不一样的结果，**完全应该使用static_cast或者const_cast替换**；   

## 第5章 条件语句    
当程序对的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时检测出问题的部分应该发出某种信号来表明程序遇到了故障，无法再继续下去了。**而且信号的发出方无需知道故障将在何处得到解决**。一旦发出异常信号，检测出问题的部分也就完成了任务。   
如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据，如果丢失了数据库连接，会发出报警信息。    
异常处理机制为程序中的异常检测和异常处理这两部分的协作提供支持，在C++语言中，异常处理包括：   
- throw表达式：异常检测部分使用throw表达式表示它遇到了无法处理的问题。   
- try语句块：异常处理使用try语句块处理异常。try语句块以关键字try开始，并以一个或者多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称为**异常处理代码**。   
- 一套异常类，用于在throw表达式和对应的catch子句之间传递异常的具体信息。   
1. throw表达式：程序的异常检测使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。   
举个例子，例如检查是否是同一种书籍，然后判断其是否能够相加：   
```
Sales_item item1, item2;
cin >> item1 >> item2;
//首先检查item1和item2是否表示同一种书籍
if (item1.isbn() == item2.isbn()) {
    cout << item1 + item2 << endl;
    return 0; //表示成功
} else {
    cerr << "Data must refer to same ISBN" << endl;
    return -1; //表示失败
}
```    
在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序使得检查完成后不再直接输出一条信息，而是抛出一个异常：   
```
//首先检查两条数据是否关于同一种书籍的
if (item1.isbn() == item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
//如果程序执行到这里，表示两个ISBN是相同
cout << item1 + item2 << endl;
```   
这段代码中，如果ISBN不一样就会抛出一个异常，该异常时类型runtime_error的对象，抛出异常就会**终止当前的函数，并且把控制权交给能处理该异常的代码**。   
类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。我们必须使用一个string对象或者一个C风格的字符串来初始化一个runtime_error对象。   

2. try语句块：其通常形式如    
```
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} //...
```     
在之前的例子里，我们使用了一个throw表达式来避免把两个代表不同书籍的Sales_item相加。我们假设执行Sales_item对象加法的代码时与用户交互的代码分离开来的。其中与用户交互的代码负责处理发生的异常，它的形式可能如下：   
```
while (cin >> item1 >> item2) {
    try {
        //执行添加两个Sales_item对象的代码
        //如果添加失败，代码抛出一个runtime_error
    } catch (runtime_error err) {
        //提醒用户两个ISBN必须一致，询问是否重新输入   
        cout << err.what() 
             << "\nTry Again? Enter y or n" << endl;
        char c;
        cin >> c;
        if (!cin || c == 'n')
            break;
    }
}

```   
程序本来要执行的任务出现在try语块中，因为这段代码可能会抛出一个runtime_error类型的异常。   
try语句块对应一个catch的子句，该子句负责处理类型为runtime_error的异常。如果try语句块的代码抛出了runtime_error异常，接下来执行catch块内的语句。在我们书写的catch子句中，输出一段提示信息要求用户指定程序是否继续。   
给用户的提示信息中最后输出了err.what()的返回值，其实就是其初始化的字符串。   
函数在寻找处理代码的过程中退出：在复杂系统中，程序在抛出异常代码之前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能又调用了一个包含新的含有try语句块的函数，依次类推。   
寻找处理代码的过程与函数的调用链正好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没有找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也会被终止，继续搜索调用它的函数。以此类推，沿着程序执行的路径逐层回退，直到找到适合类型的catch的子句为止。   
如果最终还是没找到与任何匹配的catch子句，程序转到名为terminate的标准库函数，该函数行为和系统有关，一般情况下执行该函数将会导致程序非正常退出。     
对于那些没有任何try语句块定义的异常，也按照类似的方式处理；毕竟，没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。    
3. 标准异常：
C++标准库定义了一组类，用于报告标准库函数中遇到的问题，这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中：   
- exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。   
- stdexcept头文件定义了几种常用的异常类，这些类会在下面表中列出。   
- new头文件定义了bad_alloc异常类型。   
- type_info头文件定义了bad_cast异常类型。   
    
## 第6章 函数
1. 函数基础：这里已经非常熟悉，不过有一些需要注意的点是   
- 传入函数的实参的顺序并没有规定，编译器可以以任何顺序对实参求值（这意味着传入的实参千万不能互相打架）    
- 函数的**返回类型不能是数组类型或者函数类型**，但是可以是指向数组或者函数的指针，下文会介绍如何返回数组的指针/引用以及函数的指针。   
> Tip:一个函数中的静态变量可以很方便的进行所谓次数统计的工作，这一点非常特别，当然它们只会在第一次运行时初始化一次。   
```
size_t count_calls()
{
    static size_t ctr = 0;  
    return ++ctr;
}

int main() {
    for (size_t i = 0; i != 10; i++)
        cout << count_calls() << endl;
    return 0;
}
//将会输出1到10的数字
```     
2. 参数传递：   
- 使用引用避免拷贝：除了已经熟知的原因（不复制对应的对象），还有一些原因例如某些类型根本不支持拷贝（例如IO类型）
- 利用引用返回多参数：一个经常使用的技巧就是使用引用来返回额外的信息     
- const形参和实参：顶层const只作用于对象本身   

```
const int ci = 42;  //不能改变ci，const是顶层的
int i = ci;  //正确：当拷贝ci时，会忽略它的顶层const
int * const p = &i;  //const是顶层的，不能给p赋值
*p = 0;
```     
- 尽量使用常量引用：应该从底层函数就注意使用该原则，这样避免设计高一阶函数时出现该问题；
- 数组形参：前面提过，数组有两个性质限制了其在函数使用中有区别——1) 不允许拷贝数组；2) 使用数组时通常会将其转换成指针；尽管不能以值传递的方式传递数组，但是我们可以把形参转换为类似数组的形式：   

```
//以下三个print函数等价
void print(const int*);
void print(const int[]);
void print(const int[10]); //这里的10只能表示我们希望的数组的大小，实际并不一定
```
随之而来的问题就是管理指针形参数量问题，通常使用：   
1) 使用标记指定数组长度：例如C风格字符串到\0之前确认为有效；   
2) 使用标准库规范:向函数传递数组的首元素和尾后元素的指针，这种方法收到标准库技术的启发，例如：   
```
void print(const int *beg, const int *end)
{
    while (beg != end)
        cout << *beg++ << endl;
}
```
调用时传入两个指针，可以使用标准库的begin和end函数：   
```
int j[2] = {0, 1};
print(begin(j), end(j));
```
3) 显示的传递一个数组的大小：这种方法在C和传统C++方法中非常常见     

**数组引用形参**：C++允许将变量定义为数组的引用,同理，函数形参也可以是数组是的引用。此时引用形参绑定到对应的实参上，也就是绑定到数组上：   
```
void print(int (&arr)[10])
{
    for (auto elem : arr)
        cout << elem << endl;
}
```   
> Tip:这里需要区分引用的数组和数组的引用之间的区别——f(int &arr[10]) //错误：arr为引用的数组、f(int (&arr)[10]) //z正确：arr为具有10个整数的整形数组的引用    
这里虽然没问题，但是由于指定了数组维度的大小，这样也限制了print函数的可用性，下文中还会给出不限大小形式的输出；    
  
传递多维数组：就像之前介绍的那样，C++语言中实际上没有真正的多维数组，所谓的多维数组其实是数组的数组。    
例子：   
```
//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组
void print(int (*matrix)[10], int rowSize);
{/*...*/}
```
> Tip:同上面的引用数组，注意括号是必须的。   
同样也可以使用数组的语法定义函数，此时编译器会一如既往的忽略掉第一个维度，所以最好不要把它包括在形参列表内：    
```
//等价定义
void print(int matrix[][10], int rowSize){}
```    

**main:处理命令行选项**：    
有时候，我们的确需要给main传递实参，常见的main带参形式我们已经很熟了：   
```
int main(int argc, char *argv[]){...}
```
argc等于记录argv中字符串的数量，因为第二个参数为数组，main函数也可以定义为：   
```
int main(int argc, char **argv){...}
```     
例如在一个可执行文件中传入main函数的内容，
```
prog -d -0 ofile data0
```
那么argc = 5，argv里包含以下C风格的字符串：   
```
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```
> Warning:当使用argv中间的实参时，一定要记得可选的实参从argv[1]开始，**argv[0]保存的是程序的名字，而非用户输入**。

**含有可变形参的函数**：C++11标准提供两种方法来解决编写处理不同数量实参的函数的问题：1) 如果所有是参类型相同，我们可以传递一个名为initializer_list的标准库类型；2) 如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，后面会介绍。    
C++还有一种**省略符**形参，用它可以传递可变数量的实参。下面会进行介绍，但是这种功能一般只用于和C函数的接口程序。    

#### initializer_list形参    
如上文所说，initializer_list针对的是类型相同的形参的模板，和vector一样，在定义时需要包含所属的元素例如：   
```
initializer_list<string> ls; 
initializer_list<int> li;
```    
但是和vector不一样的是，initializer_list对象中的元素永远是常量值。   
例如我们用它来输出错误信息：   
```
void error_msg(initializer_list<string> il)
{
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << " ";
    cout << endl;
}
```
如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内：    
```
if (excepted != actual)
    error_msg({"functionX", excepted, actual});
else 
    error_msg({"functionX", "okay"});
```    
当然，含有initializer_list形参的函数也可以拥有其他形参，例如调试系统可以有个名为ErrCode的类来表示不同类型的错误，因此我们可以改写之前的程序，使其包含一个initializer_list形参和一个ErrCode形参：   
```
void error_msg(ErrCode e, initializer_list<string> il)
{
    cout << e.msg() << ": ";
    for (const auto &elem : il)
        cout << elem << " ";
    cout << endl;
}
```
那么对应的调用形式可以写为：    
```
if (excepted != actual)
    error_msg(ErrCode(42), {"functionX", excepted, actual});
else
    error_msg(ErrCode(0), {"functionX", "okay"});
```    

#### 省略符形参：   
只用于兼容C的varargs的情况，其他情况基本不会使用，形式例如：    
```
void foo(parm_list, ...);
void foo(...);
```    

3. 返回类型和return语句：   
> Tip: **不要反悔局部对象的引用或者指针**，这是因为在生命周期结束后，局部变量所占用的空间也会被释放掉。     
> Tip: 那么什么时候反悔指针和引用呢？例如比较两个数，返回较大的那个数，就可以使用。    
```
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```     

#### 返回类型的函数和调用运算符     
首先调用运算符也有结合律，例如：   
```
auto sz = shorterString(s1, s2).size();
```
**引用返回左值**：函数的返回类型决定是否为左值，调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回的引用，特别是，能够给返回类型（非常量引用）直接赋值：   
```
char &get_val(string &str, string::size_type ix)
{
    return str[ix]; 
}

int main()
{
    string s("a value");
    cout << s << endl; //输出a value
    get_val(s, 0) = 'A';
    cout << s << endl; //输出A value
    
    return 0;
}
```    

**列表初始化返回值**：C++11规定，函数可以返回花括号的值的列表。和其他返回结果一样，此处的列表也用来表示函数返回的临时量进行初始化，例如：   
```
vector<string> process()
{
    if (excepted.empty())
        return {};
    else if (excepted == actual)
        return {"functionX", "okay"};
    else 
        return {"functionX", excepted, actual};
}
```    

递归：main函数不能递归    

**返回数组指针**：因为数组不能被拷贝，所以函数不能返回数组，但是函数**可以返回数组的指针或者引用**，有几个比较能够简化这个问题的方法，最简单的是使用类型别名：    
```
typedef int arrT[10]; 
using arrT = int[10];   //以上两条声明等价
arrT* func(int i);      //func返回一个指向含有10个整数的数组的指针
```    
因为arrT是含有10个整数的数组的别名，因为无法返回数组，因此返回一个数组指针。   
#### 声明一个返回数组指针的函数      
之所以推荐使用别名的方式来进行处理，是因为接下来所举的直接返回固定大小数组指针的例子会揭示这么做真的炒鸡烦。    
和上述例子相同，我们如果想要定义一个返回数组指针的函数，则**数组的维度必须跟在函数名字之后**。然后，函数的形参列表应该优先于数组的维度，这样就造成了函数的形式应该写成如下形式：    
```
Type (*function(parameter_list))[dimension]
```     
实例比如这个没有使用类型别名的func函数：   
```
int (*func(int i))[10];
```     
可以按照以下顺序理解这个声明的含义：   
- func(int i)表示调用func函数时需要一个int类型的实参；
- (*func(int i))表示我们可以对函数调用的结果进行解引用操作；   
- (*func(int i))[10]表示解引用func的调用将得到一个大小是10的数组；    
- int (*func(int i))[10]表示数组中元素是int类型。   
#### 使用尾置返回类型    
C++11标准中还提供了一种方法可以简化上述的func声明方法，就是使用**尾置返回类型**，任何函数都能使用尾置返回，但是对于比较复杂的类型最为有效。比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并且以一个->符号开头，为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto:      
```
//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组   
auto func(int i) -> int(*)[10]
```
#### 使用decltype   
还有一种情况，如果我们知道函数返回的指针指向哪个数组，就可以使用decltype关键字来声明返回类型，例如：    
```
int odd[] = {0, 1, 2, 3, 4};
int even[] = {5, 6, 7, 8, 9};
decltype(odd) *arrPtr(int i)
{
    return (i % 2) ? &odd : &even;
}
```     
decltype表示arrPtr返回类型是一个指针（不应该是一个数组吗），并且该指针所指的对象与odd类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组指针。    
> Tip:值得注意的是，declctype并不负责把数组类型转成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还需要在函数声明时加一个*符号。    

4. 函数重载：    
定义：**如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载**。（关键词：名字相同、形参不同）    
**重载和const形参**：     
根据前文所说，**顶层const不影响传入该函数的对象** ，一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：   
```
Record lookup(Phone);
Record lookup(const Phone);  

Record lookup(Phone*);
Record lookup(const Phone*);
```    
以上两组都是重复声明，每一组的第二个声明和第一个声明都是等价的。      

另一方面，如果形参是某种类型的指针或者引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时const是底层的：    
```
//对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同   
//定义了4个独立的重载函数
Record lookup(Account&);  
Record lookup(const Account&);   //新函数，用于常量引用

Record lookup(Account*);
Record lookup(const Account*);   //新函数，作用于指向常量的指针
```     
之所以编译不报错的原因是，（**因为是通过是否为底层const来判断**）编译器可以通过实参是否为常量来推断应该调用哪个函数。因为const不能转化为其他类型，所以我们只能把const对象传递给const形参。相反的，因为非常量可以转化为const，所以上面的4个函数都能作用于非常量对象或者只想非常量对象的指针。不过下文中还会介绍，**当我们传递一个非常量对象或者非常量对象指针时，编译器会优先选用非常量版本的函数** 。     

const_cast和重载：     
上文中曾经提过，const_cast在重载函数的情景中最为有用，例如之前的shorterString函数：   
```
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```    
这个函数的参数和返回类型都是const string的引用，我们可以对两个非常量的string实参调用这个函数，但是返回的结果仍然是const string的引用。因此我们**需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用** ，使用const_cast可以做到这一点：   
```
string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1),
    const_cast<const string&>(s2)));
    return const_cast<string&>(r);
}
```    
在这个版本的函数中，首先将它的实参强制转化为对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以将其再转换为一个普通的string&，这显然是安全的。     

#### 调用重载函数        
调用重载函数时需要进行函数匹配，也叫重载确定。当调用重载函数时可能有三种结果：    
- 编译器找到了一个与实参的最佳匹配；
- 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误；   
- 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时就会发生**二义性调用** ；

### 重载和作用域：    
重载对于作用域的一般性质并没有什么改变，如果在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名：   
```
string read();    
void print(const string&);
void print(double);  //重载print函数
void fooBar()
{
    bool read = false;  //新作用域：隐藏了外部的read
    string s = read();  //错误：read是一个bool值
    //通常来说，在局部作用域中声明函数不是一个好的选择    
    void print(int);    //新作用域：隐藏了之前的print
    
    print("Value:");    //错误：print(const string &)被隐藏    
    print(ival);        //正确：当前print(int)可见
    print(3.14);        //正确，虽然调用的print(int)把print(double)屏蔽掉了
}
```     
说白了就是：**一旦编译器在局部找到了外部有的同名函数，将会屏蔽外面所有的同名函数**。    
> Tip：在C++语言中，名字查找发生在类型检查之前。   
5. 特殊用途的语言特性：   
- 默认实参：这个已经很熟了
- 内联函数和constexpr函数：    
> 使用内联函数的原因在于：调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。      
内联函数的作用就在于，在每个调用节点上采取类似inline的方式“内联的”展开。例如之前的shorterString函数，一般调用：   
```
cout << shorterString(s1, s2) << endl;
```    
将会在编译过程中展开为以下形式：   
```
cout << (s1.size() < s2.size() ? s1 : s2) << end;
```    
而创建内联函数只需要在函数一开始加上inline就可以。   
一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。    

- constexpr函数：指的是能用于常量表达式的函数。其和其他函数相比并没有特殊之处，不过需要遵守几项规定——首先函数的返回类型和所有形参都必须是字面值类型，而且函数体中只能有且只有一条return语句：   
```
constexpr int new_sz() {return 42;}
constexpr int foo = new_sz();  
```    
执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果只。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。   
constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行操作就行。例如可以有空语句、类型别名、using声明等。   
我们允许constexpr函数返回值并非一个常量：   
```
//如果arg是常量表达式，则scale(arg)也是常量表达式    
constexpr size_t scale(size_t cnt){ return new_sz() * cnt; }    
```    
当scale的实参是常量表达式时，它的返回值也是常量表达式，反之则不然：    
```
int arr[scale(2)];   //正确：sacle(2)是常量表达式    
int i = 2;           //i不是常量表达式   
int a2[scale(i)];    //错误：scale(i)不是常量表达式
```    
编译器会自动检查是否返回的非常量表达式会用到只能接受常量表达式的场合中，如果有错误，则会报错。     

> Tip: 内联函数和constexpr函数一般都定义在头文件内，这是由于其可以定义多次（而每个定义又必须完全一致）决定的。     

#### 调试帮助：   
C++程序员往往会用到类似头文件保护（#ifdef .h）的结束，以便有选择的执行调试代码。其基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码，这种方法涉及两种预处理功能：assert和NDEBUG;    
assert预处理宏：     
assert是一种预处理宏，其行为类似一个内联函数，使用一个表达式作为其条件：    
```
assert(expr);
```    
首先对expr求值，若表达式为假（即为0），则assert输出信息并且终止程序的执行。若为真(即非0)，则assert什么也不做。    
和预处理变量一样（#define xxx）一样，**宏名字在程序内必须唯一** 。   
          
NDEBUG预处理变量：    
assert行为依赖于一个名为NDEBUG的预处理变量的状态，如果定义了NDEBUG，则assert什么也不做。默认情况下NDEBUG没有定义，此时assert将会执行检查。     
定义NDEBUG能够避免检查各种条件所需的运行时开销，当然此时根本不会执行运行检查。因此，assert应该**仅用于验证那些不可能发生的事** ，我们可以把assert当成调试程序的一种辅助手段，但是并不能代替真正运行时的逻辑检查，也不能替代程序本身应该包含的错误检查。    
除了用于assert以外，也可以使用NDEBUG编写自己的条件调试代码，如果NDEBUG未定义，将执行#ifndef和#endif之间的代码，如果定义了NDEBUG，则这些代码被忽略：    
```
void print(const int ia[], size_t size)
{
#ifndef NDEBUG
    //__func__是编译器定义的一个局部静态变量，用于存放函数的名字   
    cerr << __func__ << ": array size is " << size << endl;  
#endif
}
```    
编译器为每个函数都定义了__func__，它是const char的一个静态数组，用于存放函数的名字。    
除了__func__，预处理器还预留了4个对于程序调试很有用的名字：    
__FILE__:存放文件名的字符串字面值   
__LINE__:存放当前行号的整形字面值
__TIME__:存放文件编译时间的字符串字面值
__DATE__:存放文件编译日期的字符串字面值
可以使用这些常量在错误消息中提供更多信息，例如在日志中的使用；     

6. 函数匹配：     
几个重载函数经常会出现转换困难的问题，例如：    
```
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
f(5.6);   //调用f(double, double)
```    
那么如何确定候选函数和可行函数呢？候选函数具有两个特征，一是与被调用的函数同名，二是声明在调用点可见。    
第二步就是挑出可行函数，也有两个特征：一是其形参数量和本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。    
经过上面两步，接下来需要考虑实参类型是否与形参匹配。既可能是它们具有相同的类型，也可能是实参类型和形参类型满足转换规则。上述例子中第二个和第四个也是符合的。    
如果到这里还没有决出最后的调用对象，那么需要寻找最佳匹配，下文会介绍这里使用的“最匹配”的细节，它的基本思想，实参类型与形参类型越接近，它们匹配的越好。    
含有多个形参的函数匹配：当实参的数量有两个或者更多时，函数匹配就比较复杂了。例如上面这个例子调用：   
```
f(42, 2.56);
```    
选择可行函数的方法只有一个实参时一样，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。此例中，可行函数包括f(int, int)和f(double,double)。接下来，编译器依次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功：    
- 该函数每个实参的匹配都不劣于其他可行参数的匹配；    
- 至少有一个实参的匹配优于其他可行函数提供的匹配。    
如果在检查了所有实参中没有任何一个函数脱颖而出，则该调用是错误的，编译器将会报二义性的错误。    
上面的调用中，只考虑第一个实参时我们发现函数f(int,int)能精确匹配，要相匹配第二个函数，则int类型必须转化为double类型，显然需要内置类型转换的匹配劣于精确匹配，故就第一个参数而言编译器认为第一个函数胜。    
接着考虑第二个参数，很明显编译器还会认为第二个函数优于第一个函数。    
所以，编译器只能老老实实的报出二义性错误，因为每个可行函数各自在一个实参上实现了更好的匹配。看起来我们似乎可以通过强制类型转换其中一个参数来实现函数的匹配，但是设计良好的系统中，不应该对实参进行强制类型转换。    
> Advice:调用重载函数时应该尽量避免类型转换，如果实际中确实需要强制类型转换，则说明设计的形参集合不合理。     

#### 实参类型转换：    
为了确定最佳匹配，编译器将实参类型到形参类型转换划分为了几个登记，如下所示：   
1) 精确匹配，包括以下情况：    
- 实参类型和形参类型相同；
- 实参从数组类型或函数类型转换为对应的指针类型；   
- 向实参添加顶层const或者从实参中删除顶层const。   
2) 通过const转换实现的匹配；   
3) 通过类型提升实现的匹配；    
4) 通过算数类型转换或者指针转换实现的匹配；   
5) 通过类类型转换实现的匹配；    

分析函数调用前，一般小整形都会提升到int类型或者更大的整形类型。假设有两个函数，一个接受int、另一个接受shrot。只有调用提供的是short类型的值才会选short版本的函数，有时候即使实参是一个很小的整数值，也会直接提升为int类型，此时使用short版本反而会导致类型转换：    
```
void ff(int);
void ff(short);
ff('a');
```    
**所有算数算数类型转换级别都一样，例如从int向unsigned int转换并不比从int向double转换级别高** ，，例如：    
```
void mainip(long);
void mainip(float);
mainp(3.14);   //错误：二义性调用
```    
字面值3.14类型是double，它既能转换为long也能转换为float，因此存在两种可能的算数类型转换，因此该调用具有二义性。      

7. 函数指针：    
函数指针指向的是函数而非对象，和其它指针相同。而和其返回类型无关，和函数名无关。例如：    
```
bool lengthCompare(const string &, const string &);    
```
该函数的类型是bool(const string&, const const string&)。要想声明一个可以指向该函数的指针，只需要用函数替换函数名就可以：    
```
//pf指向一个函数，该函数的参数是两个const string的引用，返回的是bool类型   
bool (*pf)(const string&, const string&); //未初始化的函数指针
```    
> Note:注意，一定要在*pf两端必不可少，如果**不写这对括号，则pf是一个返回为bool指针的函数** 。   
     
当我们把函数名作为一个值使用时，该函数会自动的转化为指针，例如：    
```
pf = lengthCompare;   //pf指向名为lengthCompare的函数
pf = &lenghtCompare;  //等价的赋值语句：取地址符是可选的    
```
此外可以直接使用指向函数的指针调用该函数，无需提前解引用指针：   
```
bool b1 = pf("hello", "goodbye");    //调用lengthCompare函数   
bool b2 = (*pf)("hello", "goodbye"); //等价调用    
```    
在往不同函数类型的指针间不存在转换规则，但是和往常一样，我们可以为函数赋一个nullptr或者值为0的整形常量表达式，表示该指针没有指向任何一个函数：   
```
string size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0; //正确
pf = sumLength; //错误：返回类型不匹配
pf = cstringCompare;  //错误：形参类型不匹配
pf = lengthCompare;   //正确：函数和指针类型精确匹配    
```    
重载函数的指针：当我们使用重载函数时，如果定义了指向重载函数的指针，将会通过精准匹配来指定指针调用的哪一个函数：   
```
void ff(int*);
void ff(unsigned int);

void (*pf1)(unsigned int) = ff;
```   
函数指针形参：和数组类型类似，虽然不能定义函数类型的形参，但是形参可以是指向函数类型的指针。此时看上去形参是函数类型，但是实际上是指针：    
```
//第三个形参是函数类型，它会自动地转成指向函数的指针
void useBigger(const string &s1, const string &s2, 
                bool pf(const string&, const string&));
//等价的声明：显式的将形参定义成指向函数的指针
void useBigger(const string &s1, const string &s2, 
                bool (*pf)(const string &, const string &));
```    
我们可以直接把函数当做实参使用，它会自动转化为指针：   
```
//自动将函数lengthCompare转换成指向该函数的指针
useBigger(s1, s2, lengthCompare);    
```    
但是这么写又写的太过于冗长，为了避免如此繁琐，可以利用别名和decltype进行简化：
```
//Func和Func2是函数类型：   
typedef bool Func(const string&, const string &); //这句话的意思是，定一个函数，类似一个函数的声明，下面还需要给出Func的定义
typedef decltype(lengthCompare) Func2;  //等价类型

//FuncP和FuncP2是指向函数的指针
typedef bool (*FuncP)(const string&, const string&);
typedef decltype(lengthCompare) *FuncP2; 
```     
值得注意的是，decltype返回函数类型不会将函数类型自动转换成指针类型（类似数组），因为decltype的结果是函数类型，只有在结果前面加上*才能得到指针。这样可以使用如下的形式重新声明useBigger:   
```
//useBigger的等价声明，其中使用了类型别名
void useBigger(const string&, const string&, Func);
use useBigger(const string&, const string&, FuncP2);
```    
返回指向函数的指针：   
和数组类似，虽然不能返回一个函数，但是可以返回指向函数类型的指针。最简单的方法仍然是使用别名：   
```
using F = int(int*, int); //F为函数类型，不是指针
using PF = int(*)(int*, int); //PF为指针类型
```     
必须注意的是，**和作为函数类型的形参不一样，返回类型不会自动转换成指针**，我们必须显式的将返回类型定义为指针：    
```
PF f1(int);    //正确：PF是指向函数的指针，f1返回指向函数的指针
F f1(int); //错误：F是函数类型，不能返回一个函数类型
F *f1(int);   //正确：显式的定义返回指向函数的指针    
```    
当然更麻烦的方法就在于用以下的形式声明f1：   
```
int (*f1(int))(int*, int);
```    
以上的类型阅读应该按照由内而外的顺序：我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回了一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此函数指向函数，该函数的返回类型为int。   
另一个最讨喜的方法应该是后置返回类型了：   
```
auto f1(int) -> int(*)(int*, int);
```    
将auto和decltype用于函数指针类型：如果我们明确知道返回函数是哪一个，就能用decltype简化书写函数指针返回类型的过程。假定有两个函数，它们的返回类型都是string::size_type，并且各有两个const string&类型的形参，此时我们可以编写第三个函数，它接受一个string类型的参数，返回一个指针,此指针指向前两个函数中的一个：   
```
string::size_type sumLength(const string&, const string&);
string::size_type largerLength(const string&, const string&);
//根据其形参的取值，getFcn函数返回指向sumLength或者largerLength的指针   
decltype(sumLength) *getFunc(const string &);
```     
唯一需要注意的是，和上面一样，得显式的加上*来表明我们需要返回指针，而非函数本身。    
      
## 第7章 类
类的基本思想是**数据抽象**和**封装**，而数据抽象是一种依赖于**接口**和**实现(implementation)**分离的技术，类的接口包括用户所能执行的惭怍，类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。    
封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现的部分。    
类想要实现数据抽象和封装，首先需要定义一个抽象数据类型，在抽象数据类型中，由类的设计者负责思考类的实现过程；使用该类的程序员只需要抽象的思考类型做了什么，而无需了解类型的工作细节。    
