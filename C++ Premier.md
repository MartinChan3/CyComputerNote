# Primier C++

# 第一部分 C++基础

## 第1章 开始 
1. 除了cin、cout，还有两个标准输出对象为cerr(错误输出)和clog(日志输出)；
2. 提出了“流刷新”的概念，类似sql数据库的commit，如果一直不进行刷新，可能信息就会一直在内存中而没有显示出来；
3. 形如以下形式：    
```
while (std::cin >> value)
    sum += value;
```   
其实while后括号判断的是等式的最终结果，即std::cin的内容，一般输入一个合法结果，则返回为真，输入一个错误结果（例如回车符号），则返回为假；   

## 第2章 变量和基本类型
1. 基本类型中，比较少用的有wchar_t(宽字符，16位，对应1字节的char)，还有unicode字符char16_t和char32_t；（分别为16位和32位的Unicode字符）
2. 应该养成习惯，在明确知道数值不可能为负的情况下，应当选用无符号整形；   
3. 当给一个无符号数赋予一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数，例如``unsigned char c = -1  //char占8bit的情况下，c的值为255``，这意味着无符号数和有符号数一定不能够混用：   
```
uint u = 10;
int i = -42;
std::cout << u + i << std::endl; //结果为4294967264
```
4. 指定字面值类型：   
字符和字符串面值
| 前缀 | 含义 | 类型 |
| ---  | --- | --- |
| u    | Unicode16字符 | char16_t |
| U    | Unicode32字符 | char32_t |
| L    | 宽字符        | wchar_t  |
| u8   | UTF-8         | char     |   
整形字面值
|后缀|最小匹配类型|
|--|--|
|u or U|unsigned|
|l or L|long|
|ll or LL|long long|   
浮点型字面值
|--|--|
|f或F|float|
|l或L|long double|   
以上字面值都可以混合使用   
5. C++11新标准，确立了可以用花括号来初始化变量，这种初始化可以称为**列表初始化**，例如以下四个句子效果是一样的：   
```
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```   
这种初始化方式的一个特点在于，如果列表初始化中的数据有丢失信息的风险，则编译器就会报错，相反的，如果只是单纯的赋值，则会自动强制转换（伴随的就是精度丢失）
```
long double ld = 3.1415926;
int a{ld}, b = {ld}; //报错，因为存在信息丢失风险
int c(ld), d = ld; //正确，但丢失了精度
```    
6. 变量声明和定义中，如果想要声明一个变量而非定义它，则需要加extern关键字，并且不要显式的初始化变量，因为任何包含显式初始化的声明即会变成定义（C++使用分离式编译的原则，将声明和定义区分开来）
> 变量只能被定义一次，但是可以被多次声明。   
看上去丝毫不重要的声明和定义也许微不足道，但是非常重要。**如果要在多个文件中使用同一个变量，则必须将声明和定义分离**。此时变量的定义必须且只能出现在一个文件中，而其他用到该变量的文件必须进行声明，但是绝不能重复定义。   
7. 标识符：C++规定了用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外在函数体外的标识符不能以下划线开头。   
8. C++11使用nullptr来初始化指针，替代了原先的NULL；
9. void *指针可以存放任意对象的地址，但是并不能知晓对象的类型；   
10. 指向指针的引用：   
```
int i = 42;
int *p;       //p是一个int型指针
int *&r = p;  //r是一个对指针p的引用

r = &i;       //r引用了一个指针
*r = 0;
```
要理解r的类型到底是什么，最简单的办法是**从右至左阅读r的定义**。离变量名最近的符号（此例中为&）对变量类型有着最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中*说明&引用的是一个指针。最后，声明的基本数据类型部分指出r是一个int型指针。   
11. const限定符: 
```
int i = 42;
const int ci = i;
int j = ci;
```
const类型可以直接赋给非const的原因在于,ci的常量特性只在执行改变ci的操作中才会发挥作用，拷贝一个对象并不会改变它。   
另一个值得注意的是，const对象仅仅在文件内有效，事实上，编译使用了类似define的方法，将const类变量先用数值进行替代，因此每个用到的const变量都应该有所定义（有初始值）。   
有一种特殊情况在于需要共享const变量，做法是在一个.h和.cpp文件中进行定义即可： 
```
//file_1.h 
extern const int bufSize;
//file_1.cc
extern const int bufSize = fcn();
```   
12. const引用（常引用）： 常引用非常类似普通变量的常指针   
```
int i = 0;
const int &ip = i;
```
一般情况下，引用的类型必须和其所引用的对象类型一致，但是有两种特殊情况：1) 初始化常量引用时允许任意表达式作为初始值，只要表达式的结果能够转换为引用结果即可；   
```
int i = 42;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 * 2; //正确，为一常量引用
int &r4 = r1 * 2; //错误
```
这样能够产生的原因是因为编译器引入了**临时量**对象，即编译器用一个空间来暂存表达式的求职结果时临时创建的一个未命名的对象。
```
double dval = 3.14;
const int &ri = dval;

//编译器处理为
const int temp = dval;
const int &ri = temp;
```   

13. const指针：指针是对象，而引用不是，因此指针就和其他对象类型一样，可以把指针视作为常量。**常量指针**必须进行初始化，而且一旦完成，和其他常量一样，就无法改变了（即存放在常量指针中的地址无法改变了）。把*放在const之前说明指针是一个常量，这里暗含着不变的是指针本身的值而不是指向的那个值：   
```
int errNumb = 0;
int *const curErr = &errNumb;   //curErr将一直指向errNumb
const double pi = 3.14159;
const double *const pip = &pi; //pip是一个指向常量对象的常量指针
```   
如果先前所讲，判断复杂的变量类型依然遵循**由右向左**的阅读顺序。此例中，离curErr最近的是const，意味着本身是一个常量对象，对象的类型由声明符的其余部分决定，下一个符号是*，意思是curErr是一个常量指针。最后，声明语句的基础数据部分类型指明了它指向一个int对象。    
另一个注意点是指针本身是个常量并不意味着不能通过指针修改其所指向的对象的值。例如：    
```
if (*curErr)
{
    errorHandler();
    *curErr = 0;
}
```   

14. 顶层const：指针本身就是一个对象，而它又可以指向另一个对象，因此这是两个独立的问题。用名词**顶层const(top-level const)** 来表示指针本身是一个常量，而用名称**底层const(low-level const)** 表示指针所指向的对象是一个常量。更一般的，顶层const可以表示任何对象是常量，这一点对于任何数据类型适用。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类既可以是顶层const也可以是底层const,这一点和其他类型区别相比明显：    
```
int i = 0;
int *const p1 = &i;  //p1值不能被改变，是一个顶层const
const int ci = 42;  //ci值不能被改变，是一个顶层const
const int *p2 = &ci;  //p2的值可以被改变,是一个底层const
const int *const p3 = p2;  //靠右的const是顶层const,靠左的const是底层const   
const int &r = ci; //用于声明引用的const都是底层const
```    
顶层const有什么用呢？当执行对象拷贝操作时，常量是顶层还是底层区别明显，其中顶层const不受太多影响：   
```
i = ci;  //正确：ci是一个顶层const，无影响
p2 = p3; //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响
```   
另一方面，底层的const的限制却不容忽视，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的const资格，或者两个对象的数据类型必须能够相互转换。一般来说，非常量可以向常量转换，但是反之不行：   
```
int *p = p3;   //错误：p3包含了底层const定义，而p没有
p2 = p3;  //正确:p2和p3都是底层const（注意，这里把一个常指针赋给了非常指针，没有问题）
p2 = &i;  //正确：int*能够转换为const int*
int &r = ci; //错误:普通的int&不能够绑定到int常量上去   
const int &r2 = i;  //正确：const int&可以绑定到一个普通的int上
```   
p3既是顶层const又是底层const,拷贝p3时可以不在乎它是一个顶层const，但是必须清楚它指向的对象是一个常量。因此不能用p3去初始化p，因为p指向的是一个（非常量）整数，另一方面，p3的值也可以赋给p2，是因为这两个指针都是底层const，尽管p3本身是一个常量指针（顶层const），但是就这次赋值而言，不会有什么影响。

15. 新特性constexpr和常量表达式：常量表达式指的是值不变且在编译过程中就能得到计算结果的表达式，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。一个对象（或表达式）是不是常量表达式是由它的数据类型和初始值共同决定的，例如：   
```
const int max_files = 20;  //max_files是常量表达式
const int limit = max_files + 1;  //limits是常量表达式   
int staff_size = 27; //staff_size不是常量表达式
const int sz = get_size();  //sz不是常量表达式
```
尽管staff_size的初始值是个字面值常量，但是其数据本身只是一个普通非const int。而sz本身是一个常量，但是其具体值需要运行时才能获取，所以也不是常量表达式。   
引入constexpr变量的原因在于，在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式，实际使用中即使定义了一个const变量并且将其设定为一个我们认为是常量表达式的值，但实际使用过程中并非如此。   
C++11新标准规定，允许声明变量为constexpr类型以便由编译器来验证变量值是否为一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：    
```
constexpr int mf = 20; //20是常量表达式
constexpr int limit = mf + 1; //mf+1是常量表达式
constexpr int sz = size(); //只有当size是一个constexpr函数时才是一条正确的声明语句
```   
尽管不能使用普通函数作为constexpr变量的初始值，但是新标准允许一种特殊的constexpr函数，应该足够简单到编译时就可以计算它的结果，也就能用constexpr函数去初始化constexpr变量了。   

16. 字面值类型：类型简单，值显而易见的类型被称为“字面值类型”(literal type)。目前接触的数据类型中，算数类型、引用和指针都属于字面值类型，string\IO库和自定义类则不属于，也就不能被定义为constexpr。这里值得注意的是，尽管指针和引用都能被定义为cosntexpr，但是他们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或是存储于某个固定地址中的对象。
Tip:函数体内的变量一般来说并非存在固定的地址中，因此constexpr指针不能指向这样的变量。相反，定义于函数体外的对象其固定地址不变，则能够用来初始化constexpr指针。但是，C++允许函数定义一类超出函数本身的变量，这些变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的指针。   

17. 指针和constexpr:const和constexpr区别在哪儿？如果使用了constexpr定义了一个指针，那么constexpr仅对指针有效，而对指针所指的对象无关（这一点和const相反）：   
```
const int *p = nullptr; //p是一个指向整形常量的指针
constexpr int *q = nullptr; //q是一个指向整数的常量指针
```   
p和q的类型相差甚远，关键就在于constexpr是把它所定义的对象定义为了顶层const，这样意味着它可以随便指向常量或者非常量:   
```
constexpr int *np = nullptr;  
int j = 0;
constexpr int i = 42;  //i的类型是整形常量
//i和j都必须定义在函数体之外
constexpr const int *p = &i; //p是常量指针，指向整形常量i 
constexpr int *p1 = &j; //p1是常量指针，指向整数j
```   

18. 类型别名（type alias）: 有两种方法实现类型别名。一种方法是使用传统的``typedef``：
```
typedef double wages;  
typedef wages base, *p; //base是double的同义词，p是double*的同义词
```
C++11新的声明方法，使用别名声明（alias declaration）来定义类型别名:   
```
using SI= Sales_item;  //SI是Sales_item的同义词
```    

19. 指针、常量和类型别名：   
如果某个类型别名指代的是复合类型或者常量，那么把它运用到声明语句里就会产生意想不到的后果，例如下个例子当中的pstring实际上是char*的别名：   
```
typedef char *pstring; 
const pstring cstr = 0; //cstr是指向char的常量指针
const pstring *ps; //ps是一个指针，它的对象是指向char的常量指针
```   
这里极其容易混淆的是，pstring实际上是指向char的指针，因此const pstring指的是指向char的常量指针（**因为const是对给定类型的修饰符**）, 而非指向常量字符的指针。   
遇到一条使用了类型别名的声明语句，人们往往会错误地尝试把别名替换成它本来的样子，来理解该语句的含义：   
```
const char *cstr = 0;
```
而这样的展开或者替换完全错误，这是因为const char连写注定了后面的*修饰的是这个整体；   

20. auto类型说明符：
auto让编译器通过初始值来推断变量的类型，显然，**auto定义的变量必须有初始值**：
```
auto item = val1 + val2; //item初始化为val1和val2相加的结果
```   
使用auto也能在一条语句中声明多个变量，但是同一个声明语句中只能有一个基本数据类型，所有该语句中所有变量的初始基本数据类型都必须一样：   
```
auto i = 0, *p = &i;  //正确：皆为整形数据或指针
auto sz = 0, pi = 3.14; //错误：sz和pi类型不一致
```    
编译器推断出的auto类型有时候和初始值类型会不完全一样。
首先，由于使用引用时直接使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：   
```
int i = 0, &r = i;
auto a = r; //a是一个整数
```
其次，auto一般会忽略顶层const，同时底层const会保留下来，例如初始值是一个指向常量的指针时：   
```
const int ci = i, &cr = ci;
auto b = ci; //b是一个整数（ci顶层const特性被忽略）
auto c = cr; //c是一个整数（cr是别名，ci本身是一个顶层const）
auto d = &i; //d是一个整形指针（整数的地址就是指向整数的指针）
auto e = &ci; //e是一个指向整数常量的指针（对常量对象取地址是一种底层的const）
```   
(这里从b可以看出顶层const既可以是指针，还可以是引用的形式)   
如果希望推断的auto类型是一个顶层const，则需要进行明确指出：   
```
const auto f = ci;  //f是const int
```   
还可以将引用的类型设定为auto，此时原来的初始化规则依然适用：   
```
auto &g = ci;   //g是个整形常量引用，绑定到ci
auto &h = 42;   //错误：不能将非常量引用绑定字面值
const auto &j = 42; //正确：可以为常量引用绑定字面值
```   
设定一个类型为auto引用时，初始值中的顶层常量属性依然保留。和往常一样，**如果我们给初始值绑定一个引用，此时的常量就不是顶层常量了**（说白了最后发现auto引用是整体引用，和auto本身有一定差别）。   
同上，如果要在一个语句中定义多个变量，需要记住&和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一个类型：   
```
auto k = ci, &l = i;  //k为整数，l为整形引用   
auto &m = ci, *p = &ci; //m是对整形常量的引用，p是指向整形常量的指针
auto &n = i, *p2 = &ci; //错误，因为i的类型为int而&ci的类型为const int
```   

21. decltype类型指示符：有时候会遇到希望从表达式类型推断出要定义的变量的类型，但是又不想用该表达式的值初始化变量的情况。这里C++11引入``decltype``作为返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，但是却不计算表达式的值：   
```
decltype(f()) sum = x; //sum的类型就是函数f返回的类型
```   
编译器并不会直接调用函数f，而是使用当调用发生时f的返回类型作为sum的类型。   
decltype处理顶层const和引用方式和auto略有不同，如果decltype使用的表达式是一个变量的话，那么decltype返回该变量的类型（包含顶层const和引用在内）：   
```   
const int ci = 0, &cj = ci;
decltype(ci) x = 0;  //x类型为const int
decltype(cj) y = x;  //y类型为const int&, 绑定到变量x
decltype(cj) z;  //错误：z是一个引用，必须进行初始化处理
```    
需要指出的一点是，引用从来都是作为其所指向的对象的同义词出现，只有在decltype处是一个例外，下面会进行解释。   
如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。而有些表达式会返回一个引用类型，一把来说这种情况发生时，意味着该表达式的结果对象能够作为一条赋值语句的左值：   
```
//decltype的结果可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; //正确：加法结果为0，所以b为一个int（没有初始化）
decltype(*p)       //错误：？c是int&,必须进行初始化
```
因为r是一个引用，因此decltype(r)的结果是引用类型。如果想让结果类型是r所指向的类型，可以将r作为表达式的一部分，例如r + 0。这样就巧妙的将表达式的结果表示为一个具体值而不是一个引用。    
另一方面，如果表达式内容**是解引用操作, 则decltype将得到引用类型**，正如我们熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，所以decltype(*p)的结果类型就是int&而非int。   
> Tip: 解引用操作符指的是\*在C++中，用于得到操作数所指向变量的引用（这说明\*不是单纯的指向原操作数，而是一个引用）   
decltype和auto另一处区别在于变量加上括号后可能结果类型会发生改变：   
```
decltype((i)) d;  //错误：d是int&,必须初始化
decltype(i) e;    //正确：e是一个未初始化的int
```   
原因在于给变量套上括号后，编译器就会把它当做一个表达式。   

22. 自定义数据结构：   
如果数据结构一上来就准备好使用对应的变量，一般可以写成：   
```
struct Sales_data {/**/} accum, trans, *salesptr;
//也可以写成
struct Sales_data {/**/};
Sales_data accum, trans, *salesptr;
```   
C++11规定，可以为数据成员提供一个**类内初始值**。   
    
## 第3章 字符串、向量和数组    
1. using形式不仅可以使用整个命名空间，更可以单独指定某个符号：   
```
using std::cout; 
using std::endl;
```   
Tip:头文件不应该包含using声明，这是因为头文件的内容会被拷贝到所有引用它的文件中去。如果头文件中有某个using声明，则会导致所有使用该头文件的文件都有这个声明，这样就会导致可能的冲突。    

2. 直接初始化和拷贝初始化：使用等号，即为拷贝初始化，如果不使用等号，则执行的是直接初始化。   

3. 使用getline读取一整行数据：   
```
int main()
{
    string line;
    //每次读入一整行，直到到达文件末尾
    while (getline(cin, line))
        cout << line << endl;
    return 0;
}
```    
注意，保存到line当中的对象并不包括换行符，哪怕一开始为换行符（这种情况下为空）   

4. string::size_type:这体现了标准库类型是与机器无关的特性，如果一条表达式中已经有了size()函数就不要再使用int了，可以避免混用int和unsigned可能带来的问题。 可以使用decltype来解决这个问题  
```
for (decltype(s.size()) index = 0; index != s.size() && isspace(s[index]); ++index)
    s[index] = toupper(s[index]); //将当前字符改成大写形式
```

5. 字面值不可以直接相加：   
```
string s7 = "hello" + "," + s2; //字面值必须和string类型相邻相加才可以继续进行
```   

6. 新的for使用准则：C++11中引入了新范围语句    
```
for (declaration: expression)
    statement
```   
例如：    
```
string str("some string");
//每行输入str中的一个字符
for (auto c : str)
    cout << c << endl;
```    

7. vector对象初始化： C++11支持使用花括号来进行vector对象初始化：   
```
vector<string> articles = {"a", "an", "the"};
vector<string> v0{"a", "an", "the"};
```   
使用花括号或者圆括号来区分列表初始值还是元素数量：    
```
vector<int> v1(10);  //v1有10个元素，每个值都是0
vector<int> v2{10};  //v2有1个元素，值为10
vector<int> v3(10, 1); //v3有10个值为1的元素
vector<int> v4{10, 1}; //v4有2个元素，值分别为10为1
```   
某些操作可能会让迭代器操作失效（pushback在遇到一定体量后，会重新修改了迭代器所指的空间内容）   

8. 迭代器的运算：迭代器可以和一个整数值相加（或相减），其返回值为一个移动了若干位置的迭代器。例如要获得一个指向vector对象中间位置的元素：    
```
//计算得到最接近vi中间元素的一个迭代器
auto mid = vi.begin() + vi.size() / 2;
```    
两个迭代器类型相减，得到的类型是名为**difference_type**的带符号整数型。   
这里给出一个迭代器用于二分搜索：   
```
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg) / 2;
while (mid != end && *mid != sought)
{
    if (sought < *mid)
        end = mid;
    else 
        beg = mid + 1;
    mid = beg + (end - beg) / 2; 
}
```

9. 数组：大小不变的存储结构，可用花括号进行初始化。**并且不支持拷贝给其他数组或者赋值**（有些支持该操作的编译器称之为编译器扩展，应当避免使用）；   
复杂数组声明的例子：   
```
int *ptrs[10];   //ptrs是含有10个整形指针的数组
int &refs[10] = /*?*/; //错误，不存在引用的数组
int (*Parray)[10] = &arr;  //Parray是指向一个含有10个整数的数组
int (&arrRef)[10] = arr;   //arr引用一个含有10个整数的数组
```   
一般的，依据**类型符由右向左绑定**的规律。例如ptrs由右向左：首先是一个10大小的数组，它的名字是ptrs，然后知道其指向类型为指向int的指针。   
特例在于Parray，由右向左理解似乎不太合理，更合理的方式在于**由内向外的顺序**。首先*Parray意味着Parray是一个指针，接下来看右侧，知道Parray是个指向大小为10的数组的指针。最后观察左边，可以知道数组中的元素是int。   
总结：判断数据类型由**先由内至外，后从右至左**来进行判断。    
```
int *(&arry)[10] = ptrs; //arry是数组的引用，该数组有10个指针
```    

10. size_t:使用数组下标时，通常定义为size_t类型，它是一种及其相关的无符号类型(类似difference_type)，它被设计得足够大来表示内存中任意对象大小。    
同样可以使用新for语句适用于数组的遍历：   
```
for (auto i : scores)
    cout << i << " ";
```

11. 指针和数组：首先auto是支持指针的
```
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia); //ia2是一个整形指针，指向ia第一个元素
ia2 = 42; //错误：ia2作为一个指针，不可以用int值给指针赋值
```   
必须支出的是，如果使用decltype关键字时上述转换不会发生，decltype(ia)返回的是10个整数构成的数组:   
```
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
ia3 = p; //错误：不能将整形指针给数组赋值
ia3[4] = i; //正确：吧i赋值给ia3的一个元素
```   
总结：decltype覆盖范围没有auto大    

12. 指针也是迭代器：虽然说我们一般不会使用指向尾元素的下一个元素，但是可以用于模仿迭代器模式对数组进行遍历
```
int *e = &arr[10]; //指向arr尾元素的下一个位置的指针
for (int *b = arr; b != e; ++b)
    cout << *b << endl;
```   

13. 标准库函数begin和end：为了减少尾后指针极可能使用出错的情况，C++11引入了标准库函数begin和end，包含在iterator头文件中：    
```
int ia[] = {0,1,2,3,4,5,7,8,9};
int *beg = begin(ia); //指向ia首元素
int *last = end(ia); //指向arr尾元素下一位置的指针
```    
例如寻找到一个数组中的第一个负数：   
```
int *pbeg = begin(arr), *pend = end(arr);
while (pbeg != pend && *pbeg >= 0)
    ++pbeg;
```   

14. 指针运算：众所周知指针可以进行运算。和迭代器的difference_type不同，两个指针相减结果是一种名为**ptrdiff_t**的标准库类型：   
```
auto n = end(arr) - begin(arr); 
```   
和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中机器相关的类型，因为其差值可能为一个负数，所以ptrdiff_t是一个带符号类型。     
只要两个指针指向同一个数组的元素（或者尾元素的下一个元素），就能利用关系运算符对其进行比较，例如下面这个遍历数组中元素的例子：       
```
int *b = arr, *e = arr + sz;
while (b < e) {
    //使用*b
    ++b;
}
```

15. 下标和指针：下标也可以及其自由的使用，例如：   
```
int ia[] = {0,2,4,6,8};
int *p = &ia[2];
int j = p[1];   //指向ia[3]
int k = p[-2];  //指向ia[0]
```
虽然string和vector也能执行下标运算，但是还是略有不同，标准库类型都限定了下标必须是无符号类型，而内置的下标没有这个限制。   

16. 与旧代码的接口：   
1) 混用string对象和C风格字符串：string提供了c_str()函数来转化为c风格的字符串类型：   
```
const char *str = s.c_str();
```   
2) 使用数组初始化vector对象：   
vector的初始化其实不用逐一赋值，用迭代器(指针)的方法非常便捷：   
```
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));
```   
这种方法另一个好处是可以提出中间一部分对象：   
```
vector<int> subVec(int_arr + 1, int_arr + 4); //拷贝了三个元素，分别为1、2、3
```     
> 建议：尽量使用标准库类型而非数组，例如C++程序应尽量使用vector和迭代器而非使用内置数组和指针，使用string而非c风格基于数组的字符串；   

17. 多维数组：严格来说C++语言中没有多维数组，通常说的多维数组本质是数组的数组，理解这一点对日后使用多维数组大有裨益。   
```
int ia[3][4];  //大小为3的数组，每个元素时含有4个整数的数组
int arr[10][20][30] = {0}; //大小为10的数组，每个元素为大小为20的数组，而这些数组元素是含有30个整数的数组，最终将每个元素初始化为0
```   
阅读顺序依然遵照由内而外的规律，例如ia是一个3个元素的数组，同时这每一个元素本身都是含有4个元素的数组。   
多维数组的初始化类似普通数组，每一行都用花括号括了起来：   
```
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
};
```   
而事实上内嵌花括号并非必须，同样可以使用一位数组形式以更简洁的方式完成以上的初始化工作（前提是没有错误）：   
```
int ia[3][4] =  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
```    
也可以显示的初始化每行首元素（仅仅）：   
```
int ia[3][4] = {{0} , {4}, {8}};
```   
如果只是显式的初始化第一行元素，其它元素被初始化为0：    
```
int ix[3][4] = {0, 3, 4, 9};
```   
下标引用：**如果表达式含有的下标运算符和数组维度一样多，该表达式的结果将是给定类型的元素，如果比数组维度小，则将是返回一个给定索引处的一个内层数组**:   
```
ia[2][3] = arr[0][0][0]; //首元素赋给ia最后一个元素
int (&row)[4] = ia[1]; //将row绑定到ia的第二个4元素数组上
```   
另一个例子，常用两层嵌套来处理多维数组:   
```
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt]; 
for (size_t i = 0; i != rowCnt; ++i) //对于每一行
{
    for (size_t j = 0; j != colCnt; ++j)  //对于每一列
    {
        ia[i][j] = i * colCnt + j;
    }
}
```   
更简洁的，使用C++11的范围语句，可以简化为：   
```
size_t cnt = 0;   
for (auto &row : ia)
    for (auto &col : row) {
        col = cnt;
        cnt++;
    }
```   
这里有个很有意思的地方，为什么要强制使用引用？本质在于避免自动转化为指针：如果不使用引用类型，循环形式如下：
```   
for (auto row : ia)
    for (auto col : row)
```    
程序将会无法通过编译，这是因为，第一个循环ia所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类型，编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转换为指向给数组内首元素的指针，那么得到的row类型就是int*，因此内存循环就不合法了（编译器将试图在一个int*内进行遍历）   
> Note:要使用范围for语句处理更多的多维数组，除了最内层的循环外，其他所有的循环的控制变量都应该是引用类型。    
指针和多维数组：当程序使用多维数组的名字时，也会自动将其转换为指向数组首元素的指针。   
```
int ia[3][4];    //大小为3的数组，每个元素是含有4个整数的数组
int (*p)[4] = ia; //p指向含有4个整数的数组
p = &ia[2];  //p指向ia的尾元素
```  
> Note: 上述声明中，圆括号必不可少
> int *ip[4]; //包含4个整形指针的数组
> int (*ip)[4]; //指向包含4个整数的数组的指针    
C++11新标准可以使用auto或者decltype来避免对指针遍历时再定义一个指针类型了：   
```
for (auto p = ia; p != ia + 3; ++p)
    for (auto q = *q; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
```    
使用标准库函数begin和end可以获得同样的功能，而且形式表达上更加简洁：   
```
for (auto p = begin(ia); p != end(ia); ++p)
    for (auto q = begin(*p); q != end(*p); ++q)
        cout << *q << ' ';
    cout << endl;
```   
这样就既不用在乎size也不用在乎类型。如果需要更进一步，使用类型别名可以使这个过程更加简单一些，例如：   
```
using int_array = int[4]; //C++11新标准声明别名的形式
//或者使用
typedef int int_array[4]; 

for (int_array *p = ia; p != ia + 3; ++p)
    for (int *q = *p; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
```   

## 第4章 表达式
1. 基础：   
C++定义了一元(取地址符&/解引用符*)、二元、三元（A?B:C）运算符
左值右值：
C中，单纯的指左值只能位于赋值表达式的左侧，右值只能位于赋值表达式的右侧；   
C++中，当一个对象被用作右值时，用的是对象的内容（值）；而当对象被用作左值时，用的是对象的身份（在内存中的位置）；   
和C比起来，左值一方面在为常量时，并不能作为赋值语句的左侧运算对象，另一方面，虽然有些表达式求值结果是对象，但是它们是右值而非左值。   
运算符操作的一个重要原则在于**需要右值的地方，可以用左值代替，但是反之不成立**，并且当一个左值被当成右值使用时，实际使用的就是它的值（内容）。   
> Tip: 使用关键字decltype时，左值和右值也略有不同，如果求值结果为左值，则decltype作用于该表达式（非变量）得到一个引用类型。例如p的类型为int*,因为解引用符生成左值，故decltype(*p)得到一个int&。另一方面取地址运算符生成右值，故decltype(&p)的结果是int**, 也就是一个指向整形指针的指针。   
求值顺序：运算符的优先级决定了运算对象的组合方式，但是没有框定运算对象按什么顺序求值。**大多数情况下不会明确指定求值的顺序**，例如：   
```
int i = f1() * f2();
```   
这里对于不同的编译器来说，就无法判断是f1先调用还是f2先调用。还有例如：  
```
int i = 0; 
cout << i << " " << ++i << endl; //未定义
```
这种输入结果各种编译器也会有很大区别，完全不可预知。所以编程中尽量避免这种写法。**这给我们的启示是尽量在复杂的表达式中对同一个对象进行多次操作（至多一次）**，如果实在是需要，请用括号加以限制。  
但是有4种运算符明确了其运算对象的求值顺序，&&（逻辑与）规定了先求左侧并且只有左侧为真时才能继续求右侧（**这个很有用，尤其在判断输入变量是否满足标准的情况下**），另三种分别为逻辑或(||)、条件(?:)与逗号(,);   
2. 取余运算：取余运算的定义为，如果m和n是整数且n并非0，则m = (m/n) * n + m % n。其隐含意思为，**如果m % n不等于0，那么其结果应该始终和m的符号相同**，根据这个原则，我们不难求出：   
```
-21 % 8 = -5; -21 / -8 = 2;
21 % -5 = 1;  -21 / 5 = -4;
```   

3. 逻辑运算符：上面提过，对于逻辑与和逻辑或（&&和||）都是先求左侧对象值再求右侧对象之（除非左侧运算对象无法确定表达式才会计算右侧运算对象的值），这种策略称为短路求值（short-circuit evaluation）,一个示范可以用于指针为空和size的判断，这样可以显得语法更加简洁：   
```
bool isTen(QVector<int> *iptr){
    if (iptr && iptr->size() == 10)
        return true;
    return false;
}
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    qDebug() << isTen(Q_NULLPTR);
    return a.exec();
}
```   

4. 赋值运算符：赋值运算符合右结合律，这一点和其他的二元运算符不太一样，最常见的就是**多重赋值**，当然，这种语句必须类型转换正确：   
```
int ival, jval;
ival = jval = 0;  
```   
较低优先级的赋值运算带来的写法变换：**赋值语句经常出现在条件中**，这是因为赋值运算优先级低，通常需要给赋值语句加上括号来使得其符合我们的原意。下面给一个例子说明赋值语句放在条件语句中有什么用处，它的目的是反复调用一个函数直到返回期望的值为止：   
```
//以下为一个形式繁琐，易出错的写法
int i = get_value();   
while (i != 42)
{
    //其它处理...
    i = get_value(); //得到下一个值，继续判断
}
```   
实际上可以简化为：   
```
int i;
while ((i = get_value()) != 42)
{
    //其他处理...
}
```
这个处理更加简洁，也证明了赋值运算符本身较低的运算符。   
复合赋值运算符：+=、-=、*=、/=、%=、<<=、>>=、&=、^=、|=，其本质和其本身表达式只是稍有区别``a = a op b``，其实在很多地方，这种区别对于程序的影响几乎可以忽略不计。   

5. 递增与递减运算符（++/--）：除非必须，一般不使用递增递减运算符的后置版本，这里从另一个方面揭示了**为什么前置++的效率比后置++高？**，这是因为**前置直接返回了这个数自身+1的内容，而后置版本还需要先把原始值存储下来，用于返回这个未修改的内容**，如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。   
当然任何问题都不是绝对的，如果我们遇到在一条复合表达式中既将变量+1或减-1又能使用其原始值，这时候就可以使用递增和递减运算符的后置版本，例如以下这个例子：   
```
auto pbeg = v.begin();
while (pbeg != v.end() && *pbeg >= 0)
    cout << *pbeg++ << endl;
```   
> Tip: 虽然*pbeg++的表达式可能不太一定容易理解，但是其实这是一种更有效的写法，远比书写**cout << *pbgeg << endl; ++pbeg;**要更加简洁非，并且也更少出错。大多数C++程序追求简洁、摒弃冗长，应该习惯于这种写法。    
> Tip: 注意++极容易引起任意求值顺序问题的错误；   

6. 条件运算符：条件运算符(?:)已经非常常用，这里有两点注意点：   
1) 嵌套使用：
```
finalgrade = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : "pass";
```   
不过注意，如果超过两层，代码的可读性急剧下降；   
2) 在输出表达式中使用条件运算符：这里极其容易造成问题的原因是因为条件运算符的优先级很低，应该加以括号进行限制；   
```
cout << ((grade < 60) ? "fail" : "pass"); //输出pass或fail
cout << (grade < 60) ? "fail" : "pass"; //输出1或者0
cout << grade < 60 ? "fail" : "pass"; //错误，因为试图比较cout和60
```   

7. 位移运算符：位运算符作用于整数类型运算对象，并把运算对象看成是二进制位的集合。同时C++提供了bitset类（标准库）可以表示任意大小的二进制位集合，所以位运算符同样能用于bitset类型。   
有两个平时用的比较少的位运算符：**~求反运算符、^异或运算符**
> Warning: 位运算没有规定只能使用于有符号整形还是无符号整形，一般推荐仅将位运算符用于处理无符号整形。   
求反运算符:会将char类型的运算对象提升为int类型（向高位添加0即可），然后逐位求反。   
移位运算符（又叫IO运算符）满足左结合律，例如：   
```
cout << "hi" << "there" << endl;
```
等同于：   
```
((cout << "hi") << " there") << endl);
```     
移位运算符优先级不高不低，介于中间：比算术运算符优先级低，但是比关系运算符、赋值运算符和条件运算符的优先级高。    
```
cout << 42 + 10; //52
cout << (10 < 42); //1
cout << 10 < 42; //错误：试图比较cout和42
```   

8. sizeof运算符：返回一个表达式或者一个类型名字所占的字节数，其使用形式有两种：   
```
sizeof(type)
sizeo expr
```  
第二种形式中，sizeof返回的是表达式结果类型的大小，稍微不一样的是，sizeof并不计算其运算对象的值：   
```
Sales_data data, *p;  
sizeof(Sales_data); //存储Sales_data类型对象所占的空间大小   
sizeof data;        //data的类型大小，即sizeof p;           //指针所占空间大小
sizeof *p;          //p所指类型的空间大小，即sizeof(Sales_data)    
sizeof data.revenue;  //成员对应类型大小
sizeof Sales_data::revenue; //另一种获取revenue大小的方式
```   
其中最有意思的就是``sizeof *p``,其中即使p为空指针也不会影响最终的结果，因为sizeof根本也不需要通过运算值就可以知道类型的大小。   
最后一个例子则揭示了，C++11新标准中，使用了作用域运算符来获取类成员的大小。   
9. 逗号运算符：逗号运算符经常被人忽略。其运算遵循：先对左侧的表达式求值，然后将求值最终结果丢掉。逗号运算符的真正结果是右侧表达式的值，如果右侧表达式是一个左值，那么最终的求值结果就是个左值；   
最常见的逗号运算符的使用见于for循环中：     
```
vector<int>::size_type cnt = ivec.size();   
for (vector<int>::size_type ix = 0;ix != ivec.size(); ++ix, --cnt)
    ivec[ix] = cnt;
```   

10. 类型转换：任何编程语言都无法避免类型转换这个话题。首先最简单的是隐式转换（implicit conversion）。其次是算数转换。    
整形提升：false提升为0，true提升为1；小char型（bool、char、short等）都会转换为int，其余的提升为unsigned int。   
较大的char类型（wchar_t、char16_t、char32_t）提升为int、unsigned int、long、unsigned long、long long和unsigned long long中的最小的一种类型。

11. 显式转换：   
命名强制转换具有以下形式：   
```
cast-name<type>(expression);
```   
其中type是目标类型而expression是要转换的值，如果type是引用，则结果是左值。而cast-name会从**static_cast、dynamic_cast、const_cast和reinterpret_cast**
static_cast:    
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。例如：   
```
int i, j;
double slope = static_cast<double>(j) / i;
```   
当需要把一个较大的算数类型赋值给较小的类型时，static_cast非常有用。此时强制类型告诉程序阅读者和编译器：这里机器知道并且不在乎潜在的精度损失（这可以避免一大批warning）；     
static_cast对于编译器无法自动执行的类型转换也非常有用，例如找回存在于void*的指针：   
```
void *p = &d;   //正确：任何非常量对象的地址都能存入void*   
double *dp = static_cast<double*>(p); //转换为double类型指针
```     

const_cast:     
const_cast只能改变运算对象是底层const，例如：    
```
const char *pc;
char *p = const_cast<char*>(pc); //正确：但是通过p改变值是未定义的行为
```    
这样把常量对象转换为非常量对象的行为，我们一般称为去掉const性质，编译器也就不会再组织我们对该对象进行写操作。如果对象本身不是一个常量，这样的行为就是合法的，但是如果是一个常量，就容易会产生未定义的后果。    
const_cast的特殊之处就在于只有它能够改变表达式的常量属性，其他cast—name强制类型转换表达式的常量属性都会导致编译器错误。同理，也不能用const_cast改变表达式的类型：   
```
const char *cp;
char *q = static_cast<char*>(cp); //错误：static_cast不能转换掉const性质   
static_cast<string>(cp); //正确：将字符串字面值换为string类型
const_cast<string>(cp);  //错误：const_cast只能改变常量属性，而不能改变类型
```   
> Tip:const_cast常常用于有函数重载的上下文中，下文将会进行介绍   

reinterpret_cast:     
reinterpret_cast通常为对象的位模式提供较低层次上的重新解释，例如有以下转换：   
```
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```   
这里需要牢记pc所指向的真实对象是一个int而非字符，如果把pc当成普通的字符指针就可能在运行时发生错误。例如：   
```
string str(pc);
```     
可能导致异常的运行时行为。

> Suggestion:避免强制类型转换时对于检查类型的建议，这个建议对于reinterpret_cast尤其适用，因为这种类型转换总是充满了风险。比较无可厚非的使用是在有重载函数的上下文中使用const_cast，但是在其它情况下使用const_cast也就意味着程序存在某种设计缺陷。其它强制类型转换，例如static_cast和dynamic_cast，都不应该频繁使用。每书写一条强制类型转换语句，都应该反复斟酌是否能以其它方式事项相同目标。    
**应摒弃早期的强制转换写法**，即type(expr)或者(type)expr，因为这样的类型转换会带来不一样的结果，**完全应该使用static_cast或者const_cast替换**；   

## 第5章 条件语句    
当程序对的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时检测出问题的部分应该发出某种信号来表明程序遇到了故障，无法再继续下去了。**而且信号的发出方无需知道故障将在何处得到解决**。一旦发出异常信号，检测出问题的部分也就完成了任务。   
如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据，如果丢失了数据库连接，会发出报警信息。    
异常处理机制为程序中的异常检测和异常处理这两部分的协作提供支持，在C++语言中，异常处理包括：   
- throw表达式：异常检测部分使用throw表达式表示它遇到了无法处理的问题。   
- try语句块：异常处理使用try语句块处理异常。try语句块以关键字try开始，并以一个或者多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称为**异常处理代码**。   
- 一套异常类，用于在throw表达式和对应的catch子句之间传递异常的具体信息。   
1. throw表达式：程序的异常检测使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。   
举个例子，例如检查是否是同一种书籍，然后判断其是否能够相加：   
```
Sales_item item1, item2;
cin >> item1 >> item2;
//首先检查item1和item2是否表示同一种书籍
if (item1.isbn() == item2.isbn()) {
    cout << item1 + item2 << endl;
    return 0; //表示成功
} else {
    cerr << "Data must refer to same ISBN" << endl;
    return -1; //表示失败
}
```    
在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序使得检查完成后不再直接输出一条信息，而是抛出一个异常：   
```
//首先检查两条数据是否关于同一种书籍的
if (item1.isbn() == item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
//如果程序执行到这里，表示两个ISBN是相同
cout << item1 + item2 << endl;
```   
这段代码中，如果ISBN不一样就会抛出一个异常，该异常时类型runtime_error的对象，抛出异常就会**终止当前的函数，并且把控制权交给能处理该异常的代码**。   
类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。我们必须使用一个string对象或者一个C风格的字符串来初始化一个runtime_error对象。   

2. try语句块：其通常形式如    
```
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} //...
```     
在之前的例子里，我们使用了一个throw表达式来避免把两个代表不同书籍的Sales_item相加。我们假设执行Sales_item对象加法的代码时与用户交互的代码分离开来的。其中与用户交互的代码负责处理发生的异常，它的形式可能如下：   
```
while (cin >> item1 >> item2) {
    try {
        //执行添加两个Sales_item对象的代码
        //如果添加失败，代码抛出一个runtime_error
    } catch (runtime_error err) {
        //提醒用户两个ISBN必须一致，询问是否重新输入   
        cout << err.what() 
             << "\nTry Again? Enter y or n" << endl;
        char c;
        cin >> c;
        if (!cin || c == 'n')
            break;
    }
}

```   
程序本来要执行的任务出现在try语块中，因为这段代码可能会抛出一个runtime_error类型的异常。   
try语句块对应一个catch的子句，该子句负责处理类型为runtime_error的异常。如果try语句块的代码抛出了runtime_error异常，接下来执行catch块内的语句。在我们书写的catch子句中，输出一段提示信息要求用户指定程序是否继续。   
给用户的提示信息中最后输出了err.what()的返回值，其实就是其初始化的字符串。   
函数在寻找处理代码的过程中退出：在复杂系统中，程序在抛出异常代码之前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能又调用了一个包含新的含有try语句块的函数，依次类推。   
寻找处理代码的过程与函数的调用链正好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没有找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也会被终止，继续搜索调用它的函数。以此类推，沿着程序执行的路径逐层回退，直到找到适合类型的catch的子句为止。   
如果最终还是没找到与任何匹配的catch子句，程序转到名为terminate的标准库函数，该函数行为和系统有关，一般情况下执行该函数将会导致程序非正常退出。     
对于那些没有任何try语句块定义的异常，也按照类似的方式处理；毕竟，没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。    
3. 标准异常：
C++标准库定义了一组类，用于报告标准库函数中遇到的问题，这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中：   
- exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。   
- stdexcept头文件定义了几种常用的异常类，这些类会在下面表中列出。   
- new头文件定义了bad_alloc异常类型。   
- type_info头文件定义了bad_cast异常类型。   
    
## 第6章 函数
1. 函数基础：这里已经非常熟悉，不过有一些需要注意的点是   
- 传入函数的实参的顺序并没有规定，编译器可以以任何顺序对实参求值（这意味着传入的实参千万不能互相打架）    
- 函数的**返回类型不能是数组类型或者函数类型**，但是可以是指向数组或者函数的指针，下文会介绍如何返回数组的指针/引用以及函数的指针。   
> Tip:一个函数中的静态变量可以很方便的进行所谓次数统计的工作，这一点非常特别，当然它们只会在第一次运行时初始化一次。   
```
size_t count_calls()
{
    static size_t ctr = 0;  
    return ++ctr;
}

int main() {
    for (size_t i = 0; i != 10; i++)
        cout << count_calls() << endl;
    return 0;
}
//将会输出1到10的数字
```     
2. 参数传递：   
- 使用引用避免拷贝：除了已经熟知的原因（不复制对应的对象），还有一些原因例如某些类型根本不支持拷贝（例如IO类型）
- 利用引用返回多参数：一个经常使用的技巧就是使用引用来返回额外的信息     
- const形参和实参：顶层const只作用于对象本身   

```
const int ci = 42;  //不能改变ci，const是顶层的
int i = ci;  //正确：当拷贝ci时，会忽略它的顶层const
int * const p = &i;  //const是顶层的，不能给p赋值
*p = 0;
```     
- 尽量使用常量引用：应该从底层函数就注意使用该原则，这样避免设计高一阶函数时出现该问题；
- 数组形参：前面提过，数组有两个性质限制了其在函数使用中有区别——1) 不允许拷贝数组；2) 使用数组时通常会将其转换成指针；尽管不能以值传递的方式传递数组，但是我们可以把形参转换为类似数组的形式：   

```
//以下三个print函数等价
void print(const int*);
void print(const int[]);
void print(const int[10]); //这里的10只能表示我们希望的数组的大小，实际并不一定
```
随之而来的问题就是管理指针形参数量问题，通常使用：   
1) 使用标记指定数组长度：例如C风格字符串到\0之前确认为有效；   
2) 使用标准库规范:向函数传递数组的首元素和尾后元素的指针，这种方法收到标准库技术的启发，例如：   
```
void print(const int *beg, const int *end)
{
    while (beg != end)
        cout << *beg++ << endl;
}
```
调用时传入两个指针，可以使用标准库的begin和end函数：   
```
int j[2] = {0, 1};
print(begin(j), end(j));
```
3) 显示的传递一个数组的大小：这种方法在C和传统C++方法中非常常见     

**数组引用形参**：C++允许将变量定义为数组的引用,同理，函数形参也可以是数组是的引用。此时引用形参绑定到对应的实参上，也就是绑定到数组上：   
```
void print(int (&arr)[10])
{
    for (auto elem : arr)
        cout << elem << endl;
}
```   
> Tip:这里需要区分引用的数组和数组的引用之间的区别——f(int &arr[10]) //错误：arr为引用的数组、f(int (&arr)[10]) //z正确：arr为具有10个整数的整形数组的引用    
这里虽然没问题，但是由于指定了数组维度的大小，这样也限制了print函数的可用性，下文中还会给出不限大小形式的输出；    
  
传递多维数组：就像之前介绍的那样，C++语言中实际上没有真正的多维数组，所谓的多维数组其实是数组的数组。    
例子：   
```
//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组
void print(int (*matrix)[10], int rowSize);
{/*...*/}
```
> Tip:同上面的引用数组，注意括号是必须的。   
同样也可以使用数组的语法定义函数，此时编译器会一如既往的忽略掉第一个维度，所以最好不要把它包括在形参列表内：    
```
//等价定义
void print(int matrix[][10], int rowSize){}
```    

**main:处理命令行选项**：    
有时候，我们的确需要给main传递实参，常见的main带参形式我们已经很熟了：   
```
int main(int argc, char *argv[]){...}
```
argc等于记录argv中字符串的数量，因为第二个参数为数组，main函数也可以定义为：   
```
int main(int argc, char **argv){...}
```     
例如在一个可执行文件中传入main函数的内容，
```
prog -d -0 ofile data0
```
那么argc = 5，argv里包含以下C风格的字符串：   
```
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```
> Warning:当使用argv中间的实参时，一定要记得可选的实参从argv[1]开始，**argv[0]保存的是程序的名字，而非用户输入**。

**含有可变形参的函数**：C++11标准提供两种方法来解决编写处理不同数量实参的函数的问题：1) 如果所有是参类型相同，我们可以传递一个名为initializer_list的标准库类型；2) 如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，后面会介绍。    
C++还有一种**省略符**形参，用它可以传递可变数量的实参。下面会进行介绍，但是这种功能一般只用于和C函数的接口程序。    

#### initializer_list形参    
如上文所说，initializer_list针对的是类型相同的形参的模板，和vector一样，在定义时需要包含所属的元素例如：   
```
initializer_list<string> ls; 
initializer_list<int> li;
```    
但是和vector不一样的是，initializer_list对象中的元素永远是常量值。   
例如我们用它来输出错误信息：   
```
void error_msg(initializer_list<string> il)
{
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << " ";
    cout << endl;
}
```
如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内：    
```
if (excepted != actual)
    error_msg({"functionX", excepted, actual});
else 
    error_msg({"functionX", "okay"});
```    
当然，含有initializer_list形参的函数也可以拥有其他形参，例如调试系统可以有个名为ErrCode的类来表示不同类型的错误，因此我们可以改写之前的程序，使其包含一个initializer_list形参和一个ErrCode形参：   
```
void error_msg(ErrCode e, initializer_list<string> il)
{
    cout << e.msg() << ": ";
    for (const auto &elem : il)
        cout << elem << " ";
    cout << endl;
}
```
那么对应的调用形式可以写为：    
```
if (excepted != actual)
    error_msg(ErrCode(42), {"functionX", excepted, actual});
else
    error_msg(ErrCode(0), {"functionX", "okay"});
```    

#### 省略符形参：   
只用于兼容C的varargs的情况，其他情况基本不会使用，形式例如：    
```
void foo(parm_list, ...);
void foo(...);
```    

3. 返回类型和return语句：   
> Tip: **不要反悔局部对象的引用或者指针**，这是因为在生命周期结束后，局部变量所占用的空间也会被释放掉。     
> Tip: 那么什么时候反悔指针和引用呢？例如比较两个数，返回较大的那个数，就可以使用。    
```
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```     

#### 返回类型的函数和调用运算符     
首先调用运算符也有结合律，例如：   
```
auto sz = shorterString(s1, s2).size();
```
**引用返回左值**：函数的返回类型决定是否为左值，调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回的引用，特别是，能够给返回类型（非常量引用）直接赋值：   
```
char &get_val(string &str, string::size_type ix)
{
    return str[ix]; 
}

int main()
{
    string s("a value");
    cout << s << endl; //输出a value
    get_val(s, 0) = 'A';
    cout << s << endl; //输出A value
    
    return 0;
}
```    

**列表初始化返回值**：C++11规定，函数可以返回花括号的值的列表。和其他返回结果一样，此处的列表也用来表示函数返回的临时量进行初始化，例如：   
```
vector<string> process()
{
    if (excepted.empty())
        return {};
    else if (excepted == actual)
        return {"functionX", "okay"};
    else 
        return {"functionX", excepted, actual};
}
```    

递归：main函数不能递归    

**返回数组指针**：因为数组不能被拷贝，所以函数不能返回数组，但是函数**可以返回数组的指针或者引用**，有几个比较能够简化这个问题的方法，最简单的是使用类型别名：    
```
typedef int arrT[10]; 
using arrT = int[10];   //以上两条声明等价
arrT* func(int i);      //func返回一个指向含有10个整数的数组的指针
```    
因为arrT是含有10个整数的数组的别名，因为无法返回数组，因此返回一个数组指针。   
#### 声明一个返回数组指针的函数      
之所以推荐使用别名的方式来进行处理，是因为接下来所举的直接返回固定大小数组指针的例子会揭示这么做真的炒鸡烦。    
和上述例子相同，我们如果想要定义一个返回数组指针的函数，则**数组的维度必须跟在函数名字之后**。然后，函数的形参列表应该优先于数组的维度，这样就造成了函数的形式应该写成如下形式：    
```
Type (*function(parameter_list))[dimension]
```     
实例比如这个没有使用类型别名的func函数：   
```
int (*func(int i))[10];
```     
可以按照以下顺序理解这个声明的含义：   
- func(int i)表示调用func函数时需要一个int类型的实参；
- (*func(int i))表示我们可以对函数调用的结果进行解引用操作；   
- (*func(int i))[10]表示解引用func的调用将得到一个大小是10的数组；    
- int (*func(int i))[10]表示数组中元素是int类型。   
#### 使用尾置返回类型    
C++11标准中还提供了一种方法可以简化上述的func声明方法，就是使用**尾置返回类型**，任何函数都能使用尾置返回，但是对于比较复杂的类型最为有效。比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并且以一个->符号开头，为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto:      
```
//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组   
auto func(int i) -> int(*)[10]
```
#### 使用decltype   
还有一种情况，如果我们知道函数返回的指针指向哪个数组，就可以使用decltype关键字来声明返回类型，例如：    
```
int odd[] = {0, 1, 2, 3, 4};
int even[] = {5, 6, 7, 8, 9};
decltype(odd) *arrPtr(int i)
{
    return (i % 2) ? &odd : &even;
}
```     
decltype表示arrPtr返回类型是一个指针（不应该是一个数组吗），并且该指针所指的对象与odd类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组指针。    
> Tip:值得注意的是，declctype并不负责把数组类型转成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还需要在函数声明时加一个*符号。    

4. 函数重载：    
定义：**如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载**。（关键词：名字相同、形参不同）    
**重载和const形参**：     
根据前文所说，**顶层const不影响传入该函数的对象** ，一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：   
```
Record lookup(Phone);
Record lookup(const Phone);  

Record lookup(Phone*);
Record lookup(const Phone*);
```    
以上两组都是重复声明，每一组的第二个声明和第一个声明都是等价的。      

另一方面，如果形参是某种类型的指针或者引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时const是底层的：    
```
//对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同   
//定义了4个独立的重载函数
Record lookup(Account&);  
Record lookup(const Account&);   //新函数，用于常量引用

Record lookup(Account*);
Record lookup(const Account*);   //新函数，作用于指向常量的指针
```     
之所以编译不报错的原因是，（**因为是通过是否为底层const来判断**）编译器可以通过实参是否为常量来推断应该调用哪个函数。因为const不能转化为其他类型，所以我们只能把const对象传递给const形参。相反的，因为非常量可以转化为const，所以上面的4个函数都能作用于非常量对象或者只想非常量对象的指针。不过下文中还会介绍，**当我们传递一个非常量对象或者非常量对象指针时，编译器会优先选用非常量版本的函数** 。     

const_cast和重载：     
上文中曾经提过，const_cast在重载函数的情景中最为有用，例如之前的shorterString函数：   
```
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```    
这个函数的参数和返回类型都是const string的引用，我们可以对两个非常量的string实参调用这个函数，但是返回的结果仍然是const string的引用。因此我们**需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用** ，使用const_cast可以做到这一点：   
```
string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1),
    const_cast<const string&>(s2)));
    return const_cast<string&>(r);
}
```    
在这���版本的函数中，首先将它的实参强制转化为对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以将其再转换为一个普通的string&，这显然是安全的。     

#### 调用重载函数        
调用重载函数时需要进行函数匹配，也叫重载确定。当调用重载函数时可能有三种结果：    
- 编译器找到了一个与实参的最佳匹配；
- 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误；   
- 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时就会发生**二义性调用** ；

### 重载和作用域：    
重载对于作用域的一般性质并没有什么改变，如果在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名：   
```
string read();    
void print(const string&);
void print(double);  //重载print函数
void fooBar()
{
    bool read = false;  //新作用域：隐藏了外部的read
    string s = read();  //错误：read是一个bool值
    //通常来说，在局部作用域中声明函数不是一个好的选择    
    void print(int);    //新作用域：隐藏了之前的print
    
    print("Value:");    //错误：print(const string &)被隐藏    
    print(ival);        //正确：当前print(int)可见
    print(3.14);        //正确，虽然调用的print(int)把print(double)屏蔽掉了
}
```     
说白了就是：**一旦编译器在局部找到了外部有的同名函数，将会屏蔽外面所有的同名函数**。    
> Tip：在C++语言中，名字查找发生在类型检查之前。   
5. 特殊用途的语言特性：   
- 默认实参：这个已经很熟了
- 内联函数和constexpr函数：    
> 使用内联函数的原因在于：调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。      
内联函数的作用就在于，在每个调用节点上采取类似inline的方式“内联的”展开。例如之前的shorterString函数，一般调用：   
```
cout << shorterString(s1, s2) << endl;
```    
将会在编译过程中展开为以下形式：   
```
cout << (s1.size() < s2.size() ? s1 : s2) << end;
```    
而创建内联函数只需要在函数一开始加上inline就可以。   
一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。    

- constexpr函数：指的是能用于常量表达式的函数。其和其他函数相比并没有特殊之处，不过需要遵守几项规定——首先函数的返回类型和所有形参都必须是字面值类型，而且函数体中只能有且只有一条return语句：   
```
constexpr int new_sz() {return 42;}
constexpr int foo = new_sz();  
```    
执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果只。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。   
constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行操作就行。例如可以有空语句、类型别名、using声明等。   
我们允许constexpr函数返回值并非一个常量：   
```
//如果arg是常量表达式，则scale(arg)也是常量表达式    
constexpr size_t scale(size_t cnt){ return new_sz() * cnt; }    
```    
当scale的实参是常量表达式时，它的返回值也是常量表达式，反之则不然：    
```
int arr[scale(2)];   //正确：sacle(2)是常量表达式    
int i = 2;           //i不是常量表达式   
int a2[scale(i)];    //错误：scale(i)不是常量表达式
```    
编译器会自动检查是否返回的非常量表达式会用到只能接受常量表达式的场合中，如果有错误，则会报错。     

> Tip: 内联函数和constexpr函数一般都定义在头文件内，这是由于其可以定义多次（而每个定义又必须完全一致）决定的。     

#### 调试帮助：   
C++程序员往往会用到类似头文件保护（#ifdef .h）的结束，以便有选择的执行调试代码。其基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码，这种方法涉及两种预处理功能：assert和NDEBUG;    
assert预处理宏：     
assert是一种预处理宏，其行为类似一个内联函数，使用一个表达式作为其条件：    
```
assert(expr);
```    
首先对expr求值，若表达式为假（即为0），则assert输出信息并且终止程序的执行。若为真(即非0)，则assert什么也不做。    
和预处理变量一样（#define xxx）一样，**宏名字在程序内必须唯一** 。   
          
NDEBUG预处理变量：    
assert行为依赖于一个名为NDEBUG的预处理变量的状态，如果定义了NDEBUG，则assert什么也不做。默认情况下NDEBUG没有定义，此时assert将会执行检查。     
定义NDEBUG能够避免检查各种条件所需的运行时开销，当然此时根本不会执行运行检查。因此，assert应该**仅用于验证那些不可能发生的事** ，我们可以把assert当成调试程序的一种辅助手段，但是并不能代替真正运行时的逻辑检查，也不能替代程序本身应该包含的错误检查。    
除了用于assert以外，也可以使用NDEBUG编写自己的条件调试代码，如果NDEBUG未定义，将执行#ifndef和#endif之间的代码，如果定义了NDEBUG，则这些代码被忽略：    
```
void print(const int ia[], size_t size)
{
#ifndef NDEBUG
    //__func__是编译器定义的一个局部静态变量，用于存放函数的名字   
    cerr << __func__ << ": array size is " << size << endl;  
#endif
}
```    
编译器为每个函数都定义了__func__，它是const char的一个静态数组，用于存放函数的名字。    
除了__func__，预处理器还预留了4个对于程序调试很有用的名字：    
__FILE__:存放文件名的字符串字面值   
__LINE__:存放当前行号的整形字面值
__TIME__:存放文件编译时间的字符串字面值
__DATE__:存放文件编译日期的字符串字面值
可以使用这些常量在错误消息中提供更多信息，例如在日志中的使用；     

6. 函数匹配：     
几个重载函数经常会出现转换困难的问题，例如：    
```
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
f(5.6);   //调用f(double, double)
```    
那么如何确定候选函数和可行函数呢？候选函数具有两个特征，一是与被调用的函数同名，二是声明在调用点可见。    
第二步就是挑出可行函数，也有两个特征：一是其形参数量和本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。    
经过上面两步，接下来需要考虑实参类型是否与形参匹配。既可能是它们具有相同的类型，也可能是实参类型和形参类型满足转换规则。上述例子中第二个和第四个也是符合的。    
如果到这里还没有决出最后的调用对象，那么需要寻找最佳匹配，下文会介绍这里使用的“最匹配”的细节，它的基本思想，实参类型与形参类型越接近，它们匹配的越好。    
含有多个形参的函数匹配：当实参的数量有两个或者更多时，函数匹配就比较复杂了。例如上面这个例子调用：   
```
f(42, 2.56);
```    
选择可行函数的方法只有一个实参时一样，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。此例中，可行函数包括f(int, int)和f(double,double)。接下来，编译器依次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功：    
- 该函数每个实参的匹配都不劣于其他可行参数的匹配；    
- 至少有一个实参的匹配优于其他可行函数提供的匹配。    
如果在检查了所有实参中没有任何一个函数脱颖而出，则该调用是错误的，编译器将会报二义性的错误。    
上面的调用中，只考虑第一个实参时我们发现函数f(int,int)能精确匹配，要相匹配第二个函数，则int类型必须转化为double类型，显然需要内置类型转换的匹配劣于精确匹配，故就第一个参数而言编译器认为第一个函数胜。    
接着考虑第二个参数，很明显编译器还会认为第二个函数优于第一个函数。    
所以，编译器只能老老实实的报出二义性错误，因为每个可行函数各自在一个实参上实现了更好的匹配。看起来我们似乎可以通过强制类型转换其中一个参数来实现函数的匹配，但是设计良好的系统中，不应该对实参进行强制类型转换。    
> Advice:调用重载函数时应该尽量避免类型转换，如果实际中确实需要强制类型转换，则说明设计的形参集合不合理。     

#### 实参类型转换：    
为了确定最佳匹配，编译器将实参类型到形参类型转换划分为了几个登记，如下所示：   
1) 精确匹配，包括以下情况：    
- 实参类型和形参类型相同；
- 实参从数组类型或函数类型转换为对应的指针类型；   
- 向实参添加顶层const或者从实参中删除顶层const。   
2) 通过const转换实现的匹配；   
3) 通过类型提升实现的匹配；    
4) 通过算数类型转换或者指针转换实现的匹配；   
5) 通过类类型转换实现的匹配；    

分析函数调用前，一般小整形都会提升到int类型或者更大的整形类型。假设有两个函数，一个接受int、另一个接受shrot。只有调用提供的是short类型的值才会选short版本的函数，有时候即使实参是一个很小的整数值，也会直接提升为int类型，此时使用short版本反而会导致类型转换：    
```
void ff(int);
void ff(short);
ff('a');
```    
**所有算数算数类型转换级别都一样，例如从int向unsigned int转换并不比从int向double转换级别高** ，，例如：    
```
void mainip(long);
void mainip(float);
mainp(3.14);   //错误：二义性调用
```    
字面值3.14类型是double，它既能转换为long也能转换为float，因此存在两种可能的算数类型转换，因此该调用具有二义性。      

7. 函数指针：    
函数指针指向的是函数而非对象，和其它指针相同。而和其返回类型无关，和函数名无关。例如：    
```
bool lengthCompare(const string &, const string &);    
```
该函数的类型是bool(const string&, const const string&)。要想声明一个可以指向该函数的指针，只需要用函数替换函数名就可以：    
```
//pf指向一个函数，该函数的参数是两个const string的引用，返回的是bool类型   
bool (*pf)(const string&, const string&); //未初始化的函数指针
```    
> Note:注意，一定要在*pf两端必不可少，如果**不写这对括号，则pf是一个返回为bool指针的函数** 。   
     
当我们把函数名作为一个值使用时，该函数会自动的转化为指针，例如：    
```
pf = lengthCompare;   //pf指向名为lengthCompare的函数
pf = &lenghtCompare;  //等价的赋值语句：取地址符是可选的    
```
此外可以直接使用指向函数的指针调用该函数，无需提前解引用指针：   
```
bool b1 = pf("hello", "goodbye");    //调用lengthCompare函数   
bool b2 = (*pf)("hello", "goodbye"); //等价调用    
```    
在往不同函数类型的指针间不存在转换规则，但是和往常一样，我们可以为函数赋一个nullptr或者值为0的整形常量表达式，表示该指针没有指向任何一个函数：   
```
string size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0; //正确
pf = sumLength; //错误：返回类型不匹配
pf = cstringCompare;  //错误：形参类型不匹配
pf = lengthCompare;   //正确：函数和指针类型精确匹配    
```    
重载函数的指针：当我们使用重载函数时，如果定义了指向重载函数的指针，将会通过精准匹配来指定指针调用的哪一个函数：   
```
void ff(int*);
void ff(unsigned int);

void (*pf1)(unsigned int) = ff;
```   
函数指针形参：和数组类型类似，虽然不能定义函数类型的形参，但是形参可以是指向函数类型的指针。此时看上去形参是函数类型，但是实际上是指针：    
```
//第三个形参是函数类型，它会自动地转成指向函数的指针
void useBigger(const string &s1, const string &s2, 
                bool pf(const string&, const string&));
//等价的声明：显式的将形参定义成指向函数的指针
void useBigger(const string &s1, const string &s2, 
                bool (*pf)(const string &, const string &));
```    
我们可以直接把函数当做实参使用，它会自动转化为指针：   
```
//自动将函数lengthCompare转换成指向该函数的指针
useBigger(s1, s2, lengthCompare);    
```    
但是这么写又写的太过于冗长，为了避免如此繁琐，可以利用别名和decltype进行简化：
```
//Func和Func2是函数类型：   
typedef bool Func(const string&, const string &); //这句话的意思是，定一个函数，类似一个函数的声明，下面还需要给出Func的定义
typedef decltype(lengthCompare) Func2;  //等价类型

//FuncP和FuncP2是指向函数的指针
typedef bool (*FuncP)(const string&, const string&);
typedef decltype(lengthCompare) *FuncP2; 
```     
值得注意的是，decltype返回函数类型不会将函数类型自动转换成指针类型（类似数组），因为decltype的结果是函数类型，只有在结果前面加上*才能得到指针。这样可以使用如下的形式重新声明useBigger:   
```
//useBigger的等价声明，其中使用了类型别名
void useBigger(const string&, const string&, Func);
use useBigger(const string&, const string&, FuncP2);
```    
返回指向函数的指针：   
和数组类似，虽然不能返回一个函数，但是可以返回指向函数类型的指针。最简单的方法仍然是使用别名：   
```
using F = int(int*, int); //F为函数类型，不是指针
using PF = int(*)(int*, int); //PF为指针类型
```     
必须注意的是，**和作为函数类型的形参不一样，返回类型不会自动转换成指针**，我们必须显式的将返回类型定义为指针：    
```
PF f1(int);    //正确：PF是指向函数的指针，f1返回指向函数的指针
F f1(int); //错误：F是函数类型，不能返回一个函数类型
F *f1(int);   //正确：显式的定义返回指向函数的指针    
```    
当然更麻烦的方法就在于用以下的形式声明f1：   
```
int (*f1(int))(int*, int);
```    
以上的类型阅读应该按照由内而外的顺序：我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回了一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此函数指向函数，该函数的返回类型为int。   
另一个最讨喜的方法应该是后置返回类型了：   
```
auto f1(int) -> int(*)(int*, int);
```    
将auto和decltype用于函数指针类型：如果我们明确知道返回函数是哪一个，就能用decltype简化书写函数指针返回类型的过程。假定有两个函数，它们的返回类型都是string::size_type，并且各有两个const string&类型的形参，此时我们可以编写第三个函数，它接受一个string类型的参数，返回一个指针,此指针指向前两个函数中的一个：   
```
string::size_type sumLength(const string&, const string&);
string::size_type largerLength(const string&, const string&);
//根据其形参的取值，getFcn函数返回指向sumLength或者largerLength的指针   
decltype(sumLength) *getFunc(const string &);
```     
唯一需要注意的是，和上面一样，得显式的加上*来表明我们需要返回指针，而非函数本身。    
      
## 第7章 类
类的基本思想是**数据抽象**和**封装**，而数据抽象是一种依赖于**接口**和**实现(implementation)**分离的技术，类的接口包括用户所能执行的惭怍，类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。    
封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现的部分。    
类想要实现数据抽象和封装，首先需要定义一个抽象数据类型，在抽象数据类型中，由类的设计者负责思考类的实现过程；使用该类的程序员只需要抽象的思考类型做了什么，而无需了解类型的工作细节。    

### 7.1 定义抽象数据类型   
我们在第一章当中的Sales_item类是一个抽象数据类型，我们通过它的接口来使用一个Sales_item对象，我们不能通过访问Sales_item对象的数据成员，实际上，我们连这个类有哪些数据成员都不太知晓。    
相反的，Sales_data类就不是一个抽象的数据类型，它能够允许用户直接访问它的数据成员，并且要求 用户来编写操作。要想把Sales_data编程抽象数据类型，我们就需要定义一些操作来供类的用户使用。一旦Sales_data定义了它自己的操作，我们就可以封装（隐藏）它的数据成员了。   
#### 7.1.1 设计Sales_data类
我们的最终目的是令Sales_data支持与Sales_item类完全一样的操作集合。Sales_item类有一个名为isbn的成员函数，并且支持+、=、+=、<<和>>运算符。    
我们将会在接下来的章节介绍如何自定义运算符。现在我们先为这些运算定义普通的函数形式。执行加法和IO的函数我们将会不作为Sales_data的成员，相反的，我们会将其定义为普通的函数；执行复合复制运算的函数是成员函数。Sales_data类无需专门定义赋值运算，其原因会在下文介绍。   
总结至今，有以下功能需要实现：   
- 一个isbn成员函数，用于返回isbn号
- 一个combine成员函数，用于将一个Sales_data对象加到另一个对象上
- 一个名为add的函数，执行两个Sales_data对象的加法
- 一个read函数，将数据从istream读入到Sales_data对象中去   
- 一个print函数，将Sales_data对象的值输出到ostream

##### 使用改进的Sales_data类   
在考虑实现我们的类之前，先看看如何使用以上这些接口函数。举个例子，我们使用这写函数来编写书店程序的另一个版本，转而使用Sales_data对象：   
```
Sales_data total;           
if (read(cin, total)) {  //读入一笔交易
    Sales_data trans;    
    while (read(cin, trans)) {  //读入剩余交易
        if (total.isbn() == trans.isbn())
            total.combine(trans);
        else {
            print(cout, total) << endl;   
            total = trans;
        }
        print(cout, total) << endl;  
} else {
    cerr << "No data?!" << endl;
}
```     
#### 定义改进的Sales_data类   
需要分清接口和类实现的区别，有些除了基础实现的内容，额外的内容需要在类中实现。   
作为接口组成部分的非常远函数，例如add、read和print等，它们的定义和声明都在类的外部。改进的Sales_data类应该如下所示：   
```
struct Sales_data {
    //新的操作对象
    std:string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_pricef() const;

    //旧数据成员
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

//Sales_data的非成员接口函数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &print(std::istream&, Sales_data&);
```
> 定义在类内部的函数是隐式的inline函数（例如上文中的isbn()方法）   

#### 定义成员函数——引入this
这里Premier抛出了一个问题，对于isbn函数：   
```
std::string isbn() const { return bookNo; }
```   
如何知道bookNo成员所依赖的对象？   
这里成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如，如果调用``total.isbn()``,则编译器负责把total的地址传递给isbn的隐式形参this,可以等价地认为编译器将该调用重写成了如下的形式：    
```
//伪代码，用于说明调用成员函数的实际执行过程
Sales_data::isbn(&isbn);
```    
其中，调用Sales_data的isbn成员时传入total的地址； 同理，我们当然可以对隐式它的this进行显式的调用，例如：    
```
std::string isbn() const { return this->bookNo; }
```
因此this就是一个**总是指向“这个”对象的常量指针**，C++不会允许this中保存的地址；      

#### 引入const成员函数     
isbn函数的另一个关键之处是紧随参数列表之后的const关键字，**这里const的作用是修改隐式this指针的类型**。     
默认情况下，this类型是指向类类型非常量版本的常量指针，例如在Sales_data成员函数中，this的类型是Sales_data *const。尽管this是隐式的，但是它仍然要遵循初始化规则，意味着默认情况下我们不能把this绑定到一个常量对象上调用普通的成员函数。    
如果isbn是一个普通函数而且this是一个普通的指针参数，那么我们应该把this声明成const Sales_data *const。毕竟，在isbn的函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。    
由于this是隐式的，并且不会出现在参数列表中，所以在哪里将this声明为指向常量的指针就成为必须面对的问题。C++的做法是允许吧const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后的const表示this是一个指向常量的指针，像这样使用const的成员函数称为**常量成员函数（const member function）**。即等价于以下形式：    
```
std::string Sales_data::isbn(const Sales_data *const this)
{
    return this->isbn;
}
```
> Tip: 常量对象，以及常量对象的引用或者指针都只能调用常量成员函数；
    
#### 定义一个返回this对象的函数    
函数combine的设计初衷类似于复合赋值运算符+=，调用该函数的对象代表的是赋值运算符左侧的运算对象，右侧运算对象则通过显式的实参被传入函数：    
```
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
    units_sold += rhs.units_sold; 
    revenue += rhs.revenue;
    return *this;
}
```     
当我们的交易处理程序调用以下函数：    
```
total.combine(trans);  //更新变量total当前的值
```    
该函数最值得关注的部分是它的返回类型和返回语句。*一般来说，当我们定义的函数类似某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左侧运算对象当成左值返回*，因为为了与它保持一致，combine函数必须返回引用类型，因为此时的左侧运算对象是一个Sales_data的对象，所以返回类型应该是Sales_data&。（简单来说，传统运运算符就是返回左值的引用）     
     
### 7.1.3 定义类相关的非成员函数
类的作者常常需要定义一些辅助函数，例如add、read和print，尽管这些函数定义的操作从概念上来说属于类的接口部分，但是它们实际上并不属于类本身。    
> Tip: 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。    
#### 定义read与print函数   
```
//输入的信息包含ISBN、售出总数和售出价格
istream &read(istream &is, Sales_data& item)
{
    double price = 0;
    is >> item.bookNo >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}
ostream &print(ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
        << item.revenue << " " << item.avg_price();
    return os;
}
```
以上代码有两点值得注意，第一，read和print分别接受一个各自IO类型的引用作为其参数，这是因为IO类属于不能够被拷贝的类型，因此我们只能通过引用来传递它们。而且，因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通饮用，而非对常量的引用。    
第二点，print函数不负责换行。一般来说，执行输出任务的函数应该尽量减少对格式的控制，这样可以由用户确定是否换行。     
#### 定义add函数    
add函数与combine函数略有区别，它是接受两个Sales_data对象作为参数，返回的是一个新的Sales_data，用于表示前两个对象的和：    
```
Sales_data add(const Sales_data &lhs, const Sales_data &rhs)
{
    Sales_data sum = lhs;   
    sum.combine(rhs); 
    return sum;
}
```    

### 7.1.4 构造函数    
每个类都分别定义了它的对象被初始化的方式，类通过一个或者几个成员函数来控制其对象的初始化过程，这些函数叫做**构造函数(Constructor)**。 构造函数的任务是初始化对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。    
构造函数非常复杂，接下来会在多个章节接触到关于构造函数的知识。当然，我们从最简单的开始。构造函数名字与类名相同，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。类可以包含多个构造函数，类似重载函数，不同的构造函数必须在参数数量或者参数类型上有所区别。    

#### 合成的默认构造函数    
先前的total和trans没有构造函数，那么它们是如何初始化的呢？我们没有为这些对象提供初始值，因此我们知道他们执行了默认初始化。类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做**默认构造函数**，默认构造函数无需任何实参。    
如我们缩减，默认构造函数在很多方面都有其特殊性，其中之一就是，如果我们的类没有显式的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。    
编译器创建的构造函数又被称为**合成的默认构造函数(synthesized default constructor)**。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：
- 如果存在类内初始值，用它来初始化成员；
- 否则，默认初始化该成员；    
例如Sales_data为units_sold和revenue提供了初始值，所以合成的默认构造函数将使用这些值来初始化对应的成员；同时，它把bookNo默认初始化为一个空字符串。    
#### 某些类不能依赖于合成的默认构造函数     
合成的默认构造函数只适合非常简单的类。对于一个普通的类来说，必须定义其默认构造函数，原因有三：    
1. 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。这条规则的依据是——如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。    
> Tip: 只有当类没有声明任何构造函数，编译器才会自动地生成默认构造函数（这一点挺有意思，这意味着一旦有一个构造函数，就不会支持默认的构造函数）    
2. 第二个原因在于，对于某些类来说，能合成的默认构造函数可能执行错误的操作。例如之前介绍的，如果定义在块中的内置类型或复合类型（例如数组和指针）的对象被默认初始化，那么它们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。*因此，含有内置类型或者复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数*，否则，用户在创建类对象时就可能得到未定义的值了。   
> Warning: 如果类包含有内置类型或者复合类型的成员，则只有当这些成员全部被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。    
(以上的这个问题在之前编程中很常见，例如使用一个vector是必须是每个对象必须有实例化的能力，即有默认构造函数)     
3. 编译器有时候不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员并且整个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类来说，我们必须自定义默认构造函数，否则该类讲没有可用的默认构造函数。     
##### 定义Sales_data的构造函数    
对于我们Sales_data类来说，我们将使用下面的参数定义4个不同的构造函数：    
- 一个istream&，从中读取一条交易信息；   
- 一个const string&,表示ISBN编号；一个unsigned，表示售出的图书数量；以及一个double，表示图书的售出价格。    
- 一个const string&, 表示ISBN编号；编译器将赋予其他成员默认值；   
- 一个空参数列表（即默认构造函数），这样得到：   
```
struct Sales_data {
    //构造函数
    Sales_data() = default;
    Sales_data(const std::string &s) : bookNo(s) {}
    Sales_data(const std::string &s, unsigned n, double p) : 
                bookNo(s), units_sold(n), revenue(p * n) {}
    Sales_data(std::istream &);

    //之前已有的其他成员……
};
```
##### =default的含义   
形如``Sales_data() = default;``首先明确一点，因为该构造函数不接受任何实参，所以它是一个默认构造函数。我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数，我们希望这个函数的作用完全等同于前面提到的合成默认构造函数。    
在C++11标准中，如果我们需要默认行为，那么可以通过在参数列表后面写上``=default``来要求编译器生成构造函数。其中=default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，在内部则是内联，在外部则不是内联。    
##### 构造函数初始值列表     
接下来我们介绍类中定义的两个构造函数：    
```
Sales_data(const std::string &s) : bookNo(s) {}
Sales_data(const std::string &s, unsigned n, double p) : 
            bookNo(s), units_sold(n), revenue(p * n) {}
```    
按照以上形式，出现的新的部分包含了冒号后的部分以及花括号之间的代码，其中花括号定义了空的函数体。我们吧冒号后的内容称为**构造函数初始值列表（constructor initialize list）**,它负责为新创建的一个或者几个数据成员赋初值。构造函数初始值时成员名字的一个列表，每个名字后面紧跟括号括起来（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。     
只有一个string类型参数的构造函数使用这个string对象初始化bookNo，对于units_sold和revenue则没有显式地初始化。当某个数据成员被构造函数初始值列表被忽视时，它将以与合成默认构造函数相同的方式隐式初始化。在此例中，这样的成员使用类内初始值初始化，因此只接受一个string参数的构造函数等价于：    
```
Sales_data(cosnt std::string &s) : 
            bookNo(s), units_sold(0), revenue(0) {}
```     
> Advice: 构造函数不应该轻易的覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。     
##### 在类外部定义构造函数     
与其它构造函数不同，以istream为参数的构造函数需要执行一些实际的操作。   
```
Sales_data::Sales_data(std::istream &is)
{
    read(is, *this); 
}
```
构造函数没有返回类型，所以上述定义从我们指定的函数名字开始，和其他成员函数一样，当我们在类外定义构造函数时，必须指明该构造函数是哪个类的成员。因此，Sales_data::Sales_data的含义是我们定义Sales_data类的成员，它的名字是Sales_data，所以其是一个构造函数；    
这个构造函数没有构造函数初始值列表，或者说的更明确一点，它的构造函数初始值列表示空的，但是由于执行了构造函数体，所以对象的成员仍然能够被初始化。    
这里使用了*this来把this对象作为引用实参传递给read函数。    

### 拷贝、赋值与析构    
除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。对象在几种情况下会被拷贝，例如初始化变量以及以值的方式传递或者返回一个对象等。当我们使用了赋值运算符时都会发生赋值操作。当对象不再存在时执行销毁的操作，比如一个局部对象会在创建它的块结束时被销毁，当vector对象销毁时其存储在其中的对象也会被销毁。    
如果我们不主动去定义这些操作，那么编译器会替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。     
#### 某些类不能依赖合成的版本     
尽管编译器能够替我们合成拷贝、赋值和销毁的操作，但是必须要清楚一点，对于某些类来说合成的版本无法正常工作，特别是当类需要分配对象之外的资源时，合成的版本会常常是小。举个例子，接下来会介绍C++是如何分配和管理动态内存的，而我们会看到，管理动态内存的类通常不能依赖于上述操作的合成版本。    
不过值得注意的是，很多需要动态内存的类能（而且应该）使用vector对象或者string对象管理必要的存储空间，使用vector或者string类能够避免分配和释放内存带来的复杂性。    
进一步讲，如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版本能够正常工作。当我们对含有vector成员的对象执行拷贝或者赋值操作时，vector类会设法拷贝或者赋值成员中的元素。当这样的对象被销毁时，将销毁vector对象，也就是依次销毁vector中的每一个元素，这一点与string非常类似。    

## 7.2 访问控制与封装     
C++语言中，使用**访问说明符（access specifiers）加强类的封装性**：    
- 定义在public说明符之后的成员可以在整个程序内被访问，public成员往往定义类的接口；
- 定义在pirvate说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，即private封装（或者说隐藏了）类的实现细节；    
一个类中对于访问说明符的出现次数并没有规定，反正只要从出现开始，就开始了这个说明符有效范围一直持续到下一个说明符或者结尾。     
#### 使用class或struct关键字    
两种形式的定义其实仅仅是形式上的区别，唯一的区别是：**struct和class默认访问权限不太一样**。class是pricate，struct是public。    

### 7.2.1 友元    
上文中，我们把Sales_data的数据成员变成了private的，那么read、print和add函数也就无法正常编译了，因为尽管这几个函数是该类接口的一部分，但是它们并不是类的成员。    
类因此提出了友元的概念，一个类可以允许其他类或者函数访问它的非公有成员，方法是将其它类或者函数添加为友元（frined）。如果类想要把一个函数作为他的友元，只需要增加一条以friend关键字开始的函数声明即可：    
```
class Sales_data {
    friend Sales_data add(const Sales_data&, const Sales_data&);
    friend std::istream &read(std::istream&, Sales_data&);
    friend std::ostream &print(std::ostream&, const Sales_data&);

    //接下来声明照旧……
};
```
友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限，不过一般来说，最好在类开始或者结束的时集中声明友元。      
> Tip: 友元不是类的成员，也不受它所在区域访问控制级别的约束。     

## 7.3 类的其他特性    
### 7.3.1 类成员再探
我们定义一对相互关联的类，分别为Screen和Window_mgr。    
#### 定义一个类型成员    
Screen表示显示器中的一个窗口，每个Screen包含一个用于保存Screen内容的string成员和三个string::size_type类型的成员，它们分别表示光标的位置以及屏幕的高和宽。   
除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其它成员一样存在访问限制，可以是public或者private中的一种：  
```
class Screen {
public:
    typedef std::string::size_type pos;
private: 
    pos cursor = 0; 
    pos height = 0, width = 0;
    std::string contents;
};
```     
关于pos的声明有两点需要注意，首先使用了typedef，当然我们可以等价的使用新标准的类型别名：    
```
using pos = std::string::size_type;
```    
其次，用来定义类型的成员必须先定义后使用，这一点和普通成员函数有所区别（后文中会介绍），因此类型成员通常出现在类开始的地方。    

#### Screen类的成员函数
为了使类更加使用，还需要添加一个构造函数来使用户能够定义屏幕的尺寸和内容，以及其他两个成员分别负责移动光标和读取给定位置的字符：   
```
class Screen {
public: 
    typedef std::string::size_type pos;
    Screen() = default; //因为Screen有另一个构造函数，所以本函数必须
    //cursor被其类内初始值初始化为0
    Screen(pos ht, pos wd, cahr c) : height(ht), width(wd), contents(ht *wd, c) {}
    char get() const { return contents[cursor]; } //隐式内联
    inline char get(pos ht, pos wd) const;  //显示内联
    Screen &move(pos r, pos c);             //能在其后设置为内联

privaet: 
    pos cursor = 0; 
    pos height = 0, width = 0;
    std::string contents;
};
```
如上文所示，因为定义了一个三参数的构造函数，我们也必须要提供一个=default的默认构造函数。    
#### 令成员作为内联函数    
类内类外同样能显示的定义内联函数（内联函数的定义有灵活性）：    
```
inline Screen &Screen::move(pos r, pos c) //定义处指定
{
    pos row =  r * width;
    cursor = row + c;
    return *this;
}

char Screen::get(pos r, pos c) const  //类声明时指定
{
    pos row = r * width;
    return contents[row + c];
}
```
虽然在定义和声明的地方都说明inline是完全合法的，但是一般只在类外部定义时说明inline，这样更容易理解。    

#### 可变数据成员    
有时候（但是不频繁）会发生这种情况，**我们希望能够修改类的某个数据成员，即使是在一个const成员函数内**。可以通过在变量的声明中加入mutable关键字来做到这点。    
一个可变数据成员（mutable data member）永远不会是const，即使是const对象中的成员。因此一个const成员函数可以改变一个可变成员的值。例如，我们给Screen添加一个名为access_ctr的可变成员，来追踪每个Screen成员函数被调用了多少次：    
```
class Screen {
public: 
    void some_member() const;
private: 
    mutable size_t access_ctr; //即使在一个const对象内也能被修改
    //......
};

void Screen::some_member() const
{
    ++access_ctr;
}
```    

#### 类数据成员的初始值    
在定义好Screen类之后，我们将继续定义一个窗口管理类并用它表示显示器上的一组Screen。这个类将包含一个Screen类型的vector，每个元素表示一个特定的Screen。默认情况下，我们希望Window_mgr类开始时总是拥有一个默认初始化的Screen。在C++11标准中，最好的方式就是把这个默认值声明为一个类内初始值：    
```
class Window_mgr {
private: 
    std::vector<Screen> screens{Screen(24, 80, ' ')};
};
```
> Tip： 当提供一个类内初始值时，必须以=或者花括号表示。    

#### 7.3.2 返回*this的成员函数    
```
class Screen {
public:  
    Screen &set(char);
    Screen &set(pos, pos, char);
    //......
}

inline Screen &Screen::set(char c)
{
    contents[cursor] = c;   //设定当前光标所在位置为新值
    return *this;           //将this对象当做左值进行返回
}
inline Screen &Screen::set(pos r, pos col, char ch)
{
    contents[r * width + col] = ch;
    return *this;
}
```    
为什么要刻意返回引用而非对象呢？原因在于，如果需要进行类似的连续操作：   
```
myScreen.move(4, 0).set('#');
```
那么，不使用引用的后果就是只最后改变了副本而非对象本身。    
#### 从const成员函数返回*this    
所以稍微有点点新的冲突发生了，如果我们定义了一个新的display函数用于显示，我们令其为const成员，而此时返回的this将会变成一个常量指针，那么再执行以下操作就会引发错误：   
```
myScreen.display(cout).set('*');
```    
这个例子总体就是提醒我们const成员函数返回的*this将会是常量引用。   
#### 基于const的重载    
通过区分成员函数是否为const，我们可以对其进行重载，其原因和我们之前说判断指针参数是否指向const而重载函数的理由差不多，具体说来，因为非常量版本的函数对于常量对象不可用，所以我们只能在一个常量对象上调用const函数。另一方面，虽然非常量对象调用常量版本或者非常量版本都可以，但是很明显调用非常量版本是一个更好的选择。    
这里我们将会定义一个do_display的私有函数，用它来负责实际的打印Screen的操作，所有的display操作都会调用这个函数，然后返回执行的对象： 
```  
class Screen {
public:   
    Screen &display(std::ostream &os)
    {
        do_display(os); return *this;
    }
    const Screen &display(std::ostream &os) const 
    {
        do_display(os); return *this;
    }
private:
    //该函数负责显示Screen的内容
    void do_display(std::ostream &os) const {os << contents;}
};
```
这里透露的信息是，当一个成员调用另一个成员时，this指针会在中间隐式的传递。例如非常量版本传递了非常量的this，而常量的恰恰相反。最后合法的调用就变成了：      
```
Screen myScreen(5, 3);
const Screen blank(5, 3);
myScreen.set('#').display(cout);    //调用的非常量版本
blank.display(cout);                //调用的常量版本
```   
> Important Advice: 为什么要在私有函数中再定义一个小的do_display函数？这是因为：   
> - 避免在多处使用同样代码；
> - 我们预期随着类规模的发展，display函数可能会变得更加复杂，此时把功能相同的操作写在一处而非两处就很有用了；   
> - 我们可能在do_display中添加某些调试信息，但是这些信息会在最终的发布版本中去掉。显然只在do_display中对其进行添加或者删除会方便很多。   
> - 额外的函数调用不不会增加开销，尤其是我们还使用了隐式的内联函数来定义do_display。   
> 实践中，设计良好的C++代码通常包含大量类似do_display的小函数；    

### 7.2.3 类类型
每个类定义了唯一的类型，**即使两个类的成员完全一样，这两个类也是完全不同的类型**。   
我们可以把类名作为类型的名字使用，从而直接指向类类型。或者我们可以把类名跟在关键字class或者struct后面：    
```
Sales_data item1; 
class Sales_data item1;  //等价声明
```   
就是下面这种声明方式从C语言继承而来，不是那么常用罢了。    

#### 类的声明    
经常在各种程序中看到光秃秃的声明一个类名：    
```
QT_BEGIN_NAMESPACE
class Screen;
QT_END_NAMESPACE
```    
这种声明就是**前向声明**，在它定义后，该类只是一个不完全类型，编译器完全不了解其包含了哪些成员，所以，这决定了它使用的场景是有限的：**只能定义指向这种类型的指针或者引用，或者以指针或者引用作为返回类型的函数**。    
当然，另一种特殊的应用就在于，一个类虽然在定义时不能在自身成员函数中定义自己，但是一旦一个类的名字出现过后，它就会被认为是声明过了，因此类允许包含指向它自身类型的引用或者指针(就像数据结构的Node一样)：    
```
class Link_screen {
    Screen window;
    Link_screen *next;
    Link_screen *prev;
};
```    

### 7.3.4 友元再探    
除了先前提到的非成员函数可以定义成友元，也可以定义友元类，也可以定义某个类的某个成员函数为友元（必须编译器之前已经定义过）。此外，友元函数本身还能够定义在类的内容，而且这样也是隐式内联的。    
#### 类之间的友元关系    
例如我们的Window_mgr类有一个clear函数，想要把指定的Screen清空，那么需要把Window_mgr设定为友元：   
```
class Screen {
    friend class Window_mgr;
};
```    
这样，友元类的成员函数可以访问包含该类非公有成员在内的全部成员，因此Window_mgr的clear方法实现如下：   
```
class Window_mgr {
public: 
    using ScreenIndex = std::vector<Screen>::size_type;
    void clear(ScreenIndex);

private: 
    std::vector<Screen> screens{(Screen(24, 80, ' '))};
};

void Window_magr::clear(ScreenIndex i)
{
    Screen &s = screens[i];
    s.contents = string(s.height * s.width, ' ');
}
```    
值得注意的是，**友元并不具有传递性**，即如果Window_mgr有它自己的友元，这些友元并不能理所当然的访问Screen的全部成员。（每个类负责控制自己的友元类或者友元函数）   
#### 令成员函数作为友元   
显而易见的，可以模仿上面的形式，定义成这样来实现成员函数是友元函数：   
```
class Screen {
    friend void Window_mgr::clear(ScreenIndex);
};
```    
但是稍微需要注意的是，这样对程序结构也提出了一定的要求：   
- 首先定义Window_mgr类，并声明clear函数，但不能定义；
- 接下来声明定义Screen，包括对clear的友元声明；    
- 最后定义clear,此时它才可以使用Screen的成员；     

## 7.4 类的作用域    
我们经常说namespace命名空间，但是很少谈及**类本身就是一个作用域**，比较明显的例子就例如上面的ScreenIndex类，即使clear函数中未曾定义，但是编译器已经知道它属于Window_mgr类作用域中。**另一个例子是，我们通常在cpp文件（即类的声明之外）定义类成员函数的内容，那么这样就不能单纯的使用Screen，而要指明其类型属于哪个类**，例如：
```
class Window_mgr {
public:   
    ScreenIndex addScreen(const Screen&);
};

Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s)
{
    screen.push_back(s);
    return screens.size() - 1;
}
```    

### 7.4.1 名字查找与类的作用域    
到目前为止，名字查找过程比较简单，趋向于先从所在块中找声明语句，再逐渐到外层，如果一直没找到，则报错。    
对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别。类的定义分两步处理：    
- 首先，编译成员的声明；   
- 直到类全部可见后才编译函数体；    

注意：尽管类内类外声明同名变量遵循所谓的覆盖原则，类型名是不可以在类内类外同名定义的。    
同样可以运用作用域运算符访问::，例如：   
```
void Screen::dummy_fcn(pos height) {
    cursor = width * ::height;  //是全局的那个
}
```    

## 7.5 构造函数再探    
### 7.5.1 构造函数初始值列表
类对象的成员初始化为啥要用初始化列表？原因在于不这样去做几乎就等价于二次赋值了：   
```
Sales_data::Sales_data(const string &s, unsigned cnt, double price)
{
    //这种写法没有问题，但是比较草率：没有使用构造函数初始值
    bookNo = s;
    units_sold = cnt;
    revenue = cnt * price;
}
```
#### 构造函数的初始值有时候必不可少    
大部分情况我们能忽略输出成员初始化和赋值之间的差异，但是并非总能这样。如果成员是const或者引用的话，也必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化，例如：    
```
class ConstRef {
public: 
    ConstRef(int ii);
private:
    int i;
    const int ci;
    int &ri;
};
```
如果我们在构造函数中不给它们提供初始值，就会发生错误：   
```
ConstRef::ConstRef(int ii)
{
    i = ii;
    ci = ii;   //错误
    ri = i;    //错误
}
```   
正确的方式是：   
```
ConstRef::ConstRef(int ii) : i(ii), ci(ii), ri(i) {}
```
总而言之，如果成员是const、引用或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表来为这些函数提供初始值。   
> Advice: 在很多类中，初始化和赋值的区别会影响底层效率：前者直接初始化数据成员，后者则属于先初始化再赋值（脱裤子放屁）。   
> 此外除了效率问题外，有些数据成员必须要被初始化，所以一定建议大家养成使用初始值列表的构造函数书写方式。    

#### 成员初始化的次序    
令人稍感意外的是，构造函数初始值列表只用于说明用于初始化成员的值，**而不会限定初始化的具体执行顺序**，真正的初始化顺序是由它们在类定义中出现的顺序一致。这一点通常不会有啥毛病，但是如果遇到一个成员是用另一个成员初始化，那么这两个的定义顺序就要考究一点了：   
```
class X {
    int i;
    int j;
public: 
    X (int val) : j(val), i(j) {} //i的值是不定的
};
```
比较人性化的编译器，会在初始值列表顺序和声明顺序不一致的时候给个警告。平时编程最好令构造函数初始值顺序和成员声明的顺序保持一致，而且尽量避免使用某些成员初始化其他成员。   

#### 默认实参和构造函数   
一个构造默认构造函数比较通常的思路，就是使用带默认实参的构造函数：   
```
Sales_data (std::string s = "") : bookNo(s) {}
```  
如果一个构造函数为所有参数都提供了默认实参，那么它实际上也定义了默认构造函数；   

### 7.5.2 委托构造函数   
C++11新标准提出委托构造函数，可以使用其它构造函数来完成自己的初始化过程，或者说它把它部分（或全部）职责委托给了其它构造函数。   
那样，我们可以重写Sales_data的构造函数为：   
```
class Sales_data {
//非委托构造函数使用对应实参来初始化成员   
Sales_data(std::string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt * price){}
//其余构造函数均委托给另一个构造函数   
Sales_data() : Sales_data("", 0, 0){}
Sales_data(std::string s) : Sales_data(s, 0, 0) {}
Sales_data(std::istream &is) : Sales_data() {read(is, *this);}
};
```   

### 7.5.3 默认构造函数   
当对象被默认初始化或者值初始化时自动执行默认构造函数，在以下情况发生：   
- 当我们再块作用域内不使用任何初始值来顶一个非静态变量或者数组；
- 当一个类本身含有类类型成员，并且使用合成的默认构造函数时；
- 当类类型成员没有在构造函数初始值列表中显式的初始化时；    
值初始化则发生在：   
- 在数组初始化过程中我们提供的初始值数量小于数组大小时；
- 当我们不使用初始值定义一个局部静态变量时；
- 当我们通过书写形如T()的表达式显式地请求值初始化时，其中T是类型名；   
上述情况都还算好判断，不过有些情况会比较晦涩难发现缺少默认构造函数，例如：
```
class NoDefault {
public: 
    NoDefault(const std::string&);
    //..
}
strct A {
    NoDefault my_mem;
};
A a;  //错误：不能给A合成构造函数
struct B {
    B() {} //错误：b_member没有初始值
    NoDefault b_member;
};
```   

### 7.5.4 隐式的类类型转换   
同C++内置类型的隐式转换，我们也能为类定义隐式转换定义。如果构造参数只接受一个实参，其实也就定义了该类类型隐式转换机制，有时候我们把它称作为**转换构造函数**。
实际上上文中，接受单个string 的构造函数和接受单个istream的构造函数已经分别定义了各自想Sales_data隐式转换的规则，也就是说，**在需要使用Sales_data的地方，我们可以使用string或者istream作为替代**：   
```
string null_book = "9999";
item.combine(null_book);
```    
但是几点原则需要注意：  
- 只允许一步转换：例如如果我们直接写``item.combine("9999");``就会报错，为啥，因为只允许一步转换，所以如果要合法必须手动写为``item.combine(string("9999"))``;
- 类类型转换未必总有效；   

#### 抑制构造函数的隐式转换    
在要求隐式转换的上下文中，我们可以将构造函数加**explicit**加以阻止：   
```
class Sales_data {
public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p * n) {}
    explicit Sales_data(cosnt std::string &s) : bookNo(s) {}
    explicit Sales_data(std::istream&);   
};
```   
那么这时候，就没法儿用任何构造函数隐式的构造Sales_data对象，之前的两种方法就无法通过编译：   
```
item.combine(null_book);  //错误
item.combine(cin);  //错误
```
注意，关键字explicit**只对一个实参的构造函数有效**，需要多个实参的构造函数不嗯呢该用于执行隐式转换，所以无需将其指定为explicit。而且，**只需要在声明处**指定就可以，不应该在定义时重复写出：
```
//错误
explicit Sales_data::Sales_data(istream& is)
{
    read(is, *this);
}
```   

#### explicit构造函数只能用于直接初始化   
另一个explicit构造函数的特殊之处在于不能够使用拷贝形式初始化，而只能直接初始化，例如：   
```
Sales_data item1(null_book); //正确：直接初始化
Sales_data item2 = null_book; //错误：不支持拷贝形式初始化；   
```   

#### 为转换显式地使用构造函数    
另一个避免隐式转换错误的好方法，当然也是最傻的，就是强制类型转换：   
```
item.combine(Sales_data(null_book));
item.combine(static_cast<Sales_data>(cin));
```   

> 我们接触的一些标准库中有单参数构造函数的：string接受一个const char*参数的不是explicit的函数；
> 接受一个容量参数的vector构造函数是explicit的；    

### 7.5.5 聚合类   
**聚合类**是的用户可以直接访问其成员，并且拥有特殊的初始化语法形式。当一个类满足以下条件时，我们称之为聚合的：   
- 所有成员都是public的；
- 没有定义任何构造函数；
- 没有定义任何类内初始值；
- 没有基类，也没有virtual函数（后面会介绍）   
例如下面就是个聚合类： 
```
struct Data { 
    int val;
    string s;
};
```   
聚合类的初始化可以使用一个花括号括起来的成员初始值列表，并且用它初始化聚合类的初始化成员：    
```
Data val1 = { 0, "Anna"};
```    
初始值的顺序必须与声明的顺序一致。但是稍微注意的是，显式的初始化对象成员存在三个明显的缺点：   
- 要求所有成员都是public的；
- 将正确初始化每个对象的重任交给了类的用户；因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，这样的初始化过程冗长而且易出错；   
- 添加或者删除一个成员后，所有初始化语句都需要更新；   

### 7.5.6 字面值常量类    
之前有提到过,constexpr的参数和返回值必须是字面值类型。除了算数类型、引用和指针外，**某些类也是字面值类型**。和其他类不同，字面值类型的类可能含有constexpr成员函数，这样的成员必须符合constexpr函数的所有要求，它们是隐式const的。   
**数据成员都是字面值类型的聚合类是字面值常量值**。如果一个类不是聚合类，但是它符合以下要求，则它也是一个字面值常量类：    
- 数据成员都必须是字面值类型；   
- 类必须至少含有一个constexpr构造函数；   
- 如果一个数据成员含有类内初始值，则内置类型初始值必须是一条常量表达式；或者如果成员属于某种类类型，初始值则必须使用自己的constexpr构造函数；    
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象；   

#### constexpr构造函数     
尽管构造函数不能const（构造函数本来就是设计出来改变类的），但是字面值常量类构造函数可以是constexpr函数。事实上一个字面值常量类必须至少提供一个constexpr构造函数。   
constexpr构造函数可以声明为=default的形式，否则，constexpr构造函数就必须即符合构造函数的要求，又符合constexpr函数的要求（意味着唯一可执行语句就是返回语句）。综合两点可知，constexpr构造函数体一般来说应该是空的。我们通过前置关键字constexpr就可以声明一个constexpr构造函数：   
```
class Debug {
public: 
    constexpr Debug(bool b = true) : hw(b), io(b), other(b) {}
    constexpr Debug(bool h, bool i, bool o) : hw(h), io(i), other(o) {}
    constexpr bool any() {return hw || io || other; }
    void set_io(bool b) { io = b; }
    void set_iw(bool b) { hw = b; }
    void set_other(bool b) { hw = b;}
private:
    bool hw;     //硬件错误
    bool io;     //IO错误
    bool other;  //其他错误
};
```    
constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。    
constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或者返回类型：   
```
constexpr Debug io_sub(false, ture, false); //调试IO
if (io_sub.any())                           //等价于if(true)
    cerr << "print appropriate error messages" << endl;
constexpr Debug prod(false);                //无调试
if (prod.any())                             //等价于if(fales)
    cerr << "print an error message" << endl;
```

## 7.6 类的静态成员     
类的静态成员出现意义在于**该成员与类本身直接相关，而不是与类的某个对象保持关联**。例如，一个银行账户类可能需要一个数据成员来表示当前的基准利率。这个利率很明显不需要每个账户都要变动，更关键的是，我们希望一旦利率改变，所有对象都能使用新值。    
#### 声明静态成员     
我们通过在成员的声明之前加上static使得其余类关联在一起。和其他成员一样，静态成员可以使public或者private的。静态数据成员的类型可以是常量、引用、指针、类类型等；例子：     
```
class Account {
public: 
    void calculate() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void rate(double);
private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
};
```    
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据相关的数据；因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且被所有Account对象共享。    
类似的，静态成员函数也不和任何对象绑定到一起，**它们不包含this指针**。作为结果，静态成员函数不能声明为const的，而且也不能在static函数体内使用this指针，这一个限制适用于this的显式调用，也对调用非静态成员的隐式使用有效。     

#### 使用类的静态成员
可以直接使用作用域运算符直接访问静态成员：   
```
double r = Account::rate();
```    
虽然今天成员不属于类的某个对象，但是仍然可以用类的对象、引用或者指针来访问，这里不做赘述；   

#### 定义静态成员
和其他成员函数一样，我们既可以在内部也可以在外部定义一个静态成员函数，不能重复static关键字，该关键字只出现在类内部的声明语句：   
```
void Account::rate(double newRate)
{
    interestRate = newRate;
}
```
类内静态变量最特殊之处在于，因为静态数据成员不属于任何一个对象，所以它们并不是在创建类对象的时候被定义的，恰恰相反，我们一般不能在类的内部初始化静态变量，而必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能够定义一次。   
类似于全局变量，静态数据成员定义在任何函数之外，因此一旦它被定义，就存在于程序的整个生命周期之中。   
我们定义静态数据成员的方式和外部定义成员函差不多，指定类型名、类名、作用运算符以及成员自身的名字：    
```
double Account::interestRate = initRate();
```   
有个有意思的事儿是，这句话看似没有指定initRate的范围，但是其实是没有错的，因为从Account::之后指的就是该类内部成员，而此时interestRate为类的内部成员，也可以访问类的私有成员。     

#### 静态成员的内部初始化    
通常情况下，类的静态成员不应该在类的内部初始化，但是我们可以给静态成员提供const整数类型的类内初始值，**不过要求静态成员必须是字面值常量类型的constexpr**。初始值必须为常量表达式（这是因为这些成员本身就是常量表达式），所以它们能用在所有适合于常量表达式的地方，例如我们可以用一个初始化了静态数据成员指定数组成员的维度：   
```
class Account {
public:
    static double rate() {return interestRate;}
    static void rate(double);
    static constexpr int period = 30;  //period是常量表达式
    double daily_tbl[period];
};
```    
> Tip: 即使一个常量静态数据成员在类内部被初始化了，通常情况也应该在类外部定义一下该成员。   

#### 静态成员能够用于某些场景，但是普通成员不能    
例如，静态数据成员可以是不完全类型，特别的，静态数据成员的类型还就可以是它自己所属的类类型，而非静态数据成员则会受到限制，只能声明它自身的引用或者指针：   
```
class Bar {
public:
    //
private: 
    static Bar mem1;   //正确
    Bar *mem2;         //正确
    Bar mem3;          //不正确
};
```   
静态成员和普通成员的另一个区别就在于我么可以使用静态成员作为默认实参：   
```
class Screen {
public: 
    //bkground表示一个类中稍后定义的静态成员
    Screen& clear(char = bkground);
private:
    static const char bkground;
};
```   
非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果就是自己给自己反复调用下套，无法真正提供一个对象以便从中获取成员的值，最终引发错误。   

# 第二部分 C++标准库    

# 第8章 IO库    
## 8.1 IO类
为了支持不同种类的IO处理操作，标准库还规定了一些其他IO类型，其中iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型,sstream定义了读写内存string对象的类型；同时还定义了w开头的宽字符对象来处理宽字符数据，例如wcin、wcout等。    
### 8.1.1 IO对象无拷贝或赋值   
我们不能拷贝或者对IO对象赋值；    
### 8.1.2 条件状态    
IO设置了多种条件状态，用于修正和访问状态。注意，*一个流一旦发生错误，其后续的IO操作都会失败* ，因此最好的办法就是将流每次的结果当做一个条件来使用：    
```
while (cin >> word)
    //ok：继续读……
```    
#### 查询流的状态     
将流作为条件使用，只能知晓流是否有效，但是无法知道具体发生了什么；有时候我们还是需要知道发生了什么的，例如，键入了文件结束标示后我们的应对措施，可能和遇到一个IO设备错误的处理方式是不同的。    
IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。IO类型定义了4个iostate类型的constexpr值来表示特定的位模式，这些值用来表示特定类型的IO条件，可以用与位运算符一起来进行一次性检测或者设置多个标志位：     
- badbit： 表示系统级错误，一旦badbit被置位，流就无法使用了；      
- failbit: 这表示如果被置位，那么流遇到了一个字符错误，但是还可以继续使用；
- eofbit: 尾部标识符。到达尾部时会和failbit一起被置位；
- goodbit: 为0，表示流未发生错误；    
#### 管理条件状态     
流对象的rdstate成员返回一个iostate值，对应流当前状态,setstate操作将给特定的位定条件位置位。clear成员是一个重载的成员，他有一个不接受参数的版本，而另一个版本接受一个iostate类型的参数，前者清除所有错误标志位：     
```
//记住cin当前状态
auto old_state = cin.rdstate();  
cin.clear();
process_input(cin);
cin.setstate(old_state);   //恢复cin状态
```     
至于局部，下面例子将failbit和badbit复位，但保持eofbit不变：    
```
//复位faildbit和badbit，保持其他标志位不变   
cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit); //~取反符号，X & ~X = 0可以作为一个复位的写法
```    

### 8.1.3 管理输出缓冲     
计算机有个特定的机制在于，每个输出流都有一个缓冲区，例如cout一个东西，但是文本串既可能直接打印出来，也可以被保存在缓冲区中，等会儿再打印。这种操作最大的好处是某些系统写入很慢，但是如果能允许操作系统将多个输出操作组合为单一的设备写操作就可以带来很大的性能提升。    
导致缓存区刷新的原因很多：
- mian函数return
- 缓冲区满
- endl操作符
- unitbuf设置流的内部状态，例如cerr是立即刷新的，就是因为cerr是设置unitbuf的
- 一个输出流可能会被关联到另一个流
> Warning:如果程序崩溃，输出缓冲区不会被刷新    

### 关联输入和输出流    
当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输入流。标准库将cout和cin关联到一起，因此下面语句：   
```
cin >> ival;
```    
导致cout的缓冲区被刷新。     
> 交互式系统通常应该关联输入流和输出流，但是这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。    
tie有两个重载版本：一个版本不带参，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是这个流的指针，如果未关联到流，则返回空指针。 tie的第二个版本接受一个指向ostream的指针，将自己关联倒刺ostream。即x.tie(&o)将流x关联到输出流o。   
我们既可以把一个istream对象关联到另一个ostream，也可以讲一个ostream关联到连一个ostream:   
```
cin.tie(&cout);   //可以但是一般不会这么做
ostream *old_tie = cin.tie(nullptr); //cin不再与其它流关联
cin.tie(&cerr); //读取cin会刷新cerr而不是cout
cin.tie(old_tie);  //重建cin和cout间的正常关联
```
每个流最多关联到一个流，但是多个流可以绑定到同一个ostream。     

## 8.2 文件输入输出     
使用ifstream从一个给定文件读取数据,ostream给一个特定文件写入数据，以及fstream可以读写给定文件。    
### 8.2.1 使用文件流对象   
```
ifstream in(ifile);  //构造一个ifstream并打开给定文件
ofstream out;        //输出文件流未关联到任何文件
```    
我们可以用main函数来传递参数指定的：    
```
ifstream input(argv[1]);  //打开销售记录文件
ofstream output(argv[2]); //打开输出文件
Sales_data total;         //保存销售额的总量    
if (read(input, total)){
    Sales_data trans;
    while (read(input, trans)) {
        if (total.isbn() == trans.isbn())
            total.combine(trans);
        else {
            print(output, total) << endl;
            total = trans;
        }
        print(output, total) << endl;
    }
} else
    cerr << "No data?!" << endl;
```
除了读写是命名文件以外，这段程序与229页的加法程序几乎完全一样，虽然read和print定义的时候都是istream&和ostream&，但是我们仍然能够传递fstream的对象。    
#### open和close    
```
ifstream in(ifile);   //构筑一个ifstream并打开给定文件
ofstream out;         //输出文件流未与任何文件关联
out.open(ifile + ".copy");  //打开指定文件

if (out)  //检查是否打开成功
    //执行
in.close(); //一旦文件被打开，再open就会错误，所以需要先close再open
in.open(ifile + "2");
```    
此外fstream的自动析构函数中，会自动调用close()，所以无需担心局部变量未被关闭。   
### 8.2.2 文件模式
每个流都有一个关联的**文件模式**：   
- in: 以读方式打开
- out: 以写方式打开
- app: 每次写操作均定位到文件末尾
- ate: 打开文件后立即定位到文件末尾
- truc: 截断文件    
- binary: 以二进制方式进行IO    
默认情况下，文件会以truc模式打开（out清空先前全部内容，重新指向文件头开始写入）解决问题的方式是使用app模式同时打开：   
```
ofstream app("file2", ofstream::app); //隐含为输出模式
ofstream app2("file2", ofstream::out | ofstream::app);
```        

## 8.3 string流    
sstream定义了三个类型支持string的IO，istringstream、ostringstream、stringstream。    
### 8.3.1 使用istringstream    
当某些工作是对郑航文本处理，而其他一些工作是处理单行内的单个单词，通常可以使用istringstream;     
例如输入一个表格，每行都是一个人带他的几个号码。首先定义一个简单的类来描述输入数据：   
```
struct PersonInfo {
    string name;
    vector<string> phones;
};
```    
我们读取该数据文件，并且在一个循环中反复读取一条记录，提取一个人名和若干号码：   
```
string line, word;
vector<PersonInfo> people;
while (getline(cin, line)) {
    PersonInfo info;
    istringstream record(line);
    record >> info.name;      //这里解释为读到空格截止   
    while (record >> word)
        info.phones.push_back(word);
    people.push_back(info);
}
```    

### 8.3.2 使用ostringstream    
当我们希望一起打印信息时，ostringstream是很有用的。例如我们希望验证每个电话格式，然后进行打印。我们先将所有输出内容“写入”到一个内存ostringstream中：   
```
for (const auto &entry : people) {
    ostringstream formatted, badNums;  //每个循环步创建的对象
    for (const auto &num : entry.phones) {
        if (!valid(nums)) {
            badNums << " " << nums;
        }
        else
        {
            formatted << " " << format(nums);
        }
    }
    if (badNums.str().empty())
        os << entry.name << " " << formatted.str() << endl;
    else
        cerr << "input error:" << entry;
}
```

# 第9章 顺序容器
这章我们首先着重介绍**顺序容器(sequential container)**。    
## 9.1 顺序容器概述：    
顺序容器有很多，但是在不同方面性能又有折中：   
- 向容器添加或从容器中删除元素的代价；
- 非顺序访问容器中元素的代价；   
有以下顺序容器：    
- vector: 可变大小数组；支持随机快速访问，在尾部之外的位置或删除元素变得很慢；   
- deque: 双端队列。支持快速随机访问。在头尾位置插入、删除速度很快；   
- list: 双向链表；只支持双向顺序访问，在list的任何位置插入/删除都很快   
- forward_list: 单向链表。只支持单向顺序访问，在链表的任何位置插入/删除都很快
- array: 固定大小数组，支持快速随机访问，不能添加或者删除元素。   
- string: 与vector类似的容器，但是专门用于保存字符。随机访问快。在尾部插入/删除的速度快。    
#### 确定使用哪种顺序容器    
通常使用vector是最好的选择，以下是一些选择容器的基本原则：    
- 如果有很多小的元素，并且空间的额外开销很重要，不要使用list或者forward_list;
- 若果要求随机访问元素，应该使用vector或者deque；
- 如果程序要求中间插入或者删除元素，应该使用list或者forwardlist；   
- 如果程序需要在头尾位置插入或者删除元素，但是不会在中间插入或者删除，使用dequeue；    
- 如果程序只有在数据读入的时候才需要在容器中间位置插入元素，随后需要随机访问元素：   
首先需要去定是否真的是需要在容器中间添加元素。如果一般要得到有序的序列，应该使用vector添加数据，然后调用标准库的sort函数来重排；   
如果硬要在中间位置插入元素，则考虑在输入阶段使用list，一旦输入完成，将会把list中的内容拷贝到一个vector中。    

## 9.2 容器库概览    
#### 对容器可以保存的元素类型的限制    
虽然我们可以在容器中保存几乎任何类型，但是有些情况需要单独讨论，例如顺序容器有一个版本的构造函数接受容器大小的参数，它就会使用了元素类型的默认构造函数。所以这种类型的容器在构造时不能只传递一个元素数目参数：   
```
//假设noDefault是一个没有默认构造函数的类型   
vector<noDefault> v1(10, init);    //正确：提供了元素初始化器（init是个noDefault类型的值）
vector<noDefault> v2(10);          //错误：必须提供一个元素初始化器
```    

### 9.2.1 迭代器    
这里基本都知道，唯一有些区别的是，forward_list的迭代器不支持递减运算符（--）   
#### 迭代器范围     
这里提到C++的一个重要概念，**左闭合区间**：   
[begin, end)
这里end可以和begin指向相同的位置，但是不能指向begin之前，这反映到迭代器中就是begin()和end()所分别代表的迭代器；    

### 9.2.2 容器类型成员    
我们已经见过几个类型：size_type、iterator和const_iterator;当然其实一般还提供了反向迭代器(reverse_iterator)，如果对一个反向迭代器++，那么会得到上一个元素。    
剩下的就是类型别名。我们可以在不了解元素类型的情况下使用它，例如如果我们需要知道元素类型，我们使用value_type；如果需要元素类型的一个引用，可以使用reference或者const_reference。这样的元素相关的类型别名在**泛型编程**中相当有用，后面我们会介绍它。    
这些类型再使用时，我们必须显式的使用其类名：   
```
list<string>::iterator iter;
vector<int>::difference_type count;
```   

### 9.2.3 begin和end成员    
没啥好说的     

### 9.2.4 容器的定义和初始化    
这里指出，除了array之外，其他类容器的构造函数都支持创建一个指定类型的空容器：   
- C c         使用默认构造函数的空容器；    
- C c1(c2)    c1初始化为c2的拷贝,c1和c2必须是相同的类型；写成C c1=c2也可以；
- C c{a, b, c}或者c = {d, e} 列表初始化   
- C c(iter_b, iter_e) 使用迭代器进行指定范围内的初始化    
顺序容器才支持的初始化：
- C seq(n)    seq包含n个元素；   
- C seq(n, t) seq包含n个初始化为值t的元素；    

这里尤其推荐迭代器初始化的方式，因为这样**可以方便的跨不同顺序容器之间初始化**；    

#### 标准库array具有固定大小    
array最特殊的就在于固定大小，当定义一个array时，除了指定元素类型，还需要指定容器大小：   
```
array<int, 42>      //类型为：保存了42个int的数组
array<string, 10>   //类型为：保存了10个string的数组

array<int, 10>::size_type i; //数组包含了元素类型和大小
array<int>::size_type j;     //错误，因为前者不是一个类型！
```
同时，由于array默认构造特性，它一定是非空的，如果初始化列表数量不够，则会在后面跟着使用默认初始化函数构造到填满array元素：   
```
array<int, 10> ia3 = {42};  //ia3[0]为42，剩余元素为0
```    
有意思的是，虽然array各方面和数组非常像，但是**数组不支持的拷贝或者赋值操作**，在array里行得通：   
```
int digs[2] = {1, 2};
int cpy[2] = digs;
array<int, 10> digits = {1, 2};
array<int, 10> copy = digits;
```    

### 9.2.5 赋值和swap    
赋值运算符可以用于所有的容器，赋值运算符可以把左边容器中的全部元素换成右边容器中元素的拷贝：   
```
c1 = c2;   //不管c1和c2之前大小如何，赋值后大小和数量和c2一模一样
c1 = {a, b, c}; //赋值后，c1大小为3
```   
另一个操作是swap，stl中的调用形式为：   
```
swap(c1, c2); //swap比c2向c1拷贝要快得多
```    
此外还有assign操作，类似迭代器构造函数，例如：   
```
seq.assign(itb, ite);
```    
这里给出一个例子，注意assign同样是对象完全被覆盖：   
```
list<string> names;
vector<const char*> oldstyle;   
names = oldstyle;  //错误：容器类型不匹配    
names.assign(oldstyle.cbegin(), oldstyle.cend());
```    
swap的隐藏陷阱：因为swap是内存数据结构的整体交换，这意味着，（除了string以外）指向容器的迭代器、引用和指针在swap操作之后都不会失效，但时实际上它们已经不属于容器了。当然string的迭代器啥的均已失效。这点尤其要注意，否则很容易出现一些奇怪的bug;    
swap对array是稍有不同的，它是真正的会交换元素，时间和array中元素数量成正比。   
在新标准中，容器既提供了成员函数版本的swap，也提供了非成员版本的swap，而早期的标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的，所以尽量用非成员版本吧~    
    
### 9.2.7 关系运算符     
每个容器都支持==和!=,除了无序关联容器，都支持关系运算符（>、<、>=、<=）,其比较策略类似string的比较。   
> Note:只有当其元素类型定义了相应的比较运算符只有，我们才可以使用关系运算符来比较两个容器；    
     
## 9.3 顺序容器的操作    
### 9.3.1 向顺序容器添加元素    
- push_back/emplace_back: 在c的尾部创建一个值为t或者由args创建的元素，返回void；    
- push_front/emplace_front: 与上面相反，在头部添加；   
- insert(p, t)/emplace(p, args)：在迭代器p指向的元素**前**创建一个值为t或者由args创建的元素，返回指向新添加元素的迭代器；    

> 关键概念——容器元素是拷贝：当我们用一个对象来初始化容器时，实际上放入容器的是对象的一个拷贝，而非对象本身；    

#### 使用insert的返回值    
使用insert的返回值，作用是可以反复的在同一个位置进行插入：   
```
list<string> lst;
auto iter = lst.begin();
while (cin >> word)
    iter = lst.insert(iter, word);
```    

#### 使用emplace操作    
新标准的三个新成员函数——emplace_front、emplace和emplace_back，这些操作构造不是拷贝元素，而是分别将参数擦混递给元素类型的构造函数，并用其直接构造元素，例如：   
```
c.emplace_back("89757", 25, 15.99);
```
其传递的参数类型必须和类型的构造函数类型相匹配；    

### 9.3.2 访问元素    
除了forward_list，包含array在内的顺序容器都有front和back成员函数，来返回首元素和尾元素的引用：   
```
if (!c.empty()) {
    auto val = *c.begin(), val2 = c.front();
    auto last = c.end();
    auto val3 = *(--last); //注意，此处不能递减forward_list的迭代器
    auto val4 = c.back();    
}
```    
这里有两点需要注意：   
1. 迭代器的end一定是指向尾元素后的空元素，为了获取尾元素，必须先递减该迭代器；   
2. 进行任何操作前，需要确保c非空；否则后面的操作都可能是未定义的；    

此外注意，**访问成员函数返回的是引用**：   
```
if (!c.empty()) {
    c.front() = 42;
    auto &v = c.back();
    v = 1024;                //改变了c中的元素
    auto v2 = c.back();
    v2 = 0;                  //未改变
}
```     
#### 下标操作和安全的随机访问    
string、vector、deque和array均提供了下标运算符，我们永远希望下标时合法的，at函数可以略微规避一下类似的风险：    
```
vector<string> svec;   //空vector
cout << svec[0];       //运行错误
cout << svec.at(0);    //抛出一个out_of_range异常
```    

### 9.3.3 删除元素    
- pop_back()、pop_front() 
- erase(p): 
例如：    
```
while (!ilist.empty()) {
    process(ilist.front());  //对ilist的首元素进行一些处理
    ilist.pop_front();       //完成后删除首元素    
}
```    
如果从容器内部删除一个元素，erase既允许我们从指定位置删除元素，也可以删除一对迭代器指定的范围内所有元素，注意：**两种形式的erase都返回的是指向删除的（最后一个）元素之后位置的迭代器**，例如，这边给出了一个循环中删除list中所奇数元素的例子：    
```
list<int> lst = {0, 1, 2, 3, 4, 5};
auto it = lst.begin();
while (it != lst.end())
    if (*it % 2)  //若元素为奇数
        it = lst.erase(it);   //删除此元素，此时指向的是原it的下一个元素
    else
        ++it;
```    
如果要删除多个元素，例如：    
```
elem1 = slist.erase(elem1, elem2); //调用后,elem1 == elem2   
```
迭代器elem1指向我们要删除的第一个元素，而elem2指向我们要删除的最后一个元素之后的位置；     

### 9.3.5 改变容器的大小    
```
list<int> ilist(10, 42);  //10个int，每个值都是42
ilist.resize(15);         //后面跟5个0
ilist.resize(25, -1);     //添加10个-1
ilist.resize(20);         //删除后面20个元素
```    

### 9.3.6 容器操作可能使迭代器失效
这个是很明显的，尤其对于vector这种根据现有体积不断改变固定存储的结构类型；目前来看，vector、stirng或者deque这三种都必须要考虑迭代器、引用和指针失效的问题：   
```
//傻瓜循环，删除偶数元素，复制每个奇数元素   
vector<int > vi = {0~9};
auto iter = vi.begin(); 
while (iter != vi.end()) {
    if (*iter % 2) {
        iter = vi.insert(iter, *iter);  //复制
        iter += 2;                      //向前移动迭代器，跳过当前元素以及出插入到它之前的元素    
    }
    else
        iter = vi.erase(iter);
}
```   
这里最难理解的应该就是插入是在给定迭代器位置之前插入，而返回的是指向新数据位置的迭代器，因此要向后移动两位；而erase已经指向删除后的有效下一位了；       
#### 不要保存end返回的迭代器    
每次我们添加删除vector或者string的元素后，或者deque，原来的end返回的迭代器总会失效。因此我们需要反复调用end()，而不能只是在循环中使用之前end的返回值；C++考虑到这一点做了很多优化，end()操作都特别快的部分原因就在于此；    
例如：   
```
auto begin = v.begin(),
        end = v.end();
while(begin != end)
{
    //操作
    //插入新值，对begin重新复制，否则会失效
    ++begin;  //向前移动begin，因为想在此新元素之后插入元素
    begin = v.insert(begin, 42); //插入新值
    ++begin;  //移动到下一位
}
```   
在绝大多数的标准库是实现上，改代码会导致无限循环，因为这个end不会再指向v中任何元素，而是指向v中尾元素之后的位置；安全的方法是直接调用``while(begin != v.end())``    

## 9.4 vector对象是如何增长的    
总体来说，vector使用了“二倍法”的空间管理方式，在综合上甚至效率超过了deque和list。    

## 9.6 容器适配器     
除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。**适配器**是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一种适配器是一种机制，能够使某种事物行为看上去像是另一种事物一样。    
#### 定义一个适配器    
每个适配器都定义了两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝来初始化适配器。例如，假定deq是一个deque<int>，我们可以用一个deq来初始化一个新的stack,如下所示：    
```
stack<int> stk(deq);     //从deq拷贝元素到stk
```    
默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。    
```
//在vector上实现的空栈
stack<string, vector<string>> str_stk;
//str_stk2在vector上实现，初始化保存svec的拷贝
stack<string, vector<string>> str_stk2(svec);
```    
对于一个给定的适配器，可以使用哪些容器时有限制的。所有适配器都要求容器有添加和删除元素的容器。因此，适配器不能构建在array上，类似的，我们也不能用forward_list来构造适配器，因为所有适配器都要去容器具有添加、删除以及访问尾元素的能力。stack只要求push_back、pop_back和back操作，因此可以使用除array和forward_list之外的任何容器来构造stack。queue适配器要求back、push_back、front和push_front，因此它可以构造于list或者deque之上，但是不能构造于vector之上。priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此它可以构造与vector或者deque之上，但是不能基于list构造。
#### 栈适配器
```
stack<int> intStack;  //空栈
//填满栈
for (size_t ix = 0; ix != 10; ++ix)
    intStack.push(ix);   //inStack保存10个数
while (!inStack.empty()) {
    int value = intStack.top();
    //使用该值
    intStack.pop();  //弹出栈顶元素，继续循环
}
```

# 第10章 泛型算法
标准库定义操作非常有限，标准库并未给每个容器添加大量功能，而是提供了一系列算法，这些算法的绝大多数都独立于任何特定的容器，这些算法是通用的（generic，或者成为泛型的）
## 10.1 概述
大多数算法定义都在头文件algorithm中，标准库还在头文件numeric中定义了一组数值泛型算法。
一般情况下，这些算法并不会直接操控容器，而是遍历由两个迭代器指定的一个元素范围。例如我们需要在一个vector中寻找最大的int，使用标准库的find函数：
```
int val = 42;
auto result = find(vec.cbegin(), vec.cend(), val);
cout << "The value " << val << (result == vec.cend() ? "is not present" : "is present") << endl;
```
由于find操作的是迭代器，因此我们可以用同样的find函数在任何容器中查找值，例如使用find在一个string的list中查找一个给定值：
```
string val = "a value";
auto result = find(lst.cbegin(), lst.cend(), val);
```
甚至，类似的算法可以在数组中进行运用：
```
int ia[] = {1, 2, 3, 5, 10};
int val = 83;
int *result = find(begin(id), end(ia), val);
```
当然更可以在指定范围内进行运用：
```
auto result = find(ia + 1, ia + 4, val);
```
迭代器令算法不依赖于容器，但是依赖于元素类型的操作（对于不同的算法，它要求能够支持==号或者<、>运算符）
## 10.2 初识泛型算法
虽然各类算法遍历输入范围的方式相似，但是它们使用范围中的元素的方式不同。理解算法的最基本的方法就是他们是否读取元素、改变元素或者重排元素；
### 10.2.1 只读算法
一些算法只会读取其输入范围内的元素，而不改变元素。find就是这样一种算法，之前的count也是。
另一个只读算法是accumulate,它定义在头文件numeric中。accumulate函数接受三个参数，前两个是范围，最后一个数是和的处置，假定vec是一个整数序列：
```
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
```
> Tip:accumulate的第三个参数类型决定了函数中哪个加法运算符以及返回值的类型。
#### 算法和元素类型
accumulate将第三个参数作为求和起点，这里蕴含的一个假定就是：**将元素类型加到和的类型上操作必须是可行的**，即序列中的元素的类型必须和第三个参数匹配，或者能够转换为第三个参数的类型。在上面这个例子中，vec中的元素是可以是int，或者是double、long long或其它任何可以加到int上的类型。
例如，由于string定义了+运算符，可以写出：
```
string sum = accumulate(v.cbegin(), v.cend(), string(""));
```
这里注意，必须第三个参数需要显式的创建一个string，如果只是传递一个空串，会导致编译错误（因为空串会默认为是const char*）。
#### 操作两个序列的算法
另一个只读算法是equal。将第一个序列和第二个序列进行比较：
```
equal(roster1.cbegin(), roster1.cend(), roster2.cbeing());
```
注意，这里和之前有两点不同：1. 由于equal利用迭代器完成操作，可以比较不同类型的容器中元素，而且连元素类型也不必一样，只要我们能用==来比较两个元素类型就可以，流入roster1可以是vector<string>，roster2可以是list<const char*>。2. 这里有另一个区别在于，roster2的长度至少和roster1一样，否则会访问越界（这代表使用前需要直接先比较下size）；
### 10.2.2 写容器元素的算法
一些算法将新值赋予序列中的元素，当我们使用这类算法时，必须注意保证序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此它们自身不可能改变容器大小。
一些算法会自己向输入范围写入元素，这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。
例如，算法fill接受一对迭代器表示一个范围，同时还接受一个值作为第三个参数，fill将会把这个值赋给输入序列中的每个元素:
```
fill(vec.begin(), vec.end(), 0);
fill(vec.begin(), vec.begin() + vec.size() / 2, 10);
```
#### 算法不检查写操作
一些算法接受一个迭代器来只出一个单独的目的位置。例如函数fill_n，它接受一个但迭代器、一个计数值和一个值。它将给定赋予迭代器指向的元素开始的指定个元素。我们可以用fill_n将一个新值赋予vector中的元素：
```
vector<int> vec;
//使用vec赋予它不同值
fill_n(vec.begin(), vec.size(), 0);
```
函数fill_n假定写入指定个元素是安全的，即如下的调用形式：
```
fill_n(dest, n, val);
```
注意，不要再空容器上调用fill_n。即向目的位置写入数据的算法嘉定目的位置足够大，能容纳要写入的元素。
#### 介绍back_insert
一种保证算法有足够元素空间来容纳输入输出数据的方法是使用**插入迭代器**，插入迭代器是一种向容器中添加元素的迭代器。通常，我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素，而当我们通过一个插入迭代器赋值时，一个与赋值号右侧相等的元素被添加到容器中。
我们将会在后文中介绍迭代计算器，我们先通过back_inserter来展示用算法写入数据，它是包含在头文件iterator中的一个函数。
back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：
```
vector<int> vec;  //孔箱梁
auto it = back_inserter(vec); //通过它赋值会奖元素添加到vec中
*it = 42;  //vec中现在有一个元素，值为42
```
我们通常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用，例如：
```
vector<int> vec;
fill_n(back_inserter(vec), 10, 0);
```
在每步的迭代中，fill_n向给定序列的一个元素赋值，由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。
#### 拷贝算法
有点类似equal算法，就是将前者全部元素拷贝至后者对应位置上，仍然需要遵守后者size>=前者size的规定：
```
int a1[] = {0, 1, 2, 3, 4, 5};
int a2[sizeof(a1) / size(*a1)];
auto ret = copy(begin(a1), end(a1), a2); //ret指向拷贝到a2尾元素之后的元素
```
多个算法都提供所谓的“拷贝版本”, 这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新序列保存这些结果。
例如,replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值，此算法接受4个参数，前两个是迭代器，表示输入的序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：
```
//将所有值为0的数替换为42
replace(ilst.begin(), ilst.end(), 0, 42);
```
此调用将序列中所有的0替换为42，如果我们希望保持原序列不变，可以调用replace_copy,此算法接受额外第三个迭代器参数，指出调整后的保存位置：
```
//使用back_inserter按需要增长目标序列
replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), 0, 42);
```
### 10.2.3 重排容器元素的算法
某些算法会重排容器中的元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序。它是利用元素类型的<运算符来实现排序的。
例如，我们想要从一段话中，获取一个按照字符排序并且不重复的结果，那么我们需要：
#### 消除重复单词
为了消除重复单词，应先将vector排序，是的重复的单词都相邻出现，一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分，由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作：
```
void elimDups(vector<string> &words)
{
    sort(words.begin(), words.end());
    auto end_unique = unique(words.begin(), words.end()); //Unique重排输入范围，使得每个单词出现一次。该函数排列在范围的前部，返回指向不重复区域后一个位置的迭代器
    words.erase(end_unique, words.end());  //使用向量操作erase删除重复单词
}
```
注意，使用unique并没有删除words的元素，但是使这些元素的顺序改变了，返回的是不重复的元素后的位置（后面的内容未定）。之后我们需要使用容器的的erase函数删除从end_unique开始至words末尾范围内的所有元素。
值得注意的是，即使是words中没有重复单词，这样做也是安全的，因为unique会返回words.end()，这样最后删除的是一个空范围；
## 10.3 定制操作
很多算法都会比较输入序列中的元素，默认情况下，这类算法使用元素类型的<或者==运算符完成比较，标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。
例如，sort算法默认使用元素的<运算符，但是我们希望排序顺序与<所定义的顺序不同，或者我们的序列可能保存的是未定义<运算符的元素类型（如Sales_data），这两种情况下，都需要重载sort的默认行为。
### 10.3.1 向算法传递函数
我们准备对上面的elimDups进行更改，我们还希望按照长度排序，此版本接受第三个参数，这个参数是一个谓词(predicate)。
#### 谓词
谓词是一个可嗲用的表达式，其返回结果是一个能够作为条件的值，标准库算法使用的谓词分为两类：**一元谓词（unary predicate）**和**二元谓词（binary predicate）**。接受谓词的参数的算法对输入序列的元素调用谓词，因此，元素类型必须能转换为谓词的参数类型。
接受一个二元谓词的sort版本用这个谓词代替<来比较元素，此操作必须在输入序列中所有可能的元素值上定一个一致的序列。例如之前的isShort:
```
bool isShorter(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}
sort(words.begin(), words.end(), isShorter);
```
#### 排序算法
在我们将words按大小重排的同时，还希望具有相同长度的元素按字典序排列。为了保持相同长度的单词按照字典序排序，可以使用stable_sort算法，这种稳定排序算法维持想等元素的原有顺序。
通常情况，我们不关心有序序列中相等元素的相对顺序，它们毕竟是相等的。但是在本例中，我们定义的相等关系表示具有相同长度，而具有相同长度的元素，如果看其内容，其实还是各不相同的，通过调用stable_sort，可以保持等长元素，如果看内容，其实还是各不相等的。通过调用stable_sort,可以保持等长元素间的字典序：
```
elimDups(words);
stable_sort(words.begin(), words.end(), isShorter);
for (const auto &s : words)
    cout << s << " ";
cout << endl;
```
### 10.3.2 lambda表达式
根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或者两个参数，但是有时候我们希望进行的操作需要更多的参数，超出了算法对谓词的限制，例如上一节的程序，就必须将大小5硬编码到划分序的谓词中。如果在编写划分序列的谓词时，可以不必为每个可能的大小都编写一个独立的谓词，这样更有实际运用价值。
一个相关的例子是，我们将修改程序，求大于等于一个给定长度的单词有多少，我们还会修改输出，使得程序只打印大于等于给定长度的单词，我们将此函数命名为biggies，其框架如下所示：
```
void biggies(vector<string> &words, vector<string>::size_type sz)
{
    elimDups(words);  //将words按字典排序，删除重复单词
    //按长度排序，长度相同的单词维持字典序
    stable_sort(words.begin(), words.end(), isShorter);
    //获取一个迭代器，指向第一个size()>=sz的元素
    //计算满足size>=sz的元素的数目
    //打印长度大于等于给定值的单词，每个单词后面接一个空格
}
```
所以新问题变成了在vector中寻找第一个大于等于给定长度的元素，一旦找到了这个元素，根据位置，就可以计算出有多少元素的长度大于等于给定值。
我们可以使用标准库find_if算法来查找第一个具有特定大小的元素。类似find，find_if算法接受一对迭代器，表示一个范围。但与find不同的是，find_if的第三个参数是一个谓词。find_if算法对输入序列中的每个元素调用给定的这个谓词。它返回第一个使谓词返回非0的元素，如果不存在这样的元素，则返回尾迭代器。
编写一个函数，使其接受一个string和一个长度，并且返回一个bool值表示该string的长度是否大于给定的长度，是一件很容易的事，但是find_it接受一元谓词——我们传递给find_fi的任何函数都必须很严格的接受一个参数，以便于来自输入序列的一个元素来调用它。没有任何办法能传递给它第二个参数来表示长度，为了解决该问题，需要介绍使用另外一些语言特性。
#### 介绍lambda
我们可以向一个算法传递以任何类别的**可调用对象(callable object)**，对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为尅盗用的。即如果e是一个可调用的表达式，我们可以编写代码e(args)，则args是一个逗号分隔的一个或者多个参数的列表。
到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针，还有其他两种可调用对象：重载了函数调用运算符的类，这个我们将在下面介绍，以及lambda表示。
一个lambda表达式表示一个可调用的代码单元，我们可以将其理解成**一个未命名内联函数**。与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式：
```
[capture list](parameter list) -> return type {function body}
```
其中，capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）：return type、parameter list和function body与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同，**lambda必须使用尾置返回来指定返回类型**。
我们可以忽略参数列表和返回类型，但**必须永远包含捕获列表和函数体**：
```
auto f = []{return 42;};
```
此例中，我们定义了一个可调用的对象f，它不接受参数，返回42；
lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符：
```
cout << f() << endl;   //打印42
```
在lambda中忽略括号和参数列表等价于制定一个空参数列表。在此例中，当调用f时，参数列表是空的。如果忽略返回类型，lambda根据函数体的代码推断出返回类型。如果函数体只是一个return语句，则返回类型从返回的表达式的类型推断而来，否则返回类型为void。
> Note:如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。
#### 向lambda传递参数
与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参，通常实参和形参的类型必须匹配。但是与普通函数不同，l**ambda不能有默认参数**，因此一个lambda调用的实参数目永远和形参数目相等，一旦形参初始化完毕，就可以执行函数体了。
作为一个带参数的lambda的例子，我们可以编写一个与isShorter函数完成相同功能的lambda:
```
[](const string &a, const string &b){ return a.size() < b.size();}
```
空捕获列表表明此lambda不使用它所在函数中的任何局部变量，lambda的参数与isShorter参数类型类似，是const string的引用。lambda的函数也与isShorter类似，比较两个参数的size()，并根据两者的大小返回一个布尔值。
如下所示，可以使用此lambda来调用stable_sort:
```
stable_sort(words.begin(), words.end(),
            [](const string &a, const string &b)
            {return a.size() < b.size();});
```
#### 使用捕获列表
我们现在已经准备好解决原来的问题了——编写一个可以传递给find_if的可调用表达式。我们希望这个表还是能将输入序列中每个string的长度与biggies函数中的sz参数的值可以比较。
虽然一个lambda可以出现在一个函数，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需的信息。
在本例中，我们的lambda会捕获sz，并只有单一的string参数。其函体会将string的大小与捕获的sz的值进行比较：
```
[sz](const string &a){ return a.size() >= sz;}
```
lambda以一对[]开始，我们可以在其中提供一个以逗号分割的名字列表，**这些名字都是它所在的函数中定义的**。
由于捕获sz，因此lambda的函数体重可以使用sz。lambda不捕获words,因此不能访问此变量。如果我们给lambda提供一个空捕获列表，则代码会提示编译错误：
> Note：一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体重使用该变量。
#### 调用find_if
使用此lambda，我们可以查找第一个长度大于等于sz的元素：
```
//获取一个迭代器，指向第一个满足size()>=sz的元素
auto wc = find_if(words.begin(), words.end(),
            [](const string &a)
            {return a.size() >= sz});
```
这里对find_if的嗲用返回一个迭代器，指向第一个长度不小于给定参数sz的元素。如果这样的元素不存在，则返回words.end()的一个拷贝。
我们可以使用find_if返回的迭代器来计算从它开始到words末尾一共有多少个元素：
```
auto count = words.end() - wc;
cout << count << " " << make_plural(count, "word", "s") << " of length " << sz << " or longer" << endl;
```
#### for_each算法
问题的最后一部分是打印words中长度大于等于sz的元素，为了达到这个目的，我们可以使用for_each算法。此算法接受一个可调用对象，并对输入序列每个元素调用此对象：
```
for_each(wc, words.end(), [](const string &s){cout << s << " ";});
cout << endl;
```
此lambda中的捕获列表为空，是因为我们只对在lambda所在函数中定义的（非static）变量使用捕获列表。一个lambda可以直接使用定义在当前函数之外的名字。在本例中，cout不是定义在biggies中局部名字，而是定义在头文件iostream中。因此，只要在biggies出现的作用域中包含了头文件iostream，我们的lambda就可以使用cout。
> Note:捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字；
#### 完整的biggies
```
void bigges(vector<string> &words, vector<string>::size_type sz)
{
    elimDups(words); //将words按字典排序，并删除重复单词
    //按长度排序，长度相同的单词维持字典序
    stable_sort(words.begin(), words.end(),
                [sz](const string &a){ return a.size() >= sz;});
    //计算满足size >= sz的元素数目
    auto count = words.end() - wc;
    cout << count << " " << make_plural(count, "word", "s")
         << " of length " << sz << " or longer" << endl;
    //打印长度大于等于给定值的单词，每个单词后面接一个空格
    for_each(wc, words.end(),
             [](const string &s){cout << s << " ";});
    cout << endl;
}
```
### 10.3.3 lambda捕获和返回
当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型，下文会进行介绍。目前可以这样理解，当向一个函数传递了一个lambda时，同时定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。
默认情况下，从lambda生成的类都包含一个对应该lambda所捕获变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。
#### 值捕获
类似参数传递，变量的捕获方式也可以是值或者引用。到目前为止，文中所使用的lambda采用值捕获的方式。与传值参数类似，采用织布或的前提是变量可拷贝。与参数不同，被捕获的变量是在lambda创建时拷贝，而不是调用时拷贝：
```
void fcn1()
{
    size_t v1 = 42; //局部变量
    auto f = [v1]{return v1;}
    v1 = 0;
    auto j = f();
}
```
#### 引用捕获
同时可以使用引用捕获，例如：
```
void fcn2()
{
    size_t v1 = 42;
    auto f2 = [&v1]{return v1;}
    v1 = 0;
    auto j = f2();  //j为0，f2保存v1的引用，而非拷贝
}
````
v1之前的&指出v1应该以引用的方式捕获，一个以引用方式捕获的变量与其他任何类型的引用类型类似。引用捕获与返回引用有着相同的问题和限制，如果我们采用引用方式捕获一个变量，就必须确保被引用的对象，就必须确保引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。
引用捕获有时候是有必要的，例如有时候我们希望biggies函数接受一个ostream的引用，用来输出数据，并接受一个字符作为分隔符：
```
void biggies(vector<string> &words,
             vector<string>::size_type sz,
             ostream &os = cout,
             char c = ' ')
{
    //重排
    for_each(words.begin(), words.end(),
             [&os, c](const string &s){ os << s << c;});
}
```
我们不能拷贝ostream对象，因此捕获os的唯一方法就是捕获其引用（或者指向os的指针）。
当我们向一个函数传递传递一个lambda时，就像本例中调用for_each那样，lambda会立即执行。因为当for_each执行时，biggies中的变量是存在的。
我们也可以从一个函数返回lambda，函数可以直接返回一个可调用对象，或者返回一个类对象，该类可能含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，次lambda也不能包含引用捕获。
#### 隐式捕获
除了显式列出我们希望使用的来自所在的函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或者=。&告诉编译器采用的捕获引用方式，=则表示采用值捕获的方式。例如，我们可以重写传递给find_if的lambda:
```
wc = find_if(words.begin(), words.end(),
             [=](const string &s)
             { return s.size() >=  sz;});
```
如果我们希望一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显示捕获：
```
void biggies(vector<string> &word,
             vector<string>::size_type sz,
             ostream &os = cout, char c = ' ')
{
    for_each(words.begin(), words.end(),
             [&, c](const string &s){ os << s << c;}); //os隐式捕获，引用捕获方式，c显示捕获值捕获
    for_each(words.begin(), words.end(),
             [=, &os](const string &s){ os << s << c;}); //os显式捕获，引用捕获；c隐式捕获，值捕获方式
}
```
注意，当混合使用隐式捕获和显式捕获，捕获列表中的第一个元素必须是&或=。此符号指定了默认捕获方式为引用或值。
#### 可变lambda
默认情况下，对于一个值被拷贝的变量，lambda表达式不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表：
```
void fcn3()
{
    size_t v1 = 42;  //局部变量
    //f可以改变它所捕获的变量的值
    auto f = [v1]()mutable{return ++v1;};
    v1 = 0;
    auto j = f(); //j为43
}
```
一个引用捕获的变量是否可以修改依赖于此引用指向的是一个const类型还是一个非const类型：
```
void fcn4()
{
    size_t v1 = 42;  //局部变量
    auto f2 = [&v1]{ return ++v1; }
    v1 = 0;
    auto j = f2();   //j为1
}
```
#### 指定lambda返回类型
到目前为止，我们所编写的lambda都只包含单一的return语句，因此我们还未遇到必须指定返回类型的情况。默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。与其它返回void函数的类似，被推断返回void的lambda不能返回值。
下面给出一个简单的例子，我们可以使用标准库transform算法和一个lambda来将一个序列中每个负数来替换为其绝对值：
```
transform(vi.begin(), vi.end(), vi.begin(), [](int i){ return i < 0 ? -i : i; });
```
函数transform接受三个迭代器和一个可调用对象，前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列每个元素调用可调用对象，并将结果写到目的位置，如本例所示，目的位置迭代器和输入序列开始位置的迭代器可以是相同的。当输入迭代器和目的迭代器相同时，transform将输入序列中每个元素替换为可调用对象操作钙元素得到的结果。
我们如果使用传统等价if的语句，而不指定返回类型（让lambda自动推断），就会产生编译错误：
```
transform(vi.begin(), vi.end(), vi.begin(),
          [](int i){ if (i < 0) return -i; else return i;});
```
编译器推断这个lambda返回类型的void，但它返回了一个void。所以我们其实必须用尾置返回类型：
```
transform(vi.begin(), vi.end(), vi.begin(),
          [](int i)-> int{ if (i < 0) return -i; else return i;});
```
### 10.3.4 参数绑定
对于那种在一两个地方使用的简单操作，lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的lambda表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数会更好。
如果lambda的捕获列表为空，通常可以用函数来代替它。如前面章节所示，既可以用一个lambda，也可以用isShorter来实现vector中的单词按长度排序。类似的，对于打印vector内容的lambda，编写了一个函数来替换它也是很容易的事。这个函数只需要接受一个stirng并在标准输出上打印即可。
但是，对于局部捕获的变量的lambda，用函数替换它就不是很容易了，例如我们用find_if调用中的lambda比较一个string和一个给定大小。我们可以很容易的编写一个完成相同工作的函数：
```
bool check_size(const string &s, string::size_type sz)
{
    return s.size() >= sz;
}
```
但是，我们不能用这个函数作为find_if的一个参数，如前文所示，find_if接受一个一元谓词，因此传递给find_if的可调用对象必须接受单一参数。biggies传递给find_if的lambda使用捕获列表来保存sz。为了用check_size来代替此lambda，必须解决如何向sz形参传递一个参数的问题。
#### 标准库bind函数
我们可以解决向check_size传递一个长度参数的问题，方法是使用一个新的名为bind的标准库函数，它定义在头文件functional中，可以将bind函数看做一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来**适应**原对象的参数列表，其一般的调用形式为：
```
auto newCallable = bind(callable, arg_list);
```
其中newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给给定的callable参数。即当调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。
arg_list中的参数可能包含形如_n的名字，其中n是一个整数，这些参数是“**占位符**”，表示newCallable的参数，它们占据了传递给newCallable参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，以此类推。
#### 绑定check_size的sz参数
作为一个简单的例子，我们将使用bind生成一个调用check_size的对象，如下所示，它用一个定值作为其大小参数来调用check_size:
```
//check6是一个可调用对象，接受一个string类型的参数
//并用此string和值6来调用check_size
auto check6 = bind(check_size, _1, 6);
```
此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数应对check_size的第一个参数。此参数是一个const string&。因此调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。
```
string s = "hello";
bool b1 = check6(s);  //check6(s)会调用check_size(s, 6)
```
我们就可将原来基于lambda的bind_if的调用替换为使用check_size的版本：
```
auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz));
```
此bind调用生成一个可调用对象，将check_size将第二个参数绑定到sz值。当find_if对words中的string调用这个对象时，这些对象会调用check_size，将给定的string和sz传递给它。因此find_if可以有效地对输入序列中每个string调用check_size，实现string的大小与sz的比较。
#### 使用placeholder名字
名字_n都定义在一个名为placeholder的命名空间，而这个命名空间本身定义在std命名空间中。为了这些使用名字，两个命名空间都要写上。与我们其他例子类似，对bind的调用代码假定之前已经恰当使用了using声明。例如，_1对应的using的声明为：
```
using std::placeholders::_1;
```
此声明说明我们要使用名字_1定义在命名空间placeholders中，而此命名空间有定义在命名空间std中。
对每个占位符名字，我们都必须提供一个单独的using声明。编写这样的生命很麻烦，也很容易出错。可以使用另外一种不同形式的using语句，而不是分别声明每个占位符，如下所示：
```
using namespace namespace_name;
```
这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中使用，例如：
```
using namespace std::placeholders;
```
是的由placeholders定义的所有名字都可用，与bind函数一样，placeholders命名空间也定义在functional头文件中。
#### bind的参数
如前文所述，我们可以用bind修正参数的值，更一般的可以用bind绑定给定可调用对象中的参数或重新安排其顺序。例如，假定f是一个可调用对象，它有5个参数，则下面对bind的调用：
```
auto g = bind(f, a, b, _2, c, _1);
```
生成一个新的可调用对象，它有两个参数，分别用占位符_2和_1表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个参数分别被绑到给定的值a、b和c中。
传递给g的参数按位置绑定到占位符，即第一个参数绑定到_1，第二个参数绑定到_2。因此我们调用g时，其中一个参数将被传递给f作为最后一个参数，第二个参数将被传递给f作为第三个参数。实际上，这个bind调用会将``g(_1, _2)``映射为``f(a, b, _2, c, _1)``
#### 用bind重排参数顺序
这算是活用bind颠倒isShorter的含义：
```
sort(words.begin(), words.end(), isShorter);  //按单词长度由短至长排列
sort(words.begin(), words.end(), bind(isShorter, _2, _1));  //由长至短
```
在第一个调用中，当sort需要比较两个元素A和B时，它会调用isShorter(A, B)。在第二个对sort的调用中，传递给isShorter的参数被交换过来了，因此当sort比较两个元素时，就好像调用isShorter(B, A)一样。
#### 绑定引用参数
例如ostream经常会遇到为了替换一个引用方式捕获ostream的lambda：
```
for_each(words.begin(), words.end(), [&os, c](const string &s){ os << s << c;});
```
可以很容易的编写一个函数，完成相同的工作：
```
ostream &print(ostream &os, const string &s, char c)
{
    return os << s << c;
}
```
但是，不能直接用bind来代替对os的捕获：
```
for_each(words.begin(), words.end(), bind(print, os, _1, ' '));
```
原因在于bind拷贝其参数，而我们不能拷贝一个ostream。如果我们希望传递给bind一个对象而不拷贝它，就必须使用标准库ref函数：
```
for_each(words.begin(), words.end(), bind(print, ref));
```
函数ref返回一个对象，包含给定的引用。此对象是可以拷贝的。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样,函数ref和cref也定义在头文件functional中。
> 向后兼容：参数绑定
> 旧版本的C++提供的绑定函数参数语言特性限制更多，也更复杂。标准库定义了两个分别名为bind1st和bind2nd的函数。类似bind,这两个函数接受一个函数作为参考，生成一个新的可调用对象，该对象调用给定函数，并将绑定的参数传递给它。但是这些函数分别只能绑定第一个或者第二个参数。由于这些函数局限性太强，在新标准中已经被弃用(deprecated)。所谓被弃用的特性在新版本不再支持的特性，新的C++程序应该使用bind。
## 10.4 再谈迭代器
除了每个容器定义的迭代器外，标准在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。
- 插入迭代器(insert iterator):这些迭代器被绑定到一个容器上，可用来向容器插入元素。
- 流迭代器(stream iterator):这些迭代器被绑定到输入和输出流上，可以用来遍历所关联的IO流。
- 反向迭代器(reverse iterator):这些迭代器向后而不是向前移动，除了forward_list之外的标准容器库都有反向迭代器。
- 移动迭代器(move iterator):这些专用的迭代器不是拷贝其中的元素，而是为了移动他们。他们将会在后面介绍移动迭代器。
### 10.4.1 插入迭代器
插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。
> it = t:在it指定的当前位置插入t。类似调用原函数的push_back、push_front、insert
> *it、++it、it++:这些操作虽然存在，但是不会做任何事情，**每个操作都会返回it**
插入器有三种类型，差异在于元素插入的位置：
- back_inserter:创建一个push_back的迭代器；
- front_inserter:创建一个push_front的迭代器；
- inserter:创建一个insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素江北插入到给定跌大气所表示的元素之前。
理解插入器的工作过程很重要：当调用inserter(c, iter),得到一个迭代器，那么``*it = val;``过程等价于
```
it = c.insert(it, val); //it指向新加入的元素
++it; //递增it使它指向原来的元素
```
front_inserter生成的迭代器行为和inserter的行为完全不一样,当我们使用front_inserter时，元素总是插入到容器第一个元素之前。即使我们传递给inserter的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不会是容器首元素了：
```
list<int> lst = {1, 2, 3, 4};
list<int> lst2, lst3;
copy(lst.cbegin(), lst.cend(), front_inserter(lst2));  //lst2:4, 3, 2, 1
copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin())); //lst3: 1, 2, 3, 4
```
### 10.4.2 iostream迭代器
虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器。istream_iterator读取输入流，ostream_iterator向一个输出流写数据。这些迭代器将它们对应的流当做一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。
#### istream_iterator操作
当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个istream_iterator使用>>来读取流。因此istream_iterator要读取的类型必须定义了输入运算符。当创建一个istream_iterator时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就可以创建一个可以当做尾后值使用的迭代器。
```
istream_iterator<int> int_it(cin); //从cin读取int
istream_iterator<int> int_eof;     //尾后迭代器
ifstream in("afile");
istream_iterator<string> str_it(int);  //从"afile"读取字符串
```
下面是一个用istream_iterator从标准输入读取数据，存入一个vector的例子：
```
istream_iterator<int> in_iter(cin);  //从cin读取int
istream_iterator<int> eof;           //尾后迭代器
while (in_iter != eof)
    //后置递增运算读取流，返回迭代器的旧值
    //解引用迭代器，获得从流读取前的一个值
    vec.push_back(*in_iter++);
```
此循环从cin读取int值，保存在vec中。每个循环步中循环体代码检查in_iter是否等于eof。eof被定义为空的istream_iterator，*从而可以当做尾后迭代器来使用*。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或者遇到IO错误，迭代器的值与尾后迭代器相等。
此程序最困难的部分是传递给push_back的参数，其中用了引用运算符和后置递增运算符。该表达式的计算过程与我们之前写过的其他结合解引用和后置递增运算的表达式一样。后置的递增运算会从流中读取下一个值，向前推进，但返回的是迭代器的旧值。迭代器的旧值包含了从流中读取的前一个值，对迭代器进行解引用就能获得此值。
我们可以将程序重写为如下形式，这体现了istream_iterator更有用：
```
istream_iterator<int> in_iter(cin), eof;  //从cin读取int
vector<int> vec(in_iter, eof); //从迭代器构造vec
```
本例中我们用一对表示元素范围的迭代器来构造vec。这两个迭代器是istream_iterator，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从cin中读取数据，直至遇到文件尾或者遇到一个不是int的数据为止。从流中读取的数据来构造vec。
#### 使用算法操作流迭代器
由于算法使用迭代器来处理数据，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。下面例如我们可以用istream_iterator来调用accumulate:
```
istream_iterator<int> in(cin), eof;
cout << accumulate(in, eof, 0) << endl;
```
#### istream_iterator允许使用懒惰求值
当我们将一个istream_iterator绑定一个流时，标准库并不表征迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，知道我们使用迭代器才真正读取。标准库中的实现所表现的是，我们在第一次解引用迭代器之前，从流中读取数据的操作已经完成。对大多数程序来说，立即读取还是推迟读取没什么差别，但是如果我�������������创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取一个流，那么何时读取就可能很重要了。
#### ostream_iterator操作
我们可以对任何具有输出运算符（<<运算符）的类型定义ostream_iterator。当我们创建一个ostream_iterator时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印字符串。此字符串必须是一个C风格字符串。必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator。
```
ostream_iterator<int> out(cout, " ");
for (auto e : vec)
    *out_iter++ = e;  //
cout << endl;
```
此程序将vec中每个元素都写到cout，每个元素后加一个空格。每次向out_iter赋值，写操作就会被提交。
值得注意的是，当我们向out_iter赋值时，可以忽略解引用和递增运算。即循环可以重写成下面的样子：
```
for (auto e : vec)
    out_iter = e; //赋值语句将元素写到cout
cout << endl;
```
运算符*和++实际上对ostream_iterator对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是推荐第一种形式，因为在这种写法中，流迭代器使用和其他迭代器的使用保持一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且对于读者来说，此循环的行为也会更加清晰。
可以通过调用copy来打印vec中的元素，这比编写循环更为简单：
```
copy(vec.begin(), vec.end(), out_iter);
cout << endl;
```
#### 使用流迭代器处理类类型
我们可以为任何定义了输入运算符(>>)的类型创建istream_iterator对象，类似的，只要有输出运算符(<<)，我们就可以定义其ostream_iterator。由于Sales_item既有输入运算符又有输出运算符，因此可以使用IO迭代器重写前面的书店程序：
```
istream_iterator<Sales_item> item_iter(cin), eof;
ostream_iterator<Sales_item> out_iter(cout, "\n");
//将第一笔教育记录在sum中，并读取下一条记录
Sales_item sum = *item_iter++;
while (item_iter != eof) {
    if (item_iter->isb() == sum.isbn())
        sum += *item_iter++;
    else {
        out_iter = sum;
        sum = *item_iter++;
    }
}
out_iter = sum;
```
此程序使用item_iter从cin读取Sales_item交易记录，并将和写入cout，每个结果后面都跟一个换行符。定义了自己的迭代器后，我们既可以用item_iter读取第一条交易记录，用它的值来初始化sum:
```
Sales_item sum = *item_iter++;   //将第一条交易记录保存在sum中
```
此处，我们对item_iter执行后置递增操作，对结果进行解引用操作。这个表达会读取下一条交易记录，并用之前保存在item_iter中的值来初始化sum。
while循环会反复执行，直至在cin上遇到文件尾位置。在while循环体中，我们检查sum与刚刚读入的记录是否为同一本书。如果两者的ISBN不同，我们将sum赋予给out_iter,这将会打印sum的当前值，并接着打印sum的当前值，并接着打印一个换行符。在打印了前一本书的交易金额之和后，我们将最近读入交易记录的副本赋予sum，并递增迭代器，这将读取下一条交易记录，循环都会这样持续下去，直至遇到错误或者文件尾。在退出之前，及记住要打印输入中最后一本书的交易金额之和；
### 10.4.3 反向迭代器
反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器(++it)会移动到前一个元素，递减一个迭代器(--it)会移动到下一个元素。
除了forward_list之外，其它容器都支持反向迭代，我们可以通过调用rbegin、rend、crbegin和crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前的一个迭代器。例如下面给出一个反向迭代器打印的例子：
```
vector<int> vec = {0, 1, 2, 3, 4, 5};
for (auto r_iter = vec.crbegin(); r_iter != vec.crend(); ++r_iter)
    cout << *r_iter << endl;
```
虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但是这样可以使我们更透明的处理容器，例如向sort传递一对反向迭代器来将vector整理为递减序：
```
sort(vec.begin(), vec.end());
sort(vec.rbegin(), vec.rend());
```
注意，反向迭代器需要递减运算符，这个还是很好理解的。
#### 反向迭代器和其他迭代器之间的关系
假设一个名为line的string，保存着一个逗号分割的单词列表，我们希望打印line的第一个单词，使用find可以很容易完成者任务：
```
auto comma = find(line.cbegin(), line.cend(), ',');
cout << string(line.cbegin(), comma) << endl;
```
如果line中有逗号，那么comma将指向这个逗号。否则它将会等于line.cend()。
如果希望打印最后一个单词，就可以使用反向迭代器：
```
auto rcomma = find(line.crbegin(), line.crend(), ',');
```
最有意思的载入，如果我们企图使用逆序输出单词的字符：
```
cout << string(line.crbegin(), rcomma) << endl;
```
但它会生成错误的输出结果，例如输入LAST它会打印TSAL。这提醒我们，当输出的时候我们需要使用一个正向迭代器，所以需要将rcomma转换为一个普通的迭代器，来使得其在line中能够正向移动。我们通过调用reverse_iterator的base成员函数来完成该转换，此成员函数会返回其对应的普通迭代器：
```
cout << string(rcomma.base(), line.cend()) << endl;
```
**非常值得注意一点的就是，不管是正向还是逆向，都是严格遵守了左闭右开的原则，所以在使用base()函数转换时，迭代器位置会发生偏移**。为了实现这一点,rcomma和rcomma.base()必须生成相邻位置而不是相同位置。
## 10.5 泛型算法结构
任何算法最基本的特性是它要求其迭代器提供哪些操作。某些算法，例如find，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如sort，还要求读、写和随机访问元素的能力。算法所要求的的迭代器操作可以分为5个**迭代器类别**，每个算法都会对其迭代器参数指明须提供哪类迭代器。
- 输入迭代器：只读不写；单遍扫描，只能递增；
- 输出迭代器：只写不读；单遍扫描，只能递减；
- 前向迭代器：可读写；多遍扫描，只能递增；
- 双向迭代器：可读写；多遍扫描，可递增递减；
- 随机访问迭代器：可读写；多遍扫描，支持全部迭代器运算；
算法还共享了一组参数传递规范和一组命名规范，我们将在介绍迭代器类别之后将介绍这些内容。
### 10.5.1 5类迭代器
类似容器，迭代器也定义了一组公共操作，一些操作所有的迭代器都支持，另外一些只有特定类别的迭代器才支持。例如ostream_iterator只支持递增、解引用和赋值。vector、string和deque的迭代器除了这些操作外，还支持递减、关系和算数运算。
迭代器是按照它们所提供的的操作来分类的，而这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。
C++标准指明了泛型和数值算法每个迭代器参数的最小类别。例如find算法在一个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。replace函数需要一对迭代器，至少是向前迭代器。类似的，replace_copy的前两个迭代器参数也要求至少是向前迭代器。其第三个迭代器表示目的位置，必须最少是输出迭代器。其他的例子类似，对于每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更加的迭代器会产生错误。
**输入迭代器**(input iterator)：可以读取序列中的元素,一个输入迭代器必须支持
- 用于比较两个迭代器相等和不相等运算符(==,!=)
- 用于推进迭代器的前置和后置递增运算(++)
- 用于读取元素的解引用运算符(*)；解引用只会出现在赋值运算符的右侧
- 箭头运算符(->)，等价于(*it).member，即接引用迭代器，并提取对象的成员
输入迭代器只用于顺序访问，对于一个输入迭代器，*it++保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法find和accumulate要求输入迭代器；而istream_iterator是一种输入迭代器。
**输出迭代器**(output iterator):可以看做输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：
- 用于推进迭代器的前置和后置的递增运算(++)
- 解引用运算符(*)，只出现在赋值运算的左侧(向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素)
我们只能向一个输出迭代器赋值一次，类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如copy函数的第三个参数就是输出迭代器。ostream_iterator类型也是输出迭代器。
**前向迭代器**(forward iterator):可以读写元素，这类迭代器只能在序列沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此我们可以保存前向迭代器的状态。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法replace要求前向迭代器，forward_list上的迭代器是前向迭代器。
**双向迭代器**(bidirectional iterator):可以正向/反向读写顺序中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符(--)。算法reverse要求双向迭代器，除了forward_list之外，其他标准库都提供符合双向迭代器要去的迭代器。
**随机访问迭代器**(random-access iterator):提供在常量时间内访问序列中任意元素的能力，此类迭代器支持双向迭代器的所有功能，此外还应该支持：
- 用于比较两个iterator相对位置的关系运算符(<、<=、>=和>)
- 迭代器和一个整数值的加减(+、+=、-和-=)，计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置。
- 用于两个迭代器上的减法运算符(-)，得到两个迭代器的距离
- 下标运算符(iter[n])，与(*iter[n])等价
算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。
### 10.5.2 算法形参模式
在任何算法分类之上，还有一组参数规范。理解这些参数规范对学习新算法很有帮助——通过理解参数的含义，你可以将注意力集中在算法所做的操作上。大多数算法具有如下四种形式之一：
```
alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
```
其中alg是算法的名字，beg和end表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数依赖于要执行的操作。这里列出了最常见的一种——dest、beg2和end2，都是迭代器参数。顾名思义，如果用到了这些迭代器参数，它们分别承担指定目的和第二个范围的角色。除了这些迭代器参数，一些算法还接受额外的、非迭代器的特定参数。
#### 接受单个目标迭代器的算法
dest参数是一个表示算法可以写如的目的位置的迭代器。算法假定(assume)：按其需要写入数据，不管写入多少元素都是安全的。
> warning：向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。
如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的元素内。更常见的情况是，dest被绑定到一个插入迭代器或者是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因而保证空间是足够的。ostream_iterator会将数据写入到一个输出流，同样不管要写入多少元素都没有问题。
#### 接受第二个输入序列的算法
接受单独的beg2或是接受beg2和end2的算法用这些迭代器表示第二个输入范围。这些算法通常使用第二个范围中的元素与第一个输入范围结合来进行一些运算。
如果一个算法接受beg2和end2，这两个迭代器表示第二个范围。这类算法接受两个完整指定的范围：[beg, end)表示的范围和[beg2, end2)表示的第二个范围。
只接受单独的beg2(不接受end2)的算法将beg2作为第二个输入范围中的首元素。此范围的结束位置未指定，这些算法假定从beg2开始的范围与beg和end所表示的范围至少一样大。
> warning：接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。
### 10.5.3 算法命名规范
除了参数规范，算法还需要遵循一套命名和重载规范，这些规范处理注入：如何提供一个操作代替默认的<或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。
#### 一些算法使用重载形式传递一个谓词
接受谓词参数来代替<或==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替<或者==:
```
unique(beg, end);         //使用==运算符比较元素
unique(beg, end, comp);   //使用comp比较元素
```
两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的==运算符来检查重复元素；第二个则调用comp来确定两个元素是否相等。由于两个版本的函数在参数个数上不相等，因此具体应该调用哪个版本都不会产生歧义。
#### _if版本的算法
接受一个元素值的算法通常有另一个不同名（不是重载的）版本，该版本接受一个谓词代替元素。接受谓词参数的算法都有附加_if前缀：
```
find(beg, end, val);      //查找val第一次出现的位置
find_if(beg, end, pred);  //查找第一个令pred为真的元素
```
这两个算法都在输入范围中查找特定元素第一次出现的位置。算法find查找一个指定值，算法find_if查找使得pred返回非零值的元素。
这两个算法提供了命名上的差异的版本，而非重载版本，因为两个版本的算法都接受相同数目的参数。因此可能产生重载歧义，虽然很罕见，但是为了避免任何可能的歧义，标准库选择提供不同名字的版本而不是重载。
#### 区分拷贝元素的版本和不拷贝的版本
默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个copy，例如：
```
reverse(beg, end);              //翻转输入范围中元素顺序
reverse_copy(beg, end, dest);   //将元素按逆序拷贝到dest
```
一些算法同时提供_copy和_if版本，这些版本接受一个目的位置迭代器和一个谓词：
```
remove_if(v1.begin(), v1.end(), [](int i){ return i % 2;}); //从v1中删除奇数元素
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i){ return i % 2; });
```
两个算法都调用了lambda来确定元素是否为奇数。在第一个调用中，我们从输入序列中将奇数元素删除。在第二个调用中，我们将非奇数元素考入到v2中。
## 10.6 特定容器算法
与其它容器不同，链表类型list和forward_list定义了几个成员函数形式的算法。特别是，它们定义了独有的sort、merge、remove、reverse和unique。通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，因为这两个类型分别提供双向迭代器和前向迭代器。
链表类型定义的其他算法的通用版本可以用于链接，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速交换元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。
> Advice：对于list和forward_list，应该优先使用成员函数版本算法而不是通用算法。
#### splice成员
lst.splice(args)或flst.splice_after(args)。p是一个指向lst中元素的迭代器，或者一个指向flst首前位置的迭代器。函数将lst2的所有元素移动到lst中p之前的位置或者flst中p之后的位置。将元素从lst2中删除。lst2的类型必须与lst或者flst相同，且不能是同一个链表。
#### 链表特有的操作会改变容器
多数链表特有的算法都与其同样版本很相似，但不完全相同。这个很容易理解，就是例如merge函数会将合并的序列销毁，来自两个链表中的元素依然存在，但是它们都已经在同一个链表中。

# 第11章 关联容器
关联容器和顺序容器有着根本的不同：关联容器中的元素是按照关键字来保存和访问的。与之相对的是，顺序容器中的元素是按照它们在容器中的位置来顺序保存和访问的。
虽然关联容器很多行为与顺序容器相同，但其不同之处反映了关键字的作用。
两个最主要的**关联容器**类型map和set。map中的元素是一些关键字-值(key-value)对，关键字起到索引的作用，值则表示与索引关联的数据。set中每个元素只包含一个关键字，set支持高校的关键字查询操作——检查一个给定关键字是否在set中。例如在某些文本处理过程中，可以用set来保存想要忽略的单词。字典就是一个很好的map的例子，可以将单词作为关键字，将单词释义作为值。
标准库提供了8个关联容器：
**按关键字有序保存元素**
- map 关联数组：保存关键字-值对
- set 关键字即值，即只保存关键字的容器
- multimap 关键字可重复出现的map
- multiset 关键字可重复出现的set
**无序集合**
- unordered_map 用哈希函数组织的map
- unordered_set 用哈希函数组织的set
- unordered_multimap 哈希组织的map:关键字可以重复出现
- unordered_multiset 哈希组织的set:关键字可以重复出现
这8个容器不同体现在：1）是否为map或者set;2）是否允许重复关键字；3）按顺序或者无序保存。允许重复关键字名字中包含单词multi；不保持关键字按顺序存储的容器名字都以单词unordered开头。因此一个unordered_multi_set是一个允许重复关键字，元素无需保存的集合，而一个set则是一个要求不重复关键字，有序存储的集合。无序容器使用哈希函数来组织元素，我们将在后面介绍关于哈希函数的内容。
类型map和multimap定义在头文件map，set和multiset定义在头文件set中；无序容器则定义在头文件unordered_map和unordered_set中。
## 11.1 使用关联容器
一个景点的使用关联数组的例子是单词计数程序：
```
map<string, size_t> word_count;   //string到size_t的空map
string word;
while (cin >> word)
    ++word_count[word];           //提取word计数器并加1
for (const auto &w : word_count)
    cout << w.first << " occurs " << w.second << ((w.second > 1) ? " times" : " time") << endl;
```
当从map中提取一个元素时，会得到一个pair类型的对象，我们将会在后文介绍它。简单来说pair是一个末班类型，保存了两个名为first和second的(公有)数据成员。map所使用的pair用first成员保存关键字，用second成员保存对应的值。因此，输出语句的效果是打印每个单词及其关联的计数器。
#### 使用set
例如想要忽略一些常见单词，则可以用set保存想忽略的单词，只对不在集合中的单词统计出现次数：
```
map<string, size_t> word_count;
set<string> exclude = {"The", "A", "But", "Or"};
string word;
while (cin >> word)
{
    if (exclude.find(word) == exclude.end())
        ++word_count[word];
}
```
与其它容器类似，set也是模板。为了定义一个set，必须指定其元素类型，本例中是string。
## 11.2 关联容器概述
关联容器不支持顺序容器的位置相关的操作，例如push_back或者push_front，原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。
除了与顺序容器相同的操作外，关联容器还支持一些顺序容器不支持的操作和类型别名。此外无序容器还提供一些用来调整哈希性能的操作。关联容器的迭代器都是**双向的**。
### 11.2.1 定义关联容器
每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。我们可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器所需类型就可以。在新标准下，我们可以对关联容器进行值初始化：
```
map<string, size_t> word_count; //空容器
set<string> exclude = {"the", "but", "and"};
map<string, string> authors = { {"Dickens", "Charles"},
                                {"Austen", "Jane"},
                                {"Joyce", "James"} };
```
#### 初始化multimap或者multiset
一个map或者set中的关键字必须是唯一的，即对于一个给定的关键字，只能由一个元素的关键字等于它。容器multimap和multiset没有此限制，它们都允许多个元素具有关键字。流入在我们用来统计单词数量的map中，每个单词只能有一个元素。另一方面，在一个词典中，一个特定单词则具有多个与之关联的词义。
下面的例子展示了具有唯一关键字的容器与允许重复关键字的容器之间的区别。首先我们创建ivec的保存int的vector，它包含20个元素：0到9每个整数有两个拷贝，我们将使用此vector初始化一个set和一个multiset：
```
vector<int> ivec;
for (vector<int>::size_type i = 0; i != 10; ++i) {
    ivec.push_back(i);
    ivec.push_bakc(i);
}
set<int> iset(ivec.cbegin(), ivec.cend());
multiset<int> miset(ivec.cbegin(), ivec.cend());
cout << ivec.size() << endl;   //打印出20
cout << ivec.size() << endl;   //打印出10
cout << miset.size() << endl;  //打印出20
```
### 11.2.2 关键字类型的要求
关联容器对关键字类型有一定的限制。对于无序容器中关键字的要求后文会介绍。对于有序容器——map/multimap/set/multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型，因此11.2节中word_count的关键字类型是string，exclude的也是。
#### 有序容器的关键字类型
可以向一个算法提供我们定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的<运算符。所提供的操作必须在关键字类型上定义一个**严格弱序**。可以将严格弱序看做小于等于，虽然实际定义的操作可能是一个复杂的函数，但是无论我们怎样定义比较函数，它必须具备如下基本形式：
- 两个关键字不能同时“小于等于”对方；如果k1“小于等于”k2，那么k2绝不能“小于等于”k1。
- 如果k1"小于等于"k2,且k2"小于等于"k3,那么k1必须小于k3.
- 如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1等价于k2，且k2等价于k3，那么k1必须等价于k3;
如果两个关键字时等价的，那么容器将它们视作相等处理。当用作map的关键字时，只能有一个元素与这两个关键字关联，我们可以用两者中任意一个访问对应的值。
> 在实际编程中，重要的是如果一个类型定义了“行为正常”的<运算符，则它可以用作关键字类型
#### 使用关键字类型的比较函数
用来组织一个容器中的元素的操作类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。
在尖括号中出现的每个类型，就仅仅是一个类型而已。**当我们创建一个容器(对象)时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）**。
例如，我们不能直接定义一个Sales_data的multiset，因为Sales_data没有<运算符。但是可以compareIsbn函数来定义一个multiset。次函数在Sales_data对象的ISBN成员上定义了一个严格弱序。函数compareIsbn应该像下面定义：
```
bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)
{
    return lsh.isbn() < rhs.isbn();
}
```
为了使用自己定义的操作，在定义multiset时我们必须提供两个类型：关键字类型Sales_data，以及比较操作类型——应该是一种函数指针类型，可以指向compareIsbn，当定义此容器类型的对象时，需要提供想要使用的操作的指针。在本例中，我们提供一个指向compareIsbn的指针：
```
//bookstore中多条记录可以有相同的ISBN
//bookstore中元素以ISBN的顺序进行排列
multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);
```
此处，我们使用decltype来指出自定义自定义操作的类型，记住，**当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一给定函数类型的指针**。用compareIsbn来初始化bookstore对象，这表示当我们向bookstore添加元素时，通过调用compareIsbn为这些元素排序，可以用compareIsbn代替&compareIsbn作为构造函数的参数，因为当我们使用一个函数的名字时，在需要的情况下它会自动转化为一个指针。当然，使用&compareIsbn的效果是一样的。
### 11.2.3 pair类型
在介绍关联容器操作之前，我们需要了解名为pair的标准库类型，它定义在头文件utility中。
一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型，两个类型不要求一样：
```
pair<string, string> anon;
pair<string, size_t> word_count;
pair<string, vector<int>>  line;
```
pair的默认构造函数对数据成员进行值初始化，当然我们还可以为每个成员提供初始化器：
```
pair<string, string> author { "James", "Joyce"};
```
与其它标准库不同，pair的数据成员是public的，两个成员分别命名为first和second。我们用普通的成员访问它们就可以。
pair提供的几个操作很有限，除了上面调用first、second之外，就只有make_pair(v1, v2)来构建一个pair，类型从v1，v2自动推断而来。
#### 创建pair对象的函数
想象有一个函数需要返回一个pair，在新标准下，我们可以对返回值进行列表初始化
```
pair<string, int> process(vector<string> &v)
{
    //处理v
    if (!v.empty())
        return {v.back(), v.back().size()};    //列表初始化
    else
        return pair<string, int>();            //隐式构造返回值
}
```
早期的C++中因为不接受花括号的初始化方式，所以必须显式的构造返回值：
```
if (!v.empty())
    return pair<string, int>(v.back(), v.back().size());
```
或者使用make_pair来显式构造：
```
if (!v.empty())
    return make_pair(v.back(), v.back().size());
```
## 11.3 关联容器操作
除了列出的类型，关联容器还定义了以下类型别名：
- key_type       此容器类型的关键字类型
- mapped_type    每个关键字关联的类型；只适用于map
- value_type     对于set,与key_type相同；对于map，为pair<const key_type, mapped_type>，这一点有一些特殊
```
set<string>::value_type v1;   //v1是一个string
set<string>::key_type   v2;   //v2是一个string
map<string, int>::value_type  v3;    //v3是一个pair<const string, int>，这一点要注意
map<string, int>::key_type    v4;    //v4是一个string
map<string, int>::mapped_type v5;    //v5是一个int
```
### 11.3.1 关联容器迭代器
当解引用一个关联容器迭代器，我们会得到一个类型为value_type的值的引用。对map而言，value_type是一个pair类型，其first成员保存const关键字，second成员保存值：
```
auto map_it = word_count.begin();   //获得指向word_count中一个元素的迭代器
//*map_it是指向一个pair<const string, size_t>对象的引用
cout << map_it->first;              //打印此元素的关键字
cout << " " << map_it->second;      //打印此元素的值
map_it->first = "new key";          //错误：关键字是const的
++map_it->second;                   //正确
```
> Note:简单来说就是必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但是不能改变关键字成员的值。
#### set的迭代器是const的
虽然set类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但是不能修改：
```
set<int> iset = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
set<int>::iterator set_it = iset.begin();
if (set_it != iset.end()) {
    *set_it = 42;             //错误：set中的关键字时只读的
    cout << *set_it << endl;  //正确：可以读关键字
}
```
#### 遍历关联容器
map和set类型都支持begin和end操作。与往常一样，我们可以用这些函数获取迭代器，然后用迭代器来遍历容器。例如，我们可以编写一个循环来打印先前单词计数程序的结果：
```
auto map_it = word_count.cbegin();
while (map_it != word_count.cend()) {
    cout << map_it->first  << " occurs"
         << map_it->second << " times" << endl;
    ++map_it;
}
```
#### 关联容器和算法
我们通常不用关联容器使用泛型算法。关键字是const这一特性意味着不能将关联容器传递给修改或者重排容器元素的算法，因为这类算法需要向元素写入值，而set类型中的元素是const的，map中的元素是pair，但是第一个成员是const的。
关联容器可用于只读取元素的算法。但是很多这类算法都要搜索序列，由于关联容器中的元素不能通过它们的关键字进行（快速）查找，因此对其使用泛型搜索算法几乎总是坏主意。例如关联容器的定义了一个名为find的成员，它通过一个给定的关键字直接获取元素。我们可以用泛型的find算法来寻找一个元素，但是此算法会进行顺序搜索。使用关联容器定义的专用的find成员会比调用find快得多。
在实际编程中，如果我们真要对一个关联容器使用算法，要么是将它作为一个源序列，要么当做一个目的位置。例如可以用泛型copy算法将元素从一个关联容器拷贝到另一个序列。类似的，可以调用inserter将一个插入器绑定到一个关联容器。通过使用inserter，我们可以将关联容器当做一个目的位置来调用另一个算法。
### 11.3.2 添加元素
关联容器的insert成员向容器添加一个元素或一个元素范围。由于map和set包含不重复的关键字，因此插入一个已存在的元素对容器没有影响：
```
vector<int> ivec = {2, 4, 6, 7, 2, 4, 6, 8};
set<int> set2;
set2.insert(ivec.cbegin(), ivec.cend());  //set2有4个元素
set2.insert({1, 3, 5, 7, 1, 3, 5, 7});    //set2现在有8个元素
```
insert有两个版本，分别接受一对迭代器，或是一个初始化器列表，这两个版本的行为类似对应的构造函数——对于一个给定的关键字，只有第一个带此关键字的元素才会被插入到容器中。
#### 向map添加元素
对一个map进行insert操作时，必须记住元素类型是一个pair:
```
word_count.insert({word, 1});
word_count.insert(make_pair(word, 1));
word_count.insert(pair<string, size_t>(word, 1));
word_count.insert(map<string, size_t>::value_type(word, 1));
```
#### 检测insert的返回值
insert(或emplace)返回的值依赖于容器类型和参数，对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功。pair和first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则insert什么事情也不做，且返回值中的bool部分为false。如果关键字不存在，元素被插入容器中，且bool值为true。
我们就可以重写单词计数函数：
```
//统计每个单词在输入中出现次数的一种更繁琐的方法
map<string, size_t> word_count;    //从string到size_t的空map
string word;
while (cin >> word) {
    //插入一个元素，关键字等于word，值为1
    //若word已在word_count中，insert什么也不做
    auto ret = word_count.insert({word, 1});
    if (!ret.second)          //word已在word_count中
        ++ret.first->second;  //递增计数器
}
```
最难理解的``++((ret.first)->second)``,加上括号可以更好理解一些。当然，如果采用老版本的编译器，ret写起来就有点麻烦：
```
pair<map<string, size_t>::iterator, bool> ret = word_count.insert(make_pair(word, 1));
```
#### 向multiset或multimap添加元素
我们单词计数程序依赖这样一个事实：一个给定的关键字只能出现一次。这样任意给定的单词只有一个关联的计数器，我们有时候希望能够添加具有相同关键字的多个元素。例如可能想建立作者到他所著书籍题目的映射。在此情况下，每个作者可能有多个条目，因此我们应该使用multimap而不是map。由于一个multi容器中的关键字不必唯一，在这些类型上调用insert总会插入一个元素：
```
multimap<string, string> authors;
authors.insert({"Barth, John", "Sot-Weed Factor"});
authors.insert({"Barth, John", "Lost in the Funhouse"});
```
对允许重复关键字的容器，接受单个元素的insert操作返回一个指向一个指向新元素的迭代器。这里无须返回一个bool值，因为insert总是向这类容器中加入一个新元素。

### 11.3.3 删除元素
关联容器定义了三个版本三个版本的erase。与顺序容器一样，我们可以通过传递给erase一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。这两个版本的erase与对应的顺序容器的操作非常相似：指定的元素被删除，函数返回void。
关联容器提供一个额外的erase操作，它接受一个key_type参数。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。我们可以用词版本在打印结果之前从word_count中删除一个特定的单词：
```
//删除一个关键字，返回删除的元素数量
if (word_count.erase(removal_word))
    cout << "ok: " << removal_word << "removed\n";
else
    cout << "oops: " << removal_word << " not found!\n";
```
对于保存不重复关键字的容器，erase的返回值总是0和1。若返回值为0，则表明要删除的元素并不在容器中，对于允许重复关键字的容器，删除元素的数量可能大于1：
```
auto cnt = authors.erase("Barth, John");  //cnt = 2
```
map和unordered_map容器提供了下标运算符和一个对应的at函数，set类型不支持下标，因为set中没有与关键字相连的“值”，元素本身就是关键字，因此，获取一个与关键字相关联的值的操作就没有意义了。我们不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字关联。
类似我们用过的其他下标运算符，map下标运算符接受一个索引来获取与此关键字相关联的值。但是与其他下标运算符不同的是，如果关键字并不在map中，会为它创建一个元素并插入到map中，关联至将进行值初始化。
例如，如果我们编写如下代码：
```
map<string, size_t> word_count;
word_count["Anna"] = 1;
```
就会一口气插入一个"Anna"并且将值1赋予它。
#### 使用下标操作的返回值
map的下标运算符与我们用过其他的下标运算符的拎一个不同之处是其返回类型。通常情况，解引用一个迭代器所返回的类型与下标运算符返回的类型是一样的。但是对map有点不同，当对一个map进行下标操作时，会获得一个mapped_type对象；但当解引用一个map迭代器，会得到一个value_type对象。
与其它下标运算符相同的是，map的下标运算符返回一个左值。由于是返回一个左值，所以我们既可以读也可以写元素：
```
cout << word_count["Anna"];  //用Anna作为下标提取元素,会打印出1
++word_count["Anna"];        //提取元素，将其增1
cout << word_count["Anna"];  //提取元素并打印它，会打印出2
```
如果有时候只是想知道一个元素是否已在map中，但在不存在时不想添加元素，在这种情况下，就不能使用下标运算符。
### 11.3.5 访问元素
访问元素有很多方法：
- c.find(k)    返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器；
- c.count(k)   返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远0或1
- c.lower_bound(k)   返回一个迭代器，指向第一个关键字不小于k的元素
- c.upper_bound(k)   返回一个迭代器，指向第一个关键字大于k的元素
- c.equal_range(k)   返回一个迭代器pair，表示关键字等于k的元素范围，若k不存在，则pair的两个成员均等于c.end()
#### 在multimap或者multiset中查找元素
在一个不允许重复关键字的关联容器中查找一个元素是一件很容易的事情。但是对于允许重复关键字的容器来说，这种过程更为复杂：在容器中可能有很多元素具有给定的关键字。如果一个multimap或者multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。
例如，给定一个从作者到著作题目的映射，我们可能想打印一个特定作者的所有著作。可以用三种不同方法来解决这个问题。最直观的方法是使用find和count:
```
string search_item("Alain de Botton");
auto entries = authors.count(search_item);
auto iter = authors.find(search_item);
while(entries) {
    cout << iter->second << endl;l
    ++iter;
    --entries;
}
```
首先调用count确定此作者共有多少本著作，并调用find获得一个迭代器，指向第一个关键字为此作者的元素。for循环的迭代次数依赖于count的返回值。特别是如果count返回0，则循环一次也不执行。
#### 一种不同的，面向迭代器的解决方法
我们可以用lower_bound和upper_bound来解决此问题。这两个惭怍都会接受一个关键字，返回一个迭代器。如果关键字在容器中，lower_bound返回的迭代器将指向第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配给关键字的元素之后的位置。如果元素不在multimap中，则lower_bound和upper_bound会返回相等的迭代器——指向一个不影响排序的关键字插入位置。
> lower_bound返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向。如果关键字不在容器中，**则lower_bound会返回关键字的第一个安全插入点——不影响容器中元素顺序的插入位置**。
使用这两个操作，我们可以重写前面的程序：
```
for (auto beg = authors.lower_bound(search_item),
          end = authors.upper_bound(search_item);
     beg != end; ++beg)
     cout << beg->second << endl;  //打印每个题目
```
#### equal_range函数
这个方法是最干脆的，直接调用equal_range即可，它接受一个关键字，然后返回一个迭代器pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的元素。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。程序最终写成：
```
for(auto pos = authors.equal_range(search_item);
    pos.first != pos.second;
    ++pos.first)
    cout << pos.first->second << endl;
```
### 11.3.6 一个单词转换的map
这里给出一个程序，它会展示map的创建、搜索和遍历。其功能是给定一个string，将它转换为另一个string。程序输入的是两个文件，第一个文件保存的是一些规则，用来转换第二个文件中的文本。每条规则由两部分组成：一个可能出现在输入文件中的单词和一个用来替换它的短语。表达的含义是，每当第一个单词出现在输入中，我们就将它替换为对应的短语。表达的含义是，每当第一个单词出现在输入中，我们就将它替换为对应的短语。第二个输入文件包含要转换的问题。
#### 单词转换程序
我们程序将使用是那个函数。函数word_transform管理整个过程。它接受两个ifstream参数：第一个参数应绑定到单词转换文件，第二个参数应绑定到我们要转换的文本文件。函数buildMap会读取转换规则文件，并创建一个map，用于保存每个单词到其转换内容的映射。函数transform接受一个string，如果存在转换规则，返回转换后的内容。
我们首先定义word_transform函数，最重要的就是调用buildMap和tansform：
```
void word_transform(ifstream &map_file, ifstream &input)
{
    auto trans_map = buildMap(map_file);   //保存转换规则
    string text;
    while (getline(input, text)) {
        istringstream stream(text);        //读取每个单词
        string word;
        bool firstword = true;             //控制是否打印空格
        while (stream >> word) {
            if (firstword)
                firstword = false;
            else
                cout << " ";
            cout << transform(word, trans_map);
        }
        cout << endl;                      //完成一行的转换
    }
}
```
#### 建立转换映射
函数buildMap读入给定文件，建立起映射转换：
```
map<string, string> buildMap(fistream &map_file)
{
    map<string, string> trans_map;  //保存转换规则
    string key;     //要转换的单词
    string value;   //替换后的内容
    while (map_file >> key && getline(map_file, value))  //读取第一个单词到key中，行中剩余内容存入value
    {
       if (value.size() > 1)
            tans_map[key] = value.substr(1);  //跳过前导空格
        else
            throw runtime_error("no rule for " + key);
    }
    return trans_map;
}
```
注意的是，如果同一个键值出现次数多于一次，那么会出现该键值的**最后一次插入值替代先前值**的情况。
#### 生成转换文本
```
const string& transform(const string &s, const map<string, string> &m)
{
    auto map_it = m.find(s);
    if (map_it != m.cend())
        return map_it->second;  //返回替换内容
    else
        return s;  //返回原string
}
```

## 11.4 无序容器
新标准定义了4个无序关联容器，这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字==运算符。在关键字类型的元素没有明显的序关系下，无序容器是非常有用的。在某些应用中，维护元素的序代价特别高昂，此时无序容器也非常有用。
虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到很好的效果还需要进行一些性能测试和调优工作。因此，使用无序容器通常更为简单（通常会有更好的性能）。
> Tip：如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器。
#### 使用无序容器
除了哈希管理之外，无序容器还提供了与有序容器相同的操作(find、insert等)。这意味着我们曾用于map和set的操作也能用于unordered_map和unordered_set。类似的，无序容器也有允许重复关键字的版本。
因此，通常可以用一个无序容器替换对应的有序容器，反之亦然。但是由于元素未按照顺序存储。一个使用无序容器的程序的输出(通常)会与使用有序容器的版本不同。
例如，可以用unordered_map重写最初的单词计数程序：
```
unordered_map<string, size_t> word_count;
string word;
while (cin >> word)
    ++word_count[word];
for (const auto &w : word_count)
    cout << w.first << " occours " << w.second << ((w.second > 1) ? " times": " time" ) << endl;
```
和原程序相比，我们将会得到相同的技术结果，但是唯一不同的是**单词不太可能按照字典序输出**。
#### 管理桶
无序容器在存储上组织为一组桶，每个桶保存零个或者多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该所搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中，如果容器允许重复关键字，所有具有相同关键字的元素也都会在一个桶中。因此无序容器的性能依赖于哈希函数的质量和桶的数量和大小。
对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量的比较操作。
无需容器提供了一系列桶的操作，可以查询表11.8。
#### 无序容器对关键字的要求
默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板，还为一些标准库类型，包括stirng和我们要在第12章介绍的智能指针类型定义了hash。因此我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针类型的无序容器。
但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本，我们将在放后面介绍如何做到这一点。
我们不使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作。为了能将Sale_data用作关键字，我们需要提供函数来替代==运算符和哈希值计算函数，我们从定义这些重载函数开始：
```
size_t hasher(const Sales_data &sd)
{
    return hash<string>()(sd.isbn());
}
bool eqOp(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn();
}
```
我们的hasher函数使用一个标准库hash类型对象来计算ISBN成员的哈希值，该hash类型建立在string类型之上。类似的，eqOp函数通过比较ISBN号来比较两个Sales_data。
我们使用这些函数来定义一个unordered_multiset：
```
using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;
//参数是桶大小、哈希函数和相等性判断运算符指针
SD_multiset bookstore(42, hasher, eqOp);
```
为了简化bookstore的定义，首先为unordered_multiset定义了一个类型别名，此集合的哈希和相等性判断与hasher和eqOp函数有着相同的类型。通过使用这种类型，在定义bookstore时可以将我们希望它使用的函数的指针传递给它。
如果我们的类定义了==运算符，则可以只重载哈希函数：
```
//使用FooHash生成哈希值；Foo必须有==运算符
unordered_set<Foo, decltype(FooHash)*> fooSet(10, FooHash);
```

# 第12章 动态内存
到目前为止，我们编写的程序中所使用的对象都有着严格定义的生存期。全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。局部static对象在第一次使用时分配，在程序结束时销毁。
除了自动和static对象外，C++还支持动态分配对象，动态分配的对象生存期与它们在哪里创建是无关的，只有当显式的被释放时，这些对象才会销毁。
动态对象的正确释放被证明是编程中及其容易出错的地方，为了更安全的使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象，当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。
我们目前为止只使用过静态或栈内存。静态内存用来保存局部static对象、类static数据成员以及定义在函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或者栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。
除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作为**自由空间(free store)**或者**堆（heap）**。程序用堆来存储**动态分配(dynamically allocate)**的对象——即那些在程序运行时分配的对象。即那些程序在运行时分配的对象，动态对象的生存周期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式的销毁它们。
## 12.1 动态内存与智能指针
在C++中，动态内存的管理是通过一对运算符来完成的：new,在动态内存中为对象分配并且返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。
为了更容易也更安全的使用动态内存，新的标准库提供了两种智能指针，它的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针区别在于管理底层指针的方式：shared_ptr允许多个指针向同一个对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。
### 12.1.1 shared_ptr类
类似vector，智能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。与vector一样，我们在尖括号内给出类型后，之后是所定义的这种智能指针的名字：
```
shared_ptr<string> p1;     //可以指向string
shared_ptr<list<int>> p2;  //可以指向int的list
```
默认初始化的智能指针中保存着一个空指针，后文会介绍初始化智能指针的其他方法。
智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：
```
if (p1 && p1->empty())
    *p1 = "h1";   //如果p1指向一个空string，解引用p1，将一个新值赋予string
```
下面列出了shared_ptr和unique_ptr都支持的操作：
- shared_ptr<T> sp或 unique_ptr<T> up 空智能指针，可以指向类型为T的对象
- p 将p用作一个条件判断，若p指向一个对象，则为true
- *p 解引用p，获得它指向的对象
- p->mem 等价于(*p).mem
- p.get() 返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象所指向的对象也就消失了
- swap(p, q)或p.swap(q) 交换p和q中的指针
以下为shared_ptr独有的操作：
- make_shared<T>(args)  返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化此对象
- shared_ptr<T>p(q)  p是shared_ptr q的拷贝：此操作会递增q中的计数器，q中的指针必须能转换为T*
- p = q p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放
- p.unique() 若p.use_count()为1，返回true；否则返回false
- p.use_count() 返回与p共享对象的智能指针数量；可能很慢，主要用于调试
#### make_shared函数
最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数，此函数在动态内存中分配一个对象并且初始化它。返回此对象的shared_ptr。与智能指针一样，make_shared也定义在头文件memory中。
当使用make_shared时，必须指定要创建的对象类型。定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型：
```
shared_ptr<int> p3 = make_shared<int>(42);   //指向一个值为42的int的shared_ptr
shared_ptr<string> p4 = make_shared<string>(10, '9');  //p4指向一个10个9练起来的string
shared_ptr<int> p5 = make_shared<int>();  //p5指向一个值初始化的int，即值为0
```
类似顺序容器的emplace成员，make_shared用其参数来构造给定类型的对象。例如，调用make_shared<string>时传递的参数必须与string的某个构造函数相匹配，调用make_shared<int>时传递的参数必须能用来初始化第一个int。以此类推，如果不传递任何参数，就会进行值初始化（默认初始化）；
当然，我们通常auto定义一个对象来保存make_shared的结果，这种方式较为简单：
```
auto p6 = make_shared<vector<string>>();  //p6指向一个动态分配的空vector<string>
```
#### shared_ptr的拷贝和赋值
当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：
```
auto p = make_shared<int>(42);  //p指向的对象只有p一个引用者
auto q(p);  //p和q指向相同对象，此对象有两个引用者
```
我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为**引用计数(reference count)**。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为**参数传递给一个函数以及作为函数的返回值**时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或者shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减。
一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象：
```
auto r = make_shared<int>(42);  //r指向的int只有一个引用者
r = q;  //给r赋值，令他指向另一个地址
        //递增q指向的对象的引用计数
        //递减r原来指向的对象的引用计数
        //r原来指向的对象已没有引用者，会自动释放
```
此例中我们分配了一个int，将其指针保存在r中。接下来，我们将一个新值赋予r。在此情况下，r是唯一指向此int的shared_ptr，在把q赋给r的过程中，此int被自动释放。
> Note：到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。
#### shared_ptr自动销毁所管理的对象……
当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过另一个特殊的成员函数——**析构函数(detructor)**完成销毁工作。类似于构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。
析构函数一般用来释放对象所分配的资源。例如，string的构造函数(以及其他string成员)会分配内存来保存构成string的字符。string的析构函数就负责释放这些内存。类似的，vector的若干操作都会分配内存来保存其元素。vector的析构函数就会负责销毁这些元素，并且释放他们所占用的内存。
shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会小慧对象，并释放它占用的内存。
#### ……shared_ptr还会自动释放相关联的内存
当动态对象不再被使用时，shared_ptr类会自动释放对象，这一特性使得动态内存的使用变得非常容器。例如，我们可能有一个函数返回一个shared_ptr，指向一个Foo类型的动态分配的对象，对象是通过一个类型为T的参数进行初始化的：
```
shared_ptr<Foo> factory(T arg)
{
    //恰当的处理arg
    //shared_ptr负责释放内存
    return make_shared<Foo>(arg);
}
```
由于factory返回一个shared_ptr，所以我们可以确保它分配的对象会在恰当的时候被释放。例如下面的函数将factory返回的shared_ptr保存在局部变量中：
```
void use_factory(T arg)
{
    shared_ptr<Foo> p = factory(arg);
    //使用p

}//p离开了作用域，它指向的内存会被自动释放掉
```
由于p是use_factory的局部变量，在use_factory结束时它将会被销毁。当p被销毁时，将递减其引用计数并检查起它是否为0。在此例中，p是唯一引用factory返回的内存的对象。由于p要销毁，p指向的这个对象也会销毁，所占用的内存均能会被释放。
但如果有其他的shared_ptr也指向这块内存，它就不会被释放掉：
```
void use_factory(T arg)
{
    shared_ptr<Foo> p = factory(arg);
    //使用p
    return p;  //当我们返回p时，引用计数进行了递增操作
} //p离开了作用域，但它指向的内存不会被释放掉
```
在此版本中，use_factory中的return语句向此函数的调用者返回一个p的拷贝。拷贝一个shared_ptr会增加所管理对象的引用计数值。现在当p被销毁时，它所指向的内存还有其他使用者。对于一块内存，shared_ptr类保证只要有任何shared_ptr对象引用它，它就不会被释放掉。
由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会争取执行，但是会浪费内存。shared_ptr在无用之后仍然保留的一个种情况可能是，你将shared_ptr存放在一个容器中。随后重排了容器，从而不再需要某些元素。这种情况下，使用者应该用erase删除那些不再需要的shared_ptr元素。
> 如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得使用erase删除不再需要的那些元素。
> 如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。
#### 使用了动态生存期的类
程序使用动态内存出于以下三种原因之一：
1. 程序不知道自己需要使用多少对象；
2. 程序不知道所需对象的准确类型；
3. 程序需要在多个对象间共享数据；
容器类是出于第一种原因而使用动态内存的典型类似，我们将在第15章看到出于第二种原因而是用动态内存的例子。在本节中，我们将定义一个类，它侍弄动态内存是为了让多个对象能共享相同的底层数据。
到目前为止，我们使用的类中，分配的资源都与对应对象生存期一致。例如，每个vector拥有其自己的元素。当我们拷贝一个vector时，原vector和副本vector中的元素是相互分离的：
```
vector<string> v1;
{
    //新作用域
    vector<string> v2 = {"a", "an", "the"};
    v1 = v2;   //从v2拷贝元素到v1中
} //v2被销毁，其中的元素也被销毁
  //v1有三个元素，是原来v2中元素的拷贝
```
由一个vector分配的元素只有当这个vector存在时才存在。当一个vector被销毁时，这个vector中的元素也被销毁。
但是某些类分配的资源具有与元件对象相独立的生存期。例如假定我们希望定义一个名为Blob的类，宝UC那一组元素。与容器不同，我们希望Blob对象的不同拷贝之间共享相同的元素。即当我们拷贝一个Blob时，原Blob对象及其拷贝应该引用相同的底层元素。
一般而言，如果两个对象共享底层数据，如果某个对象被销毁时，我们不能单方面地销毁底层数据：
```
Blob<string> b1;
{
    Blob<string> b2 = {"a", "an", "the"};
    b1 = b2;  //b1和b2共享相同的元素
}   //b2被销毁了，但b2中元素不能被销毁
    //b1指向最初由b2创建的元素
```
在此例中，b1和b2共享相同的元素。当b2离开作用域时，这些元素必须保留，因为b1仍然在使用它们。
> 使用动态内存的一个常见的原因是允许多个对象共享相同的状态。
#### 定义StrBlob
最终，我们会将Blob类实现一个模板，但是后文才会介绍模板的相关内容。因此，现在我们先定义管理string的类，此版本命名为StrBlob。
实现一个新的集合类型最好的方法是使用某个标准库容器来管理元素，采用这种方法，我们可以借助标准库类型来管理元素所使用的内存空间。在本例中，我们将使用vector来保存元素。
但是我们不能在一个Blob对象内直接保存vector，因为一个对象的成员在对象销毁时也会销毁。例如，假定b1和b2是两个Blob对象，共享相同的vector。如果此vector保存在其中一个Blob中——例如b2中，那么当b2离开作用域时，此vector也将被销毁，也就是说其中的元素都将不复存在。为了保证vector中的元素继续存在，我们将vector保存在动态内存中。
为了实现我们所希望的数据共享，我们为每个StrBlob设置一个shared_ptr来管理动态分配的vector。此shared_ptr的成员将记录会有多少个StrBlob共享相同的vector，并在最后一个使用者被销毁时释放vector。
我们还需要确定这个类应该提供什么操作。当前，我们将实现一个vector操作的小子集。我们会修改访问元素的操作（例如front和back），在我们的类中，如果用户试图访问不存在的元素，那么这些操作会抛出一个异常。
我们的类有一个默认构造函数和一个构造函数，接受单一的initializer_list<string>类型参数。此构造函数可以接受一个初始化器的花括号参数：
```
class StrBlob {
public:
    typedef std::vector<std::string>::size_type size_type;
    StrBlob();
    StrBlob(std::initializer_list<std::string> il);
    size_type size() const { return data->size();}
    bool empty() const { return data->empty();}

    //添加和删除元素
    void push_back(const std::string &t) { data->push_back(t);}
    void pop_back();
    //元素访问
    std::string& front();
    std::string& back();
private:
    std::shared_ptr<std::vector<std::string>> data;
    //如果data[i]不合法，抛出一个异常
    void check(size_type i, const std::string &msg) const;
}
```
#### StrBlob构造函数
两个构造函数都是用初始化列表来初始化其data成员，令它指向一个动态分配的vector。默认构造函数分配一个空vector:
```
StrBlob::StrBlob() : data(make_shared<vector<string>>()) {}
StrBlob::StrBlob(initializer_list<string> il) : data(make_shared<vector<string>>) {}
```
接受一个initializer_list的构造函数将其参数传递给对应的vector构造函数。此构造函数通过拷贝列表中的值来初始化vector的元素。
#### 元素访问成员函数
pop_back、front和back操作访问vector中的元素。这些操作在试图访问元素之前必须检查元素是否存在。由于这些成员函数需要做相同的检查操作，我们为StrBlob定义了一个名为check的private工具函数，它检查一个给定索引是否在合法范围内。除了索引，check还接受一个string参数，它会将此参数传递给异常处理程序，这个string描述了错误内容：
```
void StrBlob::check(size_type i, const string &msg) const
{
    if (i >= data->size())
        throw out_of_range(msg);
}
```
pop_back和元素访问成员函数首先调用check。如果check成功，这些成员函数继续利用底层vector的操作来完成自己的工作：
```
string& StrBlob::front()
{
    check(0, "front on empty StrBlob");
    return data->front();
}
string& StrBlob::back()
{
    check(0, "back on empty StrBlob");
    return data->back();
}
void StrBlob::pop_back()
{
    check(0, "pop_back on empty StrBlob");
    data->pop_back();
}
```
front和back应该对const进行重载，这些版本的定义留作练习。
#### StrBlob的拷贝、赋值和销毁
类似Sales_data类，StrBlob使用默认版本的拷贝、赋值和销毁成员函数来对此类型的对象进行这些操作。默认情况下，这些操作拷贝、赋值和销毁类的数据成员。我们的StrBlob类只有一个数据成员，它是shared_ptr类型。因此，当我们拷贝、赋值或销毁一个StrBlob对象时，它的shared_ptr成员会被拷贝、赋值和销毁。
如前所见，拷贝一个shared_ptr会递增其引用计数；将一个shared_ptr赋予另一个shared_ptr会递增赋值号右侧shared_ptr的引用计数，而递减左侧shared_ptr的引用计数。如果一个shared_ptr的引用计数变为0，它所指向的对象会被自动销毁。因此，对于由StrBlob构造函数分配的vector，当最后一个指向它的StrBlob对象被销毁时，它会随之自动销毁。
#### 12.1.2 直接管理内存
C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存，delete释放new分配的内存。
相对于智能指针，使用这两个运算符管理内存非常容易出错，并且，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容器编写和调试。
#### 使用new动态分配和初始化
在自由空间分配的内存是无名的，因此**new**无法为其分配的对象命名，而是返回一个指向该对象的指针：
```
int *pi = new int; //pi指向一个动态分配、未初始化的五名对象
```
此new表达式在自由空间构造一个int型对象，并返回该对象的指针。
默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或者组合类型的对象的值是未定义的，而类类型对象将用默认构造函数进行初始化：
```
string *ps = new string;   //初始化空string
int *pi = new int;         //pi指向一位置初始化的int
```
我们可以使用直接初始化方式，既可以用老标准（圆括号）或者新标准（花括号列表初始化）：
```
int *pi = new int(1024);
string *ps = new string(10, '9');
vector<int> *pv = new vector<int>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
```
也可以对动态分配的对象进行值初始化，只需要在类型名之后跟一对空括号即可：
```
string *ps1 = new string;     //默认初始化为空string
string *ps = new string();    //值初始化为空string
int *pil1 = new int;          //默认初始化；*pil1的值未定义
int *pil2 = new int();        //值初始化为0；*pi2为0
```
对于定义了自己的构造函数的类类型，要求值初始化意义不大。不管采用什么形式，对象都会通过默认构造函数来初始化。但是对于内置类型，两种形式差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中哪些依赖于编译器合成的默认构造函数的内置类型，如果它们未在类内被初始化，那么它们的值也是未定义的。
如果我们提供了一个括号包围的初始化器，既可以使用auto从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号仅有单一初始化器时才可以使用auto：
```
auto p1 = new auto(obj);      //p指向一个与obj类型相同的对象
                              //该对象用obj进行初始化
auto p2 = new auto{a, b, c};  //错误：括号中只能有单个初始化器
```
p1的类型是一个指针，指向从obj自动推断出的类型。若obj是一个int，那么p1就是int*;若obj是一个string，那么p1是一个string*;依次类推。新分配的对象obj的值进行初始化。
#### 动态分配的const对象
用new分配const对象是合法的：
```
const int *pci = new cosnt int(1024);  //分配并初始化一个const int
const string *pcs = new const string;
```
类似其他任何const对象，一个动态分配的const对象必须进行初始化。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是const的，new返回的指针是一个指向const的指针。
#### 内存耗尽
虽然现代计算机痘通常配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。一单一个程序用光了所有的它可用的内存，new表达式就会失败。默认情况，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：
```
//如果分配失败，new返回一个空指针
int *p1 = new int;               //如果分配失败，new抛出std::bad_alloc
int *p2 = new (nothrow) int;     //如果分配失败，new返回一个空指针
```
我们称这种形式的new为**定位new**(placement new)。其原因我们将在后面解释。定位new表达式允许我们向new传递额外的参数。在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们意图是告诉它不能跑出异常。如果这种形式的new不能分配所需的内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。
#### 释放动态内存
为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式来将动态内存归还给系统。delete表达式接受一个指针，来指向我们想要释放的对象：
```
delete p;   //p必须指向一个动态内存分配的对象或是一个空指针
```
与new类型类似，delete表达式也执行两个动作：销毁给定的指针指向的对象；同时释放对应的内存；
#### 指针值和delete
我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的：
```
int i, *pil = &i, *pi2 = nullptr;
double *pd = new double(33), *pd2 = pd;
delete i;     //错误：i不是一个指针
delete pi1;   //未定义：pi1指向一个局部变量
delete pd;    //正确
delete pd2;   //未定义：pd2指向的内存已经被释放了
delete pi2;   //正确：释放一个空指针没有错误（这就是为什么要求每次使用delete总要后面赋值为nullptr）
```
除了第一种错误，i是非指针，编译器可以进行区分并且进行正确的报错，其他情况编译器都会通过，尽管它们是错误的。
虽然一个const对象值不能被改变，但是它本身是可以被销毁的。如果任何其他的动态对象一样，想要释放一个const动态对象，只要delete指向它的指针即可：
```
const int *pci = new const int(1024);
delete pci;   //正确：释放一个const对象
```
#### 动态对象的生存期知道被释放为止
如前文所述，由shared_ptr管理的内存在最后一个shared_ptr销毁时会自动被释放。但对于通过内置指针类型来管理的内存，就不是这样了。对于一个由内置指针管理的动态对象，知道被显式释放之前它都是存在的。
返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存：
```
//factory返回一个指针，指向一个动态分配的对象
Foo* factory(T arg)
{
    return new Foo(arg);  //调用者负责释放此内存
}
```
类似我们之前定义的factory函数，这个版本的factory分配一个对象，但是并不会去delete它。factory的调用者负责在不需要它的时候释放它。不幸的是，调用者经常弯忘记释放对象……
##### 小心：动态内存的管理非常容器出错
使用new和delete管理动态内存存在三个常见问题：
1. 忘记delete内存。月就是传说中的“内存泄漏”。一般很难检查，只有在内存完全耗尽时才能检查到这种错误。
2. 使用已释放的对象。通过在释放内存后将指针置为空，有时候可以检查出这种错误。
3. 同一块内存释放两次；
所以，坚持只使用智能指针，就可以避免这些问题，对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。
#### delete之后重置指针值……
当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但是在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变成了人们所说的空悬指针(dangling pointer)，即指向一块曾经保存数据对象但现在已经无效的内存的指针。
未初始化的指针的所有缺点空悬指针也都有。有一种方法可以避免空悬指针的问题：在指针即将要离开作用域之前释放掉它所关联的内存。这样在指针关联的内存被释放掉之后，就没有机会继续使用指针了。如果我们需要保留指针，可以在delete之后将nullptr赋予指针，这几清除的指出指针不指向任何对象
#### ……这只是提供有限的保护
动态内存的一个基本问题是可能有很多个指针指向相同的内存。在delete内存之后重置指针的方法只对这个指针有效，对任何其他指向（已释放的）内存的指针是没有作用的，例如：
```
int *p(new int(42));  //p指向动态内存
auto q = p;           //p和q指向相同的内存
delete p;             //p和q均变为无效
p = nullptr;          //指出p不再绑定到任何对象
```
本例中p和q指向相同的动态分配的对象。我们delete此内存，然后将p置为nullptr，指出它不再指向任何对象。但是，重置p和q没有任何作用，在我们释放p所指向的（同时也是q指向的）内存时，q也变为无效了。在实际系统中，查找指向相同内存的所有有指针是均有困难的。
### 12.1.3 shared_ptr和new结合使用
如前所述，如果我们不初始化一个智能指针，它就会初始化一个空指针。我们还可以用new返回的指针来初始化智能指针：
```
shared_ptr<double> p1;   //shared_ptr可以指向一个double
shared_ptr<int> p2(new int(42));   //p2指向一个值42的int
```
接受指针参数的智能指针构造函数是explicit的。**因此我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针**：
```
shared_ptr<int> p1 = new int(1024);   //错误：必须使用直接初始化形式
shared_ptr<int> p2(new int(1024));    //正确：使用了直接初始化形式
```
p1的初始化隐式地要求编译器用一个new返回的int*来创建一个shared_ptr。由于我们不能进行内置指针到智能指针间的隐式转换，因此这条初始化语句是错误的。由于相同的原因，一个返回shared_ptr的函数不能在其返回语句中隐式转换一个普通指针：
```
shared_ptr<int> clone(int p) {
    return new int(p);   //错误：隐式转换为shared_ptr<int>
}
```
我们必须将shared_ptr显式的绑定到一个想要返回的指针上：
```
shared_ptr<int> clone(int p) {
    return shared_ptr<int>(new int(p));
}
```
默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。我们可以将智能指针绑定到一个指向其他类型的资源的指针上，但是为了这样做，必须提供自己的操作来替代delete。我们会在后文介绍。
##### 表12.3：定义和改变shared_ptr的其他方法
- shared_ptr<T> p(q)     p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型
- shared_ptr<T> p(u)     p从unique_ptr u那里接管了对象的所有权；将u值为空
- shared_ptr<T> p(q, d)  p接管了内置指针q所指向的对象的所有权。q必须能转换为T*类型。p将使用可调用对象d来代替delete
- shared_ptr<T> p(p2, d) p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete
- p.reset()/p.reset(q)/p.reset(q, d) 若p是唯一指向其对象shared_ptr,reset会释放此对象。若传递了可选的参数内置指针q，会令p指向q，否则会将p置为空。若还传递了参数d，则会调用d而不是delete来释放q
#### 不要混合使用普通指针和智能指针……
shared_pt可以协调对象的析构，但是仅限于其自身的拷贝(也是shared_ptr)之间。这要是为什么我们推荐使用make_shared而不是new的原因。这样，我们就能在分配对象就将shared_ptr与之绑定，从而避免了无意中将同一块内存绑定到多个独立创建的shared_ptr上。
考虑下面对shared_ptr进行操作的函数：
```
//在函数被调用时ptr被创建并初始化
void process(shared_ptr<int> ptr)
{
    //使用ptr
}   //ptr离开作用域，被销毁
```
process的参数是传值方式传递的，因此会被拷贝到ptr中。拷贝一个shared_ptr会递增其引用计数，因此在process运行过程中，引用计数值至少为2。当process结束时，ptr的引用计数会递减，但是不会变成0。因此，当局部变量ptr被销毁时，ptr指向的内存不会被释放。
使用此函数的正确方法是传递给它一个shared_ptr：
```
shared_ptr<int> p(new int(42));   //引用计数1
process(p);                       //拷贝p会递增它的引用计数，在process中引用计数值为2
int i = *p;                       //正确：引用计数值1
```
虽然不能传递给process一个内置指针，但是可以传递给它一个(临时的)shared_ptr，这个shared_ptr是用一个内置指针显式构造的。但是这样很可能会导致错误：
```
int *x(new int(1024));     //危险：x是一个普通指针，不是一个智能指针
process(x);  //错误：不能将int*转换为一个shared_ptr<int>
process(shared_ptr<int>(x));   //合法的，但是内存会被释放！
int j = *x;  //错误，x已经是一个空悬指针
```
在上面的调用中，我们将一个临时shared_ptr传递给process。当这个调用所在的表达式结束时，这个临时对象就被销毁了。销毁这个临时变量会递减引用计数，此时引用计数就变为0了。因此，当临时对象被销毁时，它所指向的内存会被释放。
但x继续指向（已经释放的）内存，从而变成一个空悬指针。如果试图使用x的值，其行为是未定义的。
当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了shared_ptr。一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向内存了。
> warning：使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁
#### ……也不要使用get初始化另一个智能指针或为智能指针赋值
智能指针类型定义了一个名为get函数，它返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况而设计：**我们需要向不能使用智能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete此指针**。
虽然编译器不会给出错误信息，但是将另一个智能指针也绑定到get凡户籍的指针上是错误的：
```
shared_ptr<int> p(new int(42));
int *q = p.get();  //正确：但使用q时要注意，不要让它管理的指针被释放
{ //新程序块
  //未定义：两个独立的shared_ptr指向相同的内存
    shared_ptr<int>(q);
} //程序块结束，q被销毁，它指向的内存被释放
int foo = *p;  //未定义：p指向的内存已经被释放了
```
在本例中，p和q指向相同的内存,由于它们是互相独立创建的，因此各自的引用计数都是1。当q所在的程序块结束时，q被销毁，这会导致q指向的内存被释放。从而p编程一个空悬指针，意味着当我们试图使用p时，将发生未定义的行为。而且当p被销毁时，这块内存会被第二次delete。
> warning：get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。
#### 其他shared_ptr操作
shared_ptr还定义了其他一些操作，参见了表12.2和表12.3所示，我们可以用reset来将一个新的指针赋予一个shared_ptr：
```
p = new int(1024);       //错误：不能将一个指针赋予shared_ptr
p.reset(new int(1024));  //正确：p指向一个新对象
```
与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成员经常与unique一起使用。来控制多个shared_ptr共享的对象。在改变底层对象之前，我们检查自己是否是当前对象仅有的游湖。如果不是，在改变之前需要制作一份新的拷贝：
```
if (!p.unique())
    p.reset(new string(*p));   //我们不是唯一用户；分配新的拷贝
*p += newVal;                  //现在我们知道自己是唯一的用户，可以改变对象的值
```
### 12.1.4 智能指针和异常
5.6.2节中介绍了使用异常处理的程序能在异常发生后令程序流程继续，我们注意到，这种程序需要确保在异常发生后资源能被正确的释放。一个简单的确保资源被释放的方法是使用智能指针。
如果使用智能指针，即使程序块过早结束，智能指针也能确保在内存不再需要时将其释放：
```
void f()
{
    shared_ptr<int> sp(new int(42));   //分配一个新对象
    //这段代码抛出一个异常，且在f中未被捕获
}   //在函数结束时shared_ptr自动释放内存
```
函数的退出有两种可能，正常处理结束或者发生了异常，无论哪种情况，局部对象都会被销毁。在上面的程序中，sp是一个shared_ptr，因此sp销毁时会检查引用计数。在此例中，sp是指向这块内存的唯一指针，因此内存会被释放。
与之相对的，当发生异常时，我么直接管理的内存是不会自动释放的。如果使用内置的指针管理内存，且在new之后在对应的delete之前发生了异常，那么内存不会被释放：
```
void f()
{
    int *ip = new int(42);   //动态分配一个新对象
    //这段代码抛出一个异常，且在f中未被捕获
    delete ip;               //在退出之前释放内存
}
```
如果在new和delete之间发生异常，且异常未在f中被捕获，则内存就永远不会被释放。*这个例子对比就体现出智能指针的优势*。
#### 智能指针和哑类
包括所有标准库在内的很多C++类都定义了析构函数，负责清理对象使用的资源。但是，不是所有的类都是这样良好定义的。特别是那些为C和C++两种语言设计的类，通常都要求用户显式地释放所使用的任何资源。
那些分配资源，而又没有定义析构函数来释放这些资源的类，可能会遇到与使用动态内存相同的错误——程序员非常容易忘记释放资源。类似的，如果在资源分配和释放之间发生了异常，程序也会发生资源泄露。
与管理动态内存相似，我们通常可以使用类似的技术来管理不具有良好定义的析构函数的类。例如，假定我们正在使用一个C和C++都是用的网络库，使用这个库的代码可能是这样的：
```
struct destination;     //表示我们正在连接什么
struct connection;      //使用链接所需要的信息
connection connect(destination*);   //打开连接
void disconnect(connection);        //关闭给定的连接
void f(destination &d /* 其他参数 */)
{
    //获得一个连接；记住使用后要关闭它
    connection c = connect(&d);
    //使用连接
    //如果我们在f退出前忘记调用disconnect，就无法关闭c了
}
```
如果connection有一个析构函数，就可以在f结束时由析构函数自动关闭连接。但是connection没有析构函数。这个问题与我们再上一个程序中使用shared_ptr避免内存泄漏几乎是等价的。使用shared_ptr来保证connection被正确关闭，已被证明是一个有效的方法。
#### 使用我们自己的释放操作
默认情况，shared_ptr假定它们指向的是动态内存。因此，当一个shared_ptr被销毁时，它默认对它管理的指针进行delete操作。为了用shared_ptr来管理一个connection，我们必须首先定义函数来代替delete。这个**删除器(deleter)**函数必须能够完成对shared_ptr中保存的指针进行释放的操作。在本例中，我们的删除器必须接受单个类型为connection*的参数。
```
void end_connection(connection *p) { disconnect(*p); };
```
当我们创建一shared_ptr时，可以传递一个（可选的）指向删除器函数的参数：
```
void f(destination &d /* 其他参数 */)
{
    connection c = connect(&d);
    shared_ptr<connection> p(&c, end_connection);
    //使用连接
    //当f退出时(即使是由于异常而推出)，connection会被正确关闭
}
```
当p被销毁时，它不会对自己保存的指针执行delete，而是调用end_connection。接下来，end_connection会调用disconnect，从而确保连接被关闭。如果f正常退出，那么p的销毁会作为结束处理的一部分。如果发生了异常，p同样被销毁，同样连接被关闭。
> 注意：智能指针陷阱
> 智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：
> - 不使用相同的内置指针值初始化(或reset)多个智能指针。
> - 不delete get()返回指针。
> - 不使用get()初始化或reset()另一个智能指针。
> - 如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。
> - 如果你使用智能指针管理的资源而不是new分配的内存。记住传递给它一个删除器。
### 12.1.5 unique_ptr
一个unique_ptr“拥有”它指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁了。表12.4列出了unique_ptr特有的操作。与shared_ptr相同的操作列在先前的表中。
与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。类似shared_ptr，**初始化unique_ptr必须采用直接初始化形式**：
```
unique_ptr<double> p1;             //可以指向一个double的unique_ptr
unique_ptr<int> p2(new int(42));   //p2指向一个值为42的int
```
由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或者赋值操作：
```
unique_ptr<string> p1(new string("Stegosauraus"));
unique_ptr<string> p2(p1);    //错误：unique_ptr不支持拷贝
unique_ptr<string> p3;
p3 = p2;                      //错误：unique_ptr不支持赋值
```
##### 表12.4：unique_ptr操作
unique_ptr<T> u1 / unique_ptr<T> u2 空unique_ptr,可以指向类型为T的对象。u1会使用delete来释放它的指针；u2会使用一个类型为D的可调用对象来释放它的指针。
unique_ptr<T, D> u(d) 空unique_ptr，指向类型为T的对象，用类型为D的对象d来代替delete
u = nullptr   释放u指向的对象，将u置空
u.release()   u放弃对指针的控制权，返回指针，并且将u置为空
u.reset()     释放u指向的对象
u.reset(q)    如果提供了内置指针q，令u指向这个对象；否则将u置为空
u.reset(nullptr)
虽然我们不能拷贝或者赋值unique_ptr，但可以通过调用release或reset将指针的所有权从一个(非const)unique_ptr转移给另一个unique：
```
//将所有权从p1(指向string Str..)转移给p2
unique_ptr<string> p2(p1.release());  //release将p1置为空
unique_ptr<string> p3(new string("Trex"));
//将所有权从p3转移给p2
p2.reset(p3.release()); //reset释放了p2原来指向的内存
```
release成员返回unique_ptr当前保存的指针并将其置为空。因此p2被初始化为p1原来保存的指针，而p1被置为空。
reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果unique_ptr不为空，它原来指向的对象被释放。因此对p2调用reset释放了用"Stregosaurus"初始化的string所使用的内存，将p3对指针的所有权转移给了p2，并将p3置为空。
调用release会切断unique_ptr和它原来管理的对象间的联系。release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。在本例中，管理内存的责任简单地从一个智能指针转移给另一个。但是，如果我们不用另一个智能指针来保存release返回的指针，我们的程序就要负责资源的释放：
```
p2.release();            //错误：p2不会释放内存，而且我们丢失了指针
auto p = p2.release();   //正确，但我们必须记得delete(p)
```
#### 传递unique_ptr参数和返回unique_ptr
不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr：
```
unique_ptr<int> clone(int p)
{
    //正确：从int*创建一个unique_ptr<int>
    return unique_int<int>(new int(p));
}
```
还可以返回一个局部对象的拷贝：
````
unique_ptr<int> clone(int p)
{
    unique_ptr<int> ret(new int(p));
    //...
    return ret;
}
````
对于两段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”，将在后文介绍。
> 向后兼容：auto_ptr
> 标准库的较早版本包含了一个名为auto_ptr的类，它具有unique_ptr的部分特性，但不是全部。特别是，我们不能再容器类中保存auto_ptr，也不能从函数中返回auto_ptr。虽然auto_ptr仍是auto_ptr仍是标准库的一部分，但是编写程序时应该使用unique_ptr。
#### 向unique_ptr传递删除器
类似shared_ptr，unique_ptr默认情况下用delete释放它指向的对象。与shared_ptr一样，我们可以重载一个unique_ptr中默认的删除器，但是unique_ptr管理删除器的方式与shared_ptr不同，其原因我们将在后文中介绍。
重载一个unique_ptr中的删除器会影响到unique_ptr类型以及如何构造(或者reset)该类型的对象。与重载关联容器的比较操作类似，我们必须在尖括号中unique_ptr指向类型之后提供删除器类型。在创建或者reset一个这种unique_ptr类型的对象时，必须提供一个指定类型的可调用对象（删除器）：
```
//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象
//它会调用一个名为fcn的delT类型对象
unique_ptr<objT, delT> p(new objT, fcn);
```
作为一个更具体的例子，我们将重写连接程序，用unique_ptr来代替shared_ptr，如下所示：
```
void f(destination &d /*其他参数*/)
{
    connection c = connect(&d);  //打开链接
    //当p被销毁时，连接将会关闭
    unique_ptr<connection, decltype(end_connection)*> p(&c, end_connection);
    //使用连接
    //当f退出时(即使是由于异常而退出)，connection会被正确关闭
}
```
在本例中我们使用了decltype来指明函数指针类型。由于decltype(end_connection)返回一个函数类型，所以我们必须添加一个*来指出我们正在使用该类型的一个指针。
### 12.1.6 weak_ptr
weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放。因此，weak_ptr的名字猪猪了这种智能指针“弱”共享对象的特点。
##### 表12.5:weak_ptr
- weak_ptr<T> w       空weak_ptr可以指向类型的T的对象
- weak_ptr<T> w(sp)   与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型
- w = p               p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象
- w.reset()           将w置为空
- w.use_count()       与w共享对象的shared_ptr的数量
- w.expired()         若w.use_count()为0，返回true，否则返回false
- w.lock()            如果expired为true，返回一个空shared_ptr；否则返回一个指向w的对象的shared_ptr
当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：
```
auto p = make_shared<int>(42);
weak_ptr<int> wp(p);   //wp弱共享p；p的引用计数未改变
```
本例中wp和p指向相同的对象，由于是弱共享，创建wp不会改变p的引用计数；wq指向的对象可能也被释放掉。
由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。此函数检查weak_ptr指向的对象是否仍然存在。如果存在，lock返回一个指向共享对象的shared_ptr，与任何其他shared_ptr类似，只要此shared_ptr存在，它所指向的底层对象也就一直存在。例如：
```
if (shared_ptr<int> np = wp.lock())  //如果np不为空则条件成立
{
    //在if中，np与p共享对象
}
```
在这段代码中，只有当lock调用返回true时我们才会进入if语句体。在if中，使用np访问共享对象是安全的。
#### 核查指针类
作为weak_ptr用途的一个展示，我们将为StrBlob类定义一个伴随指针类。我们的指针类将命名为StrBlobPtr，会保存一个weak_ptr，指向StrBlob的data成员，这是初始化时提供给它的。通过使用weak_ptr，不会影响一个给定的StrBlob所指向的vector的生存期。但是，可以阻止用户访问一个不再存在的vector的企图。
StrBlobPtr会有两个数据成员：wptr，或者为空，或者指向一个StrBlob中的vector；curr，保存当前对象所表示的元素下标。类似它的伴随类StrBlob，我们的指针类也有一个check成员来检查解引用StrBlobPtr是否安全：
```
//对于访问一个不存在元素的尝试，StrBlobPtr抛出一个异常
class StrBlobPtr {
public:
    StrBlobPtr() : curr(0) {}
    StrBlobPtr(StrBlob &a, size_t sz = 0) :
        wptr(a.data), curr(sz) {}
    std::string& deref() const;
    StrBlobPtr& incr();  //前缀递增
private:
    //若检查成功，check返回一个指向vector的shared_ptr
    std::shared_ptr<std::vector<std::string>> check(std::size_t, const std:string&) const;
    //保存一个weak_ptr，意味着底层vector可能会被销毁
    std::weak_ptr<std::vector<std::string>> wptr;
    std::size_t curr;
}
```
默认构造函数生成一个空的StrBlobPtr。其默认构造函数生成一个空的StrBlobPtr，其构造函数初始化列表将curr显式初始化为0，并将wptr隐式初始化为一个空weak_ptr。第二个构造函数接受一个StrBlob引用和一个可选的索引值。此构造函数初始化wptr，令其指向给定StrBlob对象的shared_ptr中的vector，并将curr初始化为sz的值。我们使用了默认参数，表示默认情况下将curr初始化一个元素的下标。我们将会看到，StrBlob的end成员将会用到参数sz。
值得注意的是，我们不能将StrBlobPtr绑定到一个const StrBlob对象。这个限制是由于构造函数接受一个非const StrBlob对象的引用而导致。
值得注意的是，我们不能将StrBlobPtr绑定到一个const StrBlob对象。这个限制是由于构造函数接受一个非const StrBlob对象的引用而导致的。
StrBlobPtr的check成员与StrBlob中的同名成员不鸟他，它还要检查指针指向vector是否还存在：
```
std::shared_ptr<std::vector<std::string>> StrBlobPtr::check(std::size_t i, const std::string &msg) const
{
    auto ret = wptr.lock();  //vector还存在吗？
    if (!ret)
        throw std::runtime_error("unbound StrBlobPtr");
    if (i >= ret->size())
        throw std::out_of_range(msg);
    return ret;  //否则，返回指向vector的shared_ptr
}
```
由于一个weak_ptr不参与其对应的shared_ptr的引用计数，StrBlobPtr指向的vector可能已经被释放了。如果vector已销毁，lock将返回一个空指针。在本例中，任何vector的引用都会失败，于是抛出一个异常。否则，check会检查给定索引，如果索引值合法，check返回从lock获得的shared_ptr。
#### 指针操作
我们将定义名为deref和incr的函数，分别来解引用和递增StrBlobPtr。
deref成员调用check，检查使用vector是否安全以及curr是否在合法范围内：
```
std::string& StrBlobPtr::deref() const
{
    auto p = check(curr, "dereference past end");
    return (*p)[curr];   //(*p)是对象所指向的vector
}
```
如果check成功，p就是一个shared_ptr，指向StrBlobPtr所指向的vector。表达式(*p)[curr]解引用shared_ptr来获得vector，然后使用下标运算符提取并返回curr位置上的元素。
incr成员也调用check：
```
//前缀递增：返回递增后的对象的引用
StrBlobPtr& StrBlobPtr::incr()
{
    //如果curr已经指向容器的尾后位置，就不能递增他
    check(curr, "increment past end of StrBlobPtr");
    ++curr;   //推进当前位置
    return *this;
}
```
当然，为了访问data成员，我们的指针类必须声明为StrBlob的friend。我们还要为StrBlob的类定义begin和end操作，返回一个指向它自身的StrBlobPtr：
```
//对于StrBlob中的友元来说，此前置声明是有必要的
class StrBlobPtr;
class StrBlob {
    friend class StrBlobPtr;
    //其他成员与前文声明相同
    //返回指向首元素和尾后元素的StrBlobPtr
    StrBlobPtr begin() { return StrBlobPtr(*this);}
    StrBlobPtr end() {
        auto ret = StrBlobPtr(*this, data->size());
        return ret;
    }
};
```
## 12.2 动态数组
new和delete运算符一次分配/释放一个对象，但某些应用需要一次为很多对象分配内存的功能。例如vector和string都是在连续内存中保存它们的元素，因此，当容器需要重新分配时，必须一次性为很多元素分配内存。
为了支持这种需求，C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new的表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力，后文会解释这样的原因。
很多（应该说绝大多数）应用都没有直接访问动态数组的需求。当一个应用需要可变数量的对象时，我们在StrBlob中所采用的的方法几乎总是更加简单、更快速并且更安全的——即使用vecotr(或者其他标准库容器)。如前文所述，使用标准库容器的优势在新标准下更显著。在支持新标准的标准库中，容器操作比之前的版本要快得多。
> Advice：大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单，更不容器以出现内存管理错误并且可能会有更好的性能。
如前所述，使用容器的类可以使用默认版本的拷贝、赋值和析构操作。分配动态数组的类则必须定义自己版本的操作。在拷贝、复制以及销毁对象时管理所关联的内存。
### 12.2.1 new和数组
为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。在下例中，new分配要求数量的对象并（假定分配成功后）返回指向第一个对象的指针：
```
//调用get_size确定分配多少个int
int *pia = new int[get_size()];   //pia指向第一个int
```
方括号中的大小必须是整形，但不必是常量。
也可以用一个表示数组类型的类型别名来分配一个数组，这样，new表达式中就不需要方括号了：
```
typedef int arrT[42];   //arrT表示42个int的数组类型
int *p = new arrT;      //分配一个42个int的数组；p指向第一个int
```
#### 分配一个数组会得到一个元素类型的指针
虽然我们通常称new T[]分配的内存为“动态数组”，但这种叫法某些程度有些误导。当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。即使我们使用类型别名定义了一个数组类型，new也不会分配一个数组类型的对象。在上例中，我们正在分配一个数组的事实甚至都是不可见的——连[num]都没有。new返回的是一个元素类型的指针。
由于分配的内存并不是一个数组类型，**因此不能对动态数组调用begin或者end**，这些函数使用数组维度（回忆一下，维度也是数组类型的一部分）来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围for语句来处理（所谓的）动态数组中的元素。
> warning：要记住我们所说的**动态数组并不是数组类型**，这是很重要的
#### 初始化动态分配对象的数组
默认情况下，new分配的对象，不管是单个分配的还是数组中，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号：
```
int *pia = new int[10];            //10个未初始化的int
int *pia2 = new int[10]();         //10个值初始化为0的int
string *psa = new string[10];      //10个空的string
string *psa2 = new string[10]();   //10个空string
```
在新标准中，我们还可以提供一个元素初始化器的花括号列表：
```
int *pia3 = new int[10]{0, 1, 2, 3, 4, 5}; //剩余的使用默认初始化
string *psa3 = new string[10]{"a", "an", "the", string(3, 'x')};
```
注意，如果初始化器数目大于元素数目，则new表达式失败，不会分配任何内存。在本例中，new会抛出一个类型为bad_array_new_length的异常，类似bad_alloc，此类型会定义在头文件new中。
虽然我们能用空括号对元素进行值初始化，但是不能在括号中给出初始化器。这意味着不能使用auto分配数组。
#### 动态分配一个空数组是合法的
可以用任意表达来确定要分配的对象的数目：
```
size_t n = get_size();    //get_size返回需要的元素数目
int *p = new int[n];      //分配数组保存元素
for (int* q - p; q != p + n; ++q)
    /*处理数组*/;
```
这产生了一个有意思的问题：如果get_size返回为0，会发生什么？答案是代码仍然能正常工作。虽然我们不能创建一个大小为0的静态数组对象，但当n等于0时，调用new[n]是合法的：
```
char arr[0];               //错误：不能定义长度为0的数组
char *cp = new char[0];    //正确：但cp不能解引用
```
当我们用new分配一个大小为0数组时，new返回一个合法的非空指针。此指针就跟尾后指针一样，我们可以像用尾后迭代器一样使用这个指针。可以用此指针进行比较操作，反正此指针不能解引用，剩余的都可以；上面的这个循环体也不会被执行
#### 释放动态数组
为了释放动态数组，我们使用一种特殊形式的deletef——在指针前加上一个方括号：
```
delete p;       //p必须指向一个动态分配的对象或空
delete [] pa;   //pa必须指向一个动态分配的数组或者空
```
第二句话销毁pa指向的数组中的元素，并释放对应的内存。数组中的元素按照**逆序**销毁，即最后一个先被销毁，然后倒数第二个，以此类推。
当我们释放一个指向数组的指针时，空方括号是必须的：它指示编译器辞职真指向一个对象数组的第一个元素。如果忽略方括号（或者不小心delete一个对象时使用了方括号），其行为是未定义的。
回忆一下，即使是使用类型别名来定义一个数组类型时，在new表达式中不使用[]，但是即使是这样，在释放一个数组指针时也必须使用方括号：
```
typedef int arrT[42];
int *p = new arrT;
delete [] p;  //方括号是必须的
```
#### 智能指针和动态数组
标准库提供了一个可以管理new分配的数组的unique_ptr版本。为了用一个unique_ptr管理动态数组，我们必须在对象类型后面跟一对方括号：
```
//up指向一个包含10个未初始化int的数组
unique_ptr<int[]>up (new int[10]);
up.release();  //自动用delete[]销毁其指针
```
类型说明符中方括号(<int[]>)指出up指向一个int数组而不是一个int。由于up指向一个数组，当up销毁它管理的指针时，会自动调用delete[]。
指向数组的unique_ptr提供的操作与我们在先前定义的那些操作有些不同，我们在表12.6中描述了这些操作。当一个unique_ptr指向一个数组时，我们不能使用点和箭头成员运算符。毕竟unique_ptr指向的是一个数组而不是单个对象，因此这些运算符是无意义的。另一方面，当一个unique_ptr指向一个数组时，我们可以使用下标运算符来访问数组中的元素：
```
for (size_t i = 0; i != 10; ++i)
    up[i] = i;    //为每个元素赋予一个新值
```
##### 表12.6：指向数组的unique_ptr
指向数组的unique_ptr不支持成员访问运算符（点和箭头运算符）。其他unique_ptr操作不便。
- unique_ptr<T[]> u      u可以指向一个动态分配的数组，数组元素类型为T
- unique_ptr<T[]> u(p)   u指向内置指针p所指向的动态分配的数组。p必须能转化为类型T*
- u[i]                   返回u拥有的数组中位置i处的对象，其中u必须指向一个数组   
与unique_ptr不同，shared_ptr不直接支持管理动态数组。如果希望使用shared_ptr管理一个动态数组，必须提供自己定义的删除器：
```
//为了使用shared_ptr，必须提供一个删除器
shared_ptr<int> sp(new int[10], [](int *p){ delete [] p; });
sp.reset();  //使用我们提供的lambda释放数组，它使用delete[]
```
本例中我们传递给shared_ptr一个lambda作为删除器，它使用delete[]释放数组。
如果未提供删除器，这段代码将是未定义的。默认情况下，shared_ptr使用delete销毁它所指向的对象。如果此对象是一个动态数组，对其使用delete所产生的问题与释放一个动态数组指针时忘记[]产生的问题一样。
shared_ptr不直接支持动态数组管理这一特性会影响我们如何访问数组中的元素：
```
//shared_ptr未定义下标运算符，并且不支持指针的算术运算
for (size_t i = 0; i != 10; ++i)
    *(sp.get() + i) = i;  //使用get获取一个内置指针
```
shared_ptr未定义下标运算符，而且智能指针类型不支持指针算数运算。因此，为了访问数组中的元素，必须用get获取一个内置指针，然后用它来访问数组元素。
### 12.2.2 allocator类
new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，delete将对象析构和内存释放组合在了一起。我们分配单个对象时，通常希望将内存分配和对象初始化组合在一起。因为在这种情况下，我们几乎肯定知道对象应有什么值。
当分配一大块内存时，我们通常计划在这块内存上按需构造对象，在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象出按键操作（同时复出一定开销）。
一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费。例如：
```
string *const p = new string[n]; //构造n个空string
string s;
string *q = p;                   //q指向第一个string
while (cin >> s && q != p + n)
    *q++ = s;                    //赋予*q一个新值
const size_t size = q - p;       //记住我们读取了多少个string
//使用数组
delete[] p;    //p指向一个数组，记得用delete[]来释放
```
new表达式分配并初始化了n个string。但是，我们可能不需要n个string，少量string可能就足够了。这样，我们就可能创建了一些永远也用不到的对象。而且对于那些确实要使用的对象，我们就可能创建一些永远用不到的对象。而且对于那些确实要使用的对象，我们也在初始化之后立即赋予了它们新值。每个使用到的元素都被赋值了两次：第一次在默认初始化时，随后是在赋值时。
更重要的是，那些没有默认构造函数的类就不能动态分配数组了。
#### allocator类
标准库**allocator**类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。表12.7概述了allocator支持的操作。在本节中，我们将介绍这些allocator操作。在后文中，我们将看到如何使用者类的经典例子。
类似vector，allocator是一个模板。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：
```
allocator<string> alloc;          //可以分配string的allocator对象
auto const p = alloc.allocate(n); //分配n个未初始化的string
```
这个allocate调用为n个string分配了内存。
##### 12.7 标准库allocator类及其算法
- allocator<T> a     定义了一个名为a的allocator对象，它可以为类型T的对象分配内存
- a.allocate(n)      分配一段原始的、未构造的内存，保存了n个类型为T的对象
- a.deallocate(p, n) 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy
- a.contruct(p, args) p必须是一个类型为T*的指针，指向一块原始内存；arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象
- a.destroy(p)        p为T*类型的指针，此算法对p指向的对象执行析构函数
#### allocator分配未构造的内存
allocator分配的内存是未构造的（unconstructed）。我们需要在此内存中构造对象，在新标准库中，contruct成员函数接受一个指针和零个或者多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。类似make_shared的参数,这些参数必须是与构造对象类型相匹配的合法的初始化器：
```
auto q = p;  //q指向最后构造的元素之后的位置
alloc.construct(q++);              //*q为空字符串
alloc.construct(q++, 10, 'c');     //*q为cccccccccc
alloc.construct(q++, "hi");        //*q为hi!
```
在早期版本的标准库，construct只能接受两个参数，指向创建对象位置的指针和一个元素类型的值。因此，我们只能将一个元素拷贝到未构造空间中，而不能用元素类型的任何其他构造函数来构造一个元素。
还未构造对象的情况下就使用原始内存是错误的：
```
cout << *p << endl;  //正确：使用string的输出运算符
cout << *q << endl;  //灾难：q指向未构造的内存！
```
> warning：为了使用allocate返回的内存，我们必须用construct构造对象。使用未构造的内存，其行为是未定义的。
当我们用完对象后，必须对每个构造的元素调用destroy来销毁他们，函数destroy接受一个指针，对指向的对象执行析构函数：
```
while (q != p)
    alloc.destroy(--q);  //释放我们真正构造的string
```
在循环开始处，q指向最后构造的元素之后的位置。我们在调用destroy之前对q进行了递减操作。因此第一次调用destroy时，q指向最后一个构造的元素，最后在循环中我们destroy了第一个构造的元素，随后q将与p相等，循环结束。
> warning：我们只能对真正的元素进行destroy操作。
一旦元素被销毁后，就可以重新使用这部分内存来保存其他string，也可以将其归还给系统。释放内存通过调用deallocate来完成：
```
alloc.deallocate(p, n);
```
我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。
#### 拷贝和填充未初始化内存的算法
标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。他们都定义在头文件memory中。
##### 表12.8：allocator算法
这些函数在给定目的位置元素，而不是由系统分配内存给它们。
- uninitialized_copy(b, e, b2)   从迭代器b和e指出的输入范围中拷贝元素到迭代器b2 指定的未构造的原始内存中。b2指向的内存必须足够大，能容纳输入序列中的元素的拷贝。
- uninitialized_copy_n(b, n, b2) 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中
- uninitialized_fill(b, e, t)    在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝
- uninitialized_fill_n(b, n, t)  从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。
作为一个例子，假定一个int的vector，希望将其内容拷贝到动态内存中。我们将分配一块比vector重元素所占空间大一倍的动态内存，然后将原vector中的元素拷贝到前一个空间，对后一半空间用一个给定值进行填充：
```
auto p = alloc.allocate(vi.size() * 2);   //分配比vi中元素所占用空间大一倍的动态内存
auto q = uninitialized_copy(vi.begin(), vi.end(), p);  //通过拷贝vi中的额元素来构造从p开始的元素
uninitialized_fill_n(q, vi.size(), 42);  //将剩余元素初始化为42
```
类似拷贝算法，uninitialized_copy接受三个迭代器参数。前两个表示输入序列，第三个表示这些元素将要拷贝到目的空间。传递给uninitialized_copy的目的位置迭代器必须指向未构造的内存。与copy不同，uniitialized_copy在给定目的位置构造元素。
类似copy，uninitialized_copy返回（递增后）目的位置迭代器。因此，一次uninitialized_copy调用会返回一个指针，指向最后一个构造的元素只有的位置。在本例中，我们将此指针保存在q中，然后将q传递给uninitialized_fill_n。此函数类似fill_n，接受一个指向目的位置的指针、一个计数和一个值。它会在目的位置指针指内存中创建给定数目个对象，用给定值对它进行初始化。

# 第三部分 类设计者的工具
如前所示，在C++中，我们通过定义构造函数来控制在类类型的初始化对象初始化时做什么。类还可以控制在对象拷贝、赋值、移动和销毁时做什么。在这方面，C++与其它语言是不同的，其它很多语言都没有给予设计者控制这些操作的能力。第13章将介绍这些内容，本章还会介绍新标准引入的两个重要的概念：右值引用和移动操作。    
第14章介绍运算符重载，这种机制允许内置运算符作用域类类型的运算对象。这样，我们创建的类型直观上就可以像内置类型一样使用，运算符重载是C++借以实现这一目的的方法之一。     
类可以重载的运算符中有一种特殊的运算符——函数调用运算符。我们重载了这种运算符的类，我们可以“调用”其对象，就好像它们是函数一样。新标准库中提供了一些设施，使得不同类型的可调用对象可以以一种一致的方式来使用，我们也将介绍这部分内容。     
第14章最后将介绍另一种特殊类型的类成员函数——转换运算符。这些运算符定义了类类型对象的隐式转换机制。编译器应用这种转换机制的场合与原因都与内置类型转换时一样的。     
第3部分的最后两章江辉介绍C++如何面对对象编程和泛型编程。    
第15章会介绍继承和动态绑定。继承和动态绑定与数据抽象一起构成了面向对象编程的基础。继承令关联类型的定义更为简单，而动态绑定则可以帮助我们编写类型无关的代码，可以忽略具有继承关系的类型之间的差异。     
第16章介绍函数模板和类模板。模板可以让我们写出类型无关的通用类和函数。新标准引入了一些模板相关的新特性：可变参数模板、模板类型别名以及控制实例化的新方法。     
编写我们自己的面向对象或是泛型的类型需要对C++有深刻理解。幸运的是，我们无需掌握如何构建面向对象和泛型类型的细节也可以使用它们。流入，标准库中广泛使用了我们在15章和第16章中学习的技术，虽然我们已经使用了标准库类型和算法，但是实际上我们并不了解它们是如何实现的。       
因此，读者应该明白第3部分涉及的是相当深入的内容。编写模板或面向对象的类要求对C++的基本知识和基本类的定义有着深刻的理解。           
    
# 第13章 拷贝控制    
如我们在第7章缩减，每个类都定义了一个新类型和此类型对象上可执行的操作。在本章中，我们还将学到，类可以定义构造函数，用来控制在创建此类型对象时做什么。    
在本章中，我们还将学习类如何控制该类型对象拷贝、赋值、移动或销毁时做什么。类通过一些特殊的成员函数控制这些操作，包括：拷贝构造函数、移动构造函数、拷贝构造函数运算符、移动赋值运算符以及析构函数符号。     
拷贝和移动构造函数定义了当用同类型另一个对象初始化文本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做了什么。析构函数定义了此类型对象销毁时做什么。我们称这些操作为**拷贝控制操作(copy control)**。    
如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。因此，很多类会忽略这些拷贝控制操作。但是，对一些类来说，依赖这些操作的默认定义会导致灾难。    
## 13.1 拷贝、赋值与销毁    
我们将以最基本的操作——拷贝构造函数、拷贝赋值运算和析构函数作为开始。我们将在后文中介绍移动操作（新标准所引入的操作）；    
### 13.1.1 拷贝构造函数     
如果第一个构造函数的第一个参数是自身类类型的引用，其任何外额外参数都有默认值，则此构造函数是拷贝构造函数。    
```
class Foo {
public:   
    Foo();             //默认构造函数
    Foo(const Foo&);   //拷贝构造函数
};
```    
拷贝构造函数第一个参数必须是一个引用类型，愿意我们稍后解释。虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const引用。拷贝构造函数在几种情况下都会被隐式的使用。因此，拷贝构造函数通常不应该是explicit的。    
##### 合成拷贝构造函数    
如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他






