# Primier C++

# 第一部分 C++基础

## 第1章 开始 
1. 除了cin、cout，还有两个标准输出对象为cerr(错误输出)和clog(日志输出)；
2. 提出了“流刷新”的概念，类似sql数据库的commit，如果一直不进行刷新，可能信息就会一直在内存中而没有显示出来；
3. 形如以下形式：    
```
while (std::cin >> value)
    sum += value;
```   
其实while后括号判断的是等式的最终结果，即std::cin的内容，一般输入一个合法结果，则返回为真，输入一个错误结果（例如回车符号），则返回为假；   

## 第2章 变量和基本类型
1. 基本类型中，比较少用的有wchar_t(宽字符，16位，对应1字节的char)，还有unicode字符char16_t和char32_t；（分别为16位和32位的Unicode字符）
2. 应该养成习惯，在明确知道数值不可能为负的情况下，应当选用无符号整形；   
3. 当给一个无符号数赋予一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数，例如``unsigned char c = -1  //char占8bit的情况下，c的值为255``，这意味着无符号数和有符号数一定不能够混用：   
```
uint u = 10;
int i = -42;
std::cout << u + i << std::endl; //结果为4294967264
```
4. 指定字面值类型：   
字符和字符串面值
| 前缀 | 含义 | 类型 |
| ---  | --- | --- |
| u    | Unicode16字符 | char16_t |
| U    | Unicode32字符 | char32_t |
| L    | 宽字符        | wchar_t  |
| u8   | UTF-8         | char     |   
整形字面值
|后缀|最小匹配类型|
|--|--|
|u or U|unsigned|
|l or L|long|
|ll or LL|long long|   
浮点型字面值
|--|--|
|f或F|float|
|l或L|long double|   
以上字面值都可以混合使用   
5. C++11新标准，确立了可以用花括号来初始化变量，这种初始化可以称为**列表初始化**，例如以下四个句子效果是一样的：   
```
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```   
这种初始化方式的一个特点在于，如果列表初始化中的数据有丢失信息的风险，则编译器就会报错，相反的，如果只是单纯的赋值，则会自动强制转换（伴随的就是精度丢失）
```
long double ld = 3.1415926;
int a{ld}, b = {ld}; //报错，因为存在信息丢失风险
int c(ld), d = ld; //正确，但丢失了精度
```    
6. 变量声明和定义中，如果想要声明一个变量而非定义它，则需要加extern关键字，并且不要显式的初始化变量，因为任何包含显式初始化的声明即会变成定义（C++使用分离式编译的原则，将声明和定义区分开来）
> 变量只能被定义一次，但是可以被多次声明。   
看上去丝毫不重要的声明和定义也许微不足道，但是非常重要。**如果要在多个文件中使用同一个变量，则必须将声明和定义分离**。此时变量的定义必须且只能出现在一个文件中，而其他用到该变量的文件必须进行声明，但是绝不能重复定义。   
7. 标识符：C++规定了用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外在函数体外的标识符不能以下划线开头。   
8. C++11使用nullptr来初始化指针，替代了原先的NULL；
9. void *指针可以存放任意对象的地址，但是并不能知晓对象的类型；   
10. 指向指针的引用：   
```
int i = 42;
int *p;       //p是一个int型指针
int *&r = p;  //r是一个对指针p的引用

r = &i;       //r引用了一个指针
*r = 0;
```
要理解r的类型到底是什么，最简单的办法是**从右至左阅读r的定义**。离变量名最近的符号（此例中为&）对变量类型有着最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中*说明&引用的是一个指针。最后，声明的基本数据类型部分指出r是一个int型指针。   
11. const限定符: 
```
int i = 42;
const int ci = i;
int j = ci;
```
const类型可以直接赋给非const的原因在于,ci的常量特性只在执行改变ci的操作中才会发挥作用，拷贝一个对象并不会改变它。   
另一个值得注意的是，const对象仅仅在文件内有效，事实上，编译使用了类似define的方法，将const类变量先用数值进行替代，因此每个用到的const变量都应该有所定义（有初始值）。   
有一种特殊情况在于需要共享const变量，做法是在一个.h和.cpp文件中进行定义即可： 
```
//file_1.h 
extern const int bufSize;
//file_1.cc
extern const int bufSize = fcn();
```   
12. const引用（常引用）： 常引用非常类似普通变量的常指针   
```
int i = 0;
const int &ip = i;
```
一般情况下，引用的类型必须和其所引用的对象类型一致，但是有两种特殊情况：1) 初始化常量引用时允许任意表达式作为初始值，只要表达式的结果能够转换为引用结果即可；   
```
int i = 42;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 * 2; //正确，为一常量引用
int &r4 = r1 * 2; //错误
```
这样能够产生的原因是因为编译器引入了**临时量**对象，即编译器用一个空间来暂存表达式的求职结果时临时创建的一个未命名的对象。
```
double dval = 3.14;
const int &ri = dval;

//编译器处理为
const int temp = dval;
const int &ri = temp;
```   

13. const指针：指针是对象，而引用不是，因此指针就和其他对象类型一样，可以把指针视作为常量。**常量指针**必须进行初始化，而且一旦完成，和其他常量一样，就无法改变了（即存放在常量指针中的地址无法改变了）。把*放在const之前说明指针是一个常量，这里暗含着不变的是指针本身的值而不是指向的那个值：   
```
int errNumb = 0;
int *const curErr = &errNumb;   //curErr将一直指向errNumb
const double pi = 3.14159;
const double *const pip = &pi; //pip是一个指向常量对象的常量指针
```   
如果先前所讲，判断复杂的变量类型依然遵循**由右向左**的阅读顺序。此例中，离curErr最近的是const，意味着本身是一个常量对象，对象的类型由声明符的其余部分决定，下一个符号是*，意思是curErr是一个常量指针。最后，声明语句的基础数据部分类型指明了它指向一个int对象。    
另一个注意点是指针本身是个常量并不意味着不能通过指针修改其所指向的对象的值。例如：    
```
if (*curErr)
{
    errorHandler();
    *curErr = 0;
}
```   

14. 顶层const：指针本身就是一个对象，而它又可以指向另一个对象，因此这是两个独立的问题。用名词**顶层const(top-level const)** 来表示指针本身是一个常量，而用名称**底层const(low-level const)** 表示指针所指向的对象是一个常量。更一般的，顶层const可以表示任何对象是常量，这一点对于任何数据类型适用。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类既可以是顶层const也可以是底层const,这一点和其他类型区别相比明显：    
```
int i = 0;
int *const p1 = &i;  //p1值不能被改变，是一个顶层const
const int ci = 42;  //ci值不能被改变，是一个顶层const
const int *p2 = &ci;  //p2的值可以被改变,是一个底层const
const int *const p3 = p2;  //靠右的const是顶层const,靠左的const是底层const   
const int &r = ci; //用于声明引用的const都是底层const
```    
顶层const有什么用呢？当执行对象拷贝操作时，常量是顶层还是底层区别明显，其中顶层const不受太多影响：   
```
i = ci;  //正确：ci是一个顶层const，无影响
p2 = p3; //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响
```   
另一方面，底层的const的限制却不容忽视，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的const资格，或者两个对象的数据类型必须能够相互转换。一般来说，非常量可以向常量转换，但是反之不行：   
```
int *p = p3;   //错误：p3包含了底层const定义，而p没有
p2 = p3;  //正确:p2和p3都是底层const（注意，这里把一个常指针赋给了非常指针，没有问题）
p2 = &i;  //正确：int*能够转换为const int*
int &r = ci; //错误:普通的int&不能够绑定到int常量上去   
const int &r2 = i;  //正确：const int&可以绑定到一个普通的int上
```   
p3既是顶层const又是底层const,拷贝p3时可以不在乎它是一个顶层const，但是必须清楚它指向的对象是一个常量。因此不能用p3去初始化p，因为p指向的是一个（非常量）整数，另一方面，p3的值也可以赋给p2，是因为这两个指针都是底层const，尽管p3本身是一个常量指针（顶层const），但是就这次赋值而言，不会有什么影响。

15. 新特性constexpr和常量表达式：常量表达式指的是值不变且在编译过程中就能得到计算结果的表达式，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。一个对象（或表达式）是不是常量表达式是由它的数据类型和初始值共同决定的，例如：   
```
const int max_files = 20;  //max_files是常量表达式
const int limit = max_files + 1;  //limits是常量表达式   
int staff_size = 27; //staff_size不是常量表达式
const int sz = get_size();  //sz不是常量表达式
```
尽管staff_size的初始值是个字面值常量，但是其数据本身只是一个普通非const int。而sz本身是一个常量，但是其具体值需要运行时才能获取，所以也不是常量表达式。   
引入constexpr变量的原因在于，在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式，实际使用中即使定义了一个const变量并且将其设定为一个我们认为是常量表达式的值，但实际使用过程中并非如此。   
C++11新标准规定，允许声明变量为constexpr类型以便由编译器来验证变量值是否为一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：    
```
constexpr int mf = 20; //20是常量表达式
constexpr int limit = mf + 1; //mf+1是常量表达式
constexpr int sz = size(); //只有当size是一个constexpr函数时才是一条正确的声明语句
```   
尽管不能使用普通函数作为constexpr变量的初始值，但是新标准允许一种特殊的constexpr函数，应该足够简单到编译时就可以计算它的结果，也就能用constexpr函数去初始化constexpr变量了。   

16. 字面值类型：类型简单，值显而易见的类型被称为“字面值类型”(literal type)。目前接触的数据类型中，算数类型、引用和指针都属于字面值类型，string\IO库和自定义类则不属于，也就不能被定义为constexpr。这里值得注意的是，尽管指针和引用都能被定义为cosntexpr，但是他们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或是存储于某个固定地址中的对象。
Tip:函数体内的变量一般来说并非存在固定的地址中，因此constexpr指针不能指向这样的变量。相反，定义于函数体外的对象其固定地址不变，则能够用来初始化constexpr指针。但是，C++允许函数定义一类超出函数本身的变量，这些变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的指针。   

17. 指针和constexpr:const和constexpr区别在哪儿？如果使用了constexpr定义了一个指针，那么constexpr仅对指针有效，而对指针所指的对象无关（这一点和const相反）：   
```
const int *p = nullptr; //p是一个指向整形常量的指针
constexpr int *q = nullptr; //q是一个指向整数的常量指针
```   
p和q的类型相差甚远，关键就在于constexpr是把它所定义的对象定义为了顶层const，这样意味着它可以随便指向常量或者非常量:   
```
constexpr int *np = nullptr;  
int j = 0;
constexpr int i = 42;  //i的类型是整形常量
//i和j都必须定义在函数体之外
constexpr const int *p = &i; //p是常量指针，指向整形常量i 
constexpr int *p1 = &j; //p1是常量指针，指向整数j
```   

18. 类型别名（type alias）: 有两种方法实现类型别名。一种方法是使用传统的``typedef``：
```
typedef double wages;  
typedef wages base, *p; //base是double的同义词，p是double*的同义词
```
C++11新的声明方法，使用别名声明（alias declaration）来定义类型别名:   
```
using SI= Sales_item;  //SI是Sales_item的同义词
```    

19. 指针、常量和类型别名：   
如果某个类型别名指代的是复合类型或者常量，那么把它运用到声明语句里就会产生意想不到的后果，例如下个例子当中的pstring实际上是char*的别名：   
```
typedef char *pstring; 
const pstring cstr = 0; //cstr是指向char的常量指针
const pstring *ps; //ps是一个指针，它的对象是指向char的常量指针
```   
这里极其容易混淆的是，pstring实际上是指向char的指针，因此const pstring指的是指向char的常量指针（**因为const是对给定类型的修饰符**）, 而非指向常量字符的指针。   
遇到一条使用了类型别名的声明语句，人们往往会错误地尝试把别名替换成它本来的样子，来理解该语句的含义：   
```
const char *cstr = 0;
```
而这样的展开或者替换完全错误，这是因为const char连写注定了后面的*修饰的是这个整体；   

20. auto类型说明符：
auto让编译器通过初始值来推断变量的类型，显然，**auto定义的变量必须有初始值**：
```
auto item = val1 + val2; //item初始化为val1和val2相加的结果
```   
使用auto也能在一条语句中声明多个变量，但是同一个声明语句中只能有一个基本数据类型，所有该语句中所有变量的初始基本数据类型都必须一样：   
```
auto i = 0, *p = &i;  //正确：皆为整形数据或指针
auto sz = 0, pi = 3.14; //错误：sz和pi类型不一致
```    
编译器推断出的auto类型有时候和初始值类型会不完全一样。
首先，由于使用引用时直接使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：   
```
int i = 0, &r = i;
auto a = r; //a是一个整数
```
其次，auto一般会忽略顶层const，同时底层const会保留下来，例如初始值是一个指向常量的指针时：   
```
const int ci = i, &cr = ci;
auto b = ci; //b是一个整数（ci顶层const特性被忽略）
auto c = cr; //c是一个整数（cr是别名，ci本身是一个顶层const）
auto d = &i; //d是一个整形指针（整数的地址就是指向整数的指针）
auto e = &ci; //e是一个指向整数常量的指针（对常量对象取地址是一种底层的const）
```   
(这里从b可以看出顶层const既可以是指针，还可以是引用的形式)   
如果希望推断的auto类型是一个顶层const，则需要进行明确指出：   
```
const auto f = ci;  //f是const int
```   
还可以将引用的类型设定为auto，此时原来的初始化规则依然适用：   
```
auto &g = ci;   //g是个整形常量引用，绑定到ci
auto &h = 42;   //错误：不能将非常量引用绑定字面值
const auto &j = 42; //正确：可以为常量引用绑定字面值
```   
设定一个类型为auto引用时，初始值中的顶层常量属性依然保留。和往常一样，**如果我们给初始值绑定一个引用，此时的常量就不是顶层常量了**（说白了最后发现auto引用是整体引用，和auto本身有一定差别）。   
同上，如果要在一个语句中定义多个变量，需要记住&和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一个类型：   
```
auto k = ci, &l = i;  //k为整数，l为整形引用   
auto &m = ci, *p = &ci; //m是对整形常量的引用，p是指向整形常量的指针
auto &n = i, *p2 = &ci; //错误，因为i的类型为int而&ci的类型为const int
```   

21. decltype类型指示符：有时候会遇到希望从表达式类型推断出要定义的变量的类型，但是又不想用该表达式的值初始化变量的情况。这里C++11引入``decltype``作为返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，但是却不计算表达式的值：   
```
decltype(f()) sum = x; //sum的类型就是函数f返回的类型
```   
编译器并不会直接调用函数f，而是使用当调用发生时f的返回类型作为sum的类型。   
decltype处理顶层const和引用方式和auto略有不同，如果decltype使用的表达式是一个变量的话，那么decltype返回该变量的类型（包含顶层const和引用在内）：   
const int ci = 0, &cj = ci;
decltype(ci) x = 0;  //x类型为const int
decltype(cj) y = x;  //y类型为const int&, 绑定到变量x
decltype(cj) z;  //错误：z是一个引用，必须进行初始化处理
```    
需要指出的一点是，引用从来都是作为其所指向的对象的同义词出现，只有在decltype处是一个例外，下面会进行解释。   
如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。而有些表达式会返回一个引用类型，一把来说这种情况发生时，意味着该表达式的结果对象能够作为一条赋值语句的左值：   
```
//decltype的结果可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; //正确：加法结果为0，所以b为一个int（没有初始化）
decltype(*p)       //错误：？c是int&,必须进行初始化
```
因为r是一个引用，因此decltype(r)的结果是引用类型。如果想让结果类型是r所指向的类型，可以将r作为表达式的一部分，例如r + 0。这样就巧妙的将表达式的结果表示为一个具体值而不是一个引用。    
另一方面，如果表达式内容**是解引用操作, 则decltype将得到引用类型**，正如我们熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，所以decltype(*p)的结果类型就是int&而非int。   
> Tip: 解引用操作符指的是\*在C++中，用于得到操作数所指向变量的引用（这说明\*不是单纯的指向原操作数，而是一个引用）   
decltype和auto另一处区别在于变量加上括号后可能结果类型会发生改变：   
```
decltype((i)) d;  //错误：d是int&,必须初始化
decltype(i) e;    //正确：e是一个未初始化的int
```   
原因在于给变量套上括号后，编译器就会把它当做一个表达式。   

22. 自定义数据结构：   
如果数据结构一上来就准备好使用对应的变量，一般可以写成：   
```
struct Sales_data {/**/} accum, trans, *salesptr;
//也可以写成
struct Sales_data {/**/};
Sales_data accum, trans, *salesptr;
```   
C++11规定，可以为数据成员提供一个**类内初始值**。   
    
## 第3章 字符串、向量和数组    
1. using形式不仅可以使用整个命名空间，更可以单独指定某个符号：   
```
using std::cout; 
using std::endl;
```   
Tip:头文件不应该包含using声明，这是因为头文件的内容会被拷贝到所有引用它的文件中去。如果头文件中有某个using声明，则会导致所有使用该头文件的文件都有这个声明，这样就会导致可能的冲突。    

2. 直接初始化和拷贝初始化：使用等号，即为拷贝初始化，如果不使用等号，则执行的是直接初始化。   

3. 使用getline读取一整行数据：   
```
int main()
{
    string line;
    //每次读入一整行，直到到达文件末尾
    while (getline(cin, line))
        cout << line << endl;
    return 0;
}
```    
注意，保存到line当中的对象并不包括换行符，哪怕一开始为换行符（这种情况下为空）   

4. string::size_type:这体现了标准库类型是与机器无关的特性，如果一条表达式中已经有了size()函数就不要再使用int了，可以避免混用int和unsigned可能带来的问题。 可以使用decltype来解决这个问题  
```
for (decltype(s.size()) index = 0; index != s.size() && isspace(s[index]); ++index)
    s[index] = toupper(s[index]); //将当前字符改成大写形式
```

5. 字面值不可以直接相加：   
```
string s7 = "hello" + "," + s2; //字面值必须和string类型相邻相加才可以继续进行
```   

6. 新的for使用准则：C++11中引入了新范围语句    
```
for (declaration: expression)
    statement
```   
例如：    
```
string str("some string");
//每行输入str中的一个字符
for (auto c : str)
    cout << c << endl;
```    

7. vector对象初始化： C++11支持使用花括号来进行vector对象初始化：   
```
vector<string> articles = {"a", "an", "the"};
vector<string> v0{"a", "an", "the"};
```   
使用花括号或者圆括号来区分列表初始值还是元素数量：    
```
vector<int> v1(10);  //v1有10个元素，每个值都是0
vector<int> v2{10};  //v2有1个元素，值为10
vector<int> v3(10, 1); //v3有10个值为1的元素
vector<int> v4{10, 1}; //v4有2个元素，值分别为10为1
```   
某些操作可能会让迭代器操作失效（pushback在遇到一定体量后，会重新修改了迭代器所指的空间内容）   

8. 迭代器的运算：迭代器可以和一个整数值相加（或相减），其返回值为一个移动了若干位置的迭代器。例如要获得一个指向vector对象中间位置的元素：    
```
//计算得到最接近vi中间元素的一个迭代器
auto mid = vi.begin() + vi.size() / 2;
```    
两个迭代器类型相减，得到的类型是名为**difference_type**的带符号整数型。   
这里给出一个迭代器用于二分搜索：   
```
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg) / 2;
while (mid != end && *mid != sought)
{
    if (sought < *mid)
        end = mid;
    else 
        beg = mid + 1;
    mid = beg + (end - beg) / 2; 
}
```

9. 数组：大小不变的存储结构，可用花括号进行初始化。**并且不支持拷贝给其他数组或者赋值**（有些支持该操作的编译器称之为编译器扩展，应当避免使用）；   
复杂数组声明的例子：   
```
int *ptrs[10];   //ptrs是含有10个整形指针的数组
int &refs[10] = /*?*/; //错误，不存在引用的数组
int (*Parray)[10] = &arr;  //Parray是指向一个含有10个整数的数组
int (&arrRef)[10] = arr;   //arr引用一个含有10个整数的数组
```   
一般的，依据**类型符由右向左绑定**的规律。例如ptrs由右向左：首先是一个10大小的数组，它的名字是ptrs，然后知道其指向类型为指向int的指针。   
特例在于Parray，由右向左理解似乎不太合理，更合理的方式在于**由内向外的顺序**。首先*Parray意味着Parray是一个指针，接下来看右侧，知道Parray是个指向大小为10的数组的指针。最后观察左边，可以知道数组中的元素是int。   
总结：判断数据类型由**先由内至外，后从右至左**来进行判断。    
```
int *(&arry)[10] = ptrs; //arry是数组的引用，该数组有10个指针
```    

10. size_t:使用数组下标时，通常定义为size_t类型，它是一种及其相关的无符号类型(类似difference_type)，它被设计得足够大来表示内存中任意对象大小。    
同样可以使用新for语句适用于数组的遍历：   
```
for (auto i : scores)
    cout << i << " ";
```

11. 指针和数组：首先auto是支持指针的
```
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia); //ia2是一个整形指针，指向ia第一个元素
ia2 = 42; //错误：ia2作为一个指针，不可以用int值给指针赋值
```   
必须支出的是，如果使用decltype关键字时上述转换不会发生，decltype(ia)返回的是10个整数构成的数组:   
```
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
ia3 = p; //错误：不能将整形指针给数组赋值
ia3[4] = i; //正确：吧i赋值给ia3的一个元素
```   
总结：decltype覆盖范围没有auto大    

12. 指针也是迭代器：虽然说我们一般不会使用指向尾元素的下一个元素，但是可以用于模仿迭代器模式对数组进行遍历
```
int *e = &arr[10]; //指向arr尾元素的下一个位置的指针
for (int *b = arr; b != e; ++b)
    cout << *b << endl;
```   

13. 标准库函数begin和end：为了减少尾后指针极可能使用出错的情况，C++11引入了标准库函数begin和end，包含在iterator头文件中：    
```
int ia[] = {0,1,2,3,4,5,7,8,9};
int *beg = begin(ia); //指向ia首元素
int *last = end(ia); //指向arr尾元素下一位置的指针
```    
例如寻找到一个数组中的第一个负数：   
```
int *pbeg = begin(arr), *pend = end(arr);
while (pbeg != pend && *pbeg >= 0)
    ++pbeg;
```   

14. 指针运算：众所周知指针可以进行运算。和迭代器的difference_type不同，两个指针相减结果是一种名为**ptrdiff_t**的标准库类型：   
```
auto n = end(arr) - begin(arr); 
```   
和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中机器相关的类型，因为其差值可能为一个负数，所以ptrdiff_t是一个带符号类型。     
只要两个指针指向同一个数组的元素（或者尾元素的下一个元素），就能利用关系运算符对其进行比较，例如下面这个遍历数组中元素的例子：       
```
int *b = arr, *e = arr + sz;
while (b < e) {
    //使用*b
    ++b;
}
```

15. 下标和指针：下标也可以及其自由的使用，例如：   
```
int ia[] = {0,2,4,6,8};
int *p = &ia[2];
int j = p[1];   //指向ia[3]
int k = p[-2];  //指向ia[0]
```
虽然string和vector也能执行下标运算，但是还是略有不同，标准库类型都限定了下标必须是无符号类型，而内置的下标没有这个限制。   

16. 与旧代码的接口：   
1) 混用string对象和C风格字符串：string提供了c_str()函数来转化为c风格的字符串类型：   
```
const char *str = s.c_str();
```   
2) 使用数组初始化vector对象：   
vector的初始化其实不用逐一赋值，用迭代器(指针)的方法非常便捷：   
```
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));
```   
这种方法另一个好处是可以提出中间一部分对象：   
```
vector<int> subVec(int_arr + 1, int_arr + 4); //拷贝了三个元素，分别为1、2、3
```     
> 建议：尽量使用标准库类型而非数组，例如C++程序应尽量使用vector和迭代器而非使用内置数组和指针，使用string而非c风格基于数组的字符串；   

17. 多维数组：严格来说C++语言中没有多维数组，通常说的多维数组本质是数组的数组，理解这一点对日后使用多维数组大有裨益。   
```
int ia[3][4];  //大小为3的数组，每个元素时含有4个整数的数组
int arr[10][20][30] = {0}; //大小为10的数组，每个元素为大小为20的数组，而这些数组元素是含有30个整数的数组，最终将每个元素初始化为0
```   
阅读顺序依然遵照由内而外的规律，例如ia是一个3个元素的数组，同时这每一个元素本身都是含有4个元素的数组。   
多维数组的初始化类似普通数组，每一行都用花括号括了起来：   
```
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
};
```   
而事实上内嵌花括号并非必须，同样可以使用一位数组形式以更简洁的方式完成以上的初始化工作（前提是没有错误）：   
```
int ia[3][4] =  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
```    
也可以显示的初始化每行首元素（仅仅）：   
```
int ia[3][4] = {{0} , {4}, {8}};
```   
如果只是显式的初始化第一行元素，其它元素被初始化为0：    
```
int ix[3][4] = {0, 3, 4, 9};
```   
下标引用：**如果表达式含有的下标运算符和数组维度一样多，该表达式的结果将是给定类型的元素，如果比数组维度小，则将是返回一个给定索引处的一个内层数组**:   
```
ia[2][3] = arr[0][0][0]; //首元素赋给ia最后一个元素
int (&row)[4] = ia[1]; //将row绑定到ia的第二个4元素数组上
```   
另一个例子，常用两层嵌套来处理多维数组:   
```
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt]; 
for (size_t i = 0; i != rowCnt; ++i) //对于每一行
{
    for (size_t j = 0; j != colCnt; ++j)  //对于每一列
    {
        ia[i][j] = i * colCnt + j;
    }
}
```   
更简洁的，使用C++11的范围语句，可以简化为：   
```
size_t cnt = 0;   
for (auto &row : ia)
    for (auto &col : row) {
        col = cnt;
        cnt++;
    }
```   
这里有个很有意思的地方，为什么要强制使用引用？本质在于避免自动转化为指针：如果不使用引用类型，循环形式如下：
```   
for (auto row : ia)
    for (auto col : row)
```    
程序将会无法通过编译，这是因为，第一个循环ia所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类型，编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转换为指向给数组内首元素的指针，那么得到的row类型就是int*，因此内存循环就不合法了（编译器将试图在一个int*内进行遍历）   
> Note:要使用范围for语句处理更多的多维数组，除了最内层的循环外，其他所有的循环的控制变量都应该是引用类型。    
指针和多维数组：当程序使用多维数组的名字时，也会自动将其转换为指向数组首元素的指针。   
```
int ia[3][4];    //大小为3的数组，每个元素是含有4个整数的数组
int (*p)[4] = ia; //p指向含有4个整数的数组
p = &ia[2];  //p指向ia的尾元素
```  
> Note: 上述声明中，圆括号必不可少
> int *ip[4]; //包含4个整形指针的数组
> int (*ip)[4]; //指向包含4个整数的数组的指针    
C++11新标准可以使用auto或者decltype来避免对指针遍历时再定义一个指针类型了：   
```
for (auto p = ia; p != ia + 3; ++p)
    for (auto q = *q; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
```    
使用标准库函数begin和end可以获得同样的功能，而且形式表达上更加简洁：   
```
for (auto p = begin(ia); p != end(ia); ++p)
    for (auto q = begin(*p); q != end(*p); ++q)
        cout << *q << ' ';
    cout << endl;
```   
这样就既不用在乎size也不用在乎类型。如果需要更进一步，使用类型别名可以使这个过程更加简单一些，例如：   
```
using int_array = int[4]; //C++11新标准声明别名的形式
//或者使用
typedef int int_array[4]; 

for (int_array *p = ia; p != ia + 3; ++p)
    for (int *q = *p; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
```   

## 第4章 表达式
1. 基础：   
C++定义了一元(取地址符&/解引用符*)、二元、三元（A?B:C）运算符
左值右值：
C中，单纯的指左值只能位于赋值表达式的左侧，右值只能位于赋值表达式的右侧；   
C++中，当一个对象被用作右值时，用的是对象的内容（值）；而当对象被用作左值时，用的是对象的身份（在内存中的位置）；   
和C比起来，左值一方面在为常量时，并不能作为赋值语句的左侧运算对象，另一方面，虽然有些表达式求值结果是对象，但是它们是右值而非左值。   
运算符操作的一个重要原则在于**需要右值的地方，可以用左值代替，但是反之不成立**，并且当一个左值被当成右值使用时，实际使用的就是它的值（内容）。   
> Tip: 使用关键字decltype时，左值和右值也略有不同，如果求值结果为左值，则decltype作用于该表达式（非变量）得到一个引用类型。例如p的类型为int*,因为解引用符生成左值，故decltype(*p)得到一个int&。另一方面取地址运算符生成右值，故decltype(&p)的结果是int**, 也就是一个指向整形指针的指针。   
求值顺序：运算符的优先级决定了运算对象的组合方式，但是没有框定运算对象按什么顺序求值。**大多数情况下不会明确指定求值的顺序**，例如：   
```
int i = f1() * f2();
```   
这里对于不同的编译器来说，就无法判断是f1先调用还是f2先调用。还有例如：  
```
int i = 0; 
cout << i << " " << ++i << endl; //未定义
```
这种输入结果各种编译器也会有很大区别，完全不可预知。所以编程中尽量避免这种写法。**这给我们的启示是尽量在复杂的表达式中对同一个对象进行多次操作（至多一次）**，如果实在是需要，请用括号加以限制。  
但是有4种运算符明确了其运算对象的求值顺序，&&（逻辑与）规定了先求左侧并且只有左侧为真时才能继续求右侧（**这个很有用，尤其在判断输入变量是否满足标准的情况下**），另三种分别为逻辑或(||)、条件(?:)与逗号(,);   
2. 取余运算：取余运算的定义为，如果m和n是整数且n并非0，则m = (m/n) * n + m % n。其隐含意思为，**如果m % n不等于0，那么其结果应该始终和m的符号相同**，根据这个原则，我们不难求出：   
```
-21 % 8 = -5; -21 / -8 = 2;
21 % -5 = 1;  -21 / 5 = -4;
```   

3. 逻辑运算符：上面提过，对于逻辑与和逻辑或（&&和||）都是先求左侧对象值再求右侧对象之（除非左侧运算对象无法确定表达式才会计算右侧运算对象的值），这种策略称为短路求值（short-circuit evaluation）,一个示范可以用于指针为空和size的判断，这样可以显得语法更加简洁：   
```
bool isTen(QVector<int> *iptr){
    if (iptr && iptr->size() == 10)
        return true;
    return false;
}
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    qDebug() << isTen(Q_NULLPTR);
    return a.exec();
}
```   

4. 赋值运算符：赋值运算符合右结合律，这一点和其他的二元运算符不太一样，最常见的就是**多重赋值**，当然，这种语句必须类型转换正确：   
```
int ival, jval;
ival = jval = 0;  
```   
较低优先级的赋值运算带来的写法变换：**赋值语句经常出现在条件中**，这是因为赋值运算优先级低，通常需要给赋值语句加上括号来使得其符合我们的原意。下面给一个例子说明赋值语句放在条件语句中有什么用处，它的目的是反复调用一个函数直到返回期望的值为止：   
```
//以下为一个形式繁琐，易出错的写法
int i = get_value();   
while (i != 42)
{
    //其它处理...
    i = get_value(); //得到下一个值，继续判断
}
```   
实际上可以简化为：   
```
int i;
while ((i = get_value()) != 42)
{
    //其他处理...
}
```
这个处理更加简洁，也证明了赋值运算符本身较低的运算符。   
复合赋值运算符：+=、-=、*=、/=、%=、<<=、>>=、&=、^=、|=，其本质和其本身表达式只是稍有区别``a = a op b``，其实在很多地方，这种区别对于程序的影响几乎可以忽略不计。   

5. 递增与递减运算符（++/--）：除非必须，一般不使用递增递减运算符的后置版本，这里从另一个方面揭示了**为什么前置++的效率比后置++高？**，这是因为**前置直接返回了这个数自身+1的内容，而后置版本还需要先把原始值存储下来，用于返回这个未修改的内容**，如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。   
当然任何问题都不是绝对的，如果我们遇到在一条复合表达式中既将变量+1或减-1又能使用其原始值，这时候就可以使用递增和递减运算符的后置版本，例如以下这个例子：   
```
auto pbeg = v.begin();
while (pbeg != v.end() && *pbeg >= 0)
    cout << *pbeg++ << endl;
```   
> Tip: 虽然*pbeg++的表达式可能不太一定容易理解，但是其实这是一种更有效的写法，远比书写**cout << *pbgeg << endl; ++pbeg;**要更加简洁非，并且也更少出错。大多数C++程序追求简洁、摒弃冗长，应该习惯于这种写法。    
> Tip: 注意++极容易引起任意求值顺序问题的错误；   

6. 条件运算符：条件运算符(?:)已经非常常用，这里有两点注意点：   
1) 嵌套使用：
```
finalgrade = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : "pass";
```   
不过注意，如果超过两层，代码的可读性急剧下降；   
2) 在输出表达式中使用条件运算符：这里极其容易造成问题的原因是因为条件运算符的优先级很低，应该加以括号进行限制；   
```
cout << ((grade < 60) ? "fail" : "pass"); //输出pass或fail
cout << (grade < 60) ? "fail" : "pass"; //输出1或者0
cout << grade < 60 ? "fail" : "pass"; //错误，因为试图比较cout和60
```   

7. 位移运算符：位运算符作用于整数类型运算对象，并把运算对象看成是二进制位的集合。同时C++提供了bitset类（标准库）可以表示任意大小的二进制位集合，所以位运算符同样能用于bitset类型。   
有两个平时用的比较少的位运算符：**~求反运算符、^异或运算符**
> Warning: 位运算没有规定只能使用于有符号整形还是无符号整形，一般推荐仅将位运算符用于处理无符号整形。   
求反运算符:会将char类型的运算对象提升为int类型（向高位添加0即可），然后逐位求反。   
移位运算符（又叫IO运算符）满足左结合律，例如：   
```
cout << "hi" << "there" << endl;
```
等同于：   
```
((cout << "hi") << " there") << endl);
```     
移位运算符优先级不高不低，介于中间：比算术运算符优先级低，但是比关系运算符、赋值运算符和条件运算符的优先级高。    
```
cout << 42 + 10; //52
cout << (10 < 42); //1
cout << 10 < 42; //错误：试图比较cout和42
```   

8. sizeof运算符：返回一个表达式或者一个类型名字所占的字节数，其使用形式有两种：   
```
sizeof(type)
sizeo expr
```  
第二种形式中，sizeof返回的是表达式结果类型的大小，稍微不一样的是，sizeof并不计算其运算对象的值：   
```
Sales_data data, *p;  
sizeof(Sales_data); //存储Sales_data类型对象所占的空间大小   
sizeof data;        //data的类型大小，即sizeof p;           //指针所占空间大小
sizeof *p;          //p所指类型的空间大小，即sizeof(Sales_data)    
sizeof data.revenue;  //成员对应类型大小
sizeof Sales_data::revenue; //另一种获取revenue大小的方式
```   
其中最有意思的就是``sizeof *p``,其中即使p为空指针也不会影响最终的结果，因为sizeof根本也不需要通过运算值就可以知道类型的大小。   
最后一个例子则揭示了，C++11新标准中，使用了作用域运算符来获取类成员的大小。   
9. 逗号运算符：逗号运算符经常被人忽略。其运算遵循：先对左侧的表达式求值，然后将求值最终结果丢掉。逗号运算符的真正结果是右侧表达式的值，如果右侧表达式是一个左值，那么最终的求值结果就是个左值；   
最常见的逗号运算符的使用见于for循环中：     
```
vector<int>::size_type cnt = ivec.size();   
for (vector<int>::size_type ix = 0;ix != ivec.size(); ++ix, --cnt)
    ivec[ix] = cnt;
```   

10. 类型转换：任何编程语言都无法避免类型转换这个话题。首先最简单的是隐式转换（implicit conversion）。其次是算数转换。    
整形提升：false提升为0，true提升为1；小char型（bool、char、short等）都会转换为int，其余的提升为unsigned int。   
较大的char类型（wchar_t、char16_t、char32_t）提升为int、unsigned int、long、unsigned long、long long和unsigned long long中的最小的一种类型。

11. 显式转换：   
命名强制转换具有以下形式：   
```
cast-name<type>(expression);
```   
其中type是目标类型而expression是要转换的值，如果type是引用，则结果是左值。而cast-name会从**static_cast、dynamic_cast、const_cast和reinterpret_cast**
static_cast:    
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。例如：   
```
int i, j;
double slope = static_cast<double>(j) / i;
```   
当需要把一个较大的算数类型赋值给较小的类型时，static_cast非常有用。此时强制类型告诉程序阅读者和编译器：这里机器知道并且不在乎潜在的精度损失（这可以避免一大批warning）；     
static_cast对于编译器无法自动执行的类型转换也非常有用，例如找回存在于void*的指针：   
```
void *p = &d;   //正确：任何非常量对象的地址都能存入void*   
double *dp = static_cast<double*>(p); //转换为double类型指针
```     

const_cast:     
const_cast只能改变运算对象是底层const，例如：    
```
const char *pc;
char *p = const_cast<char*>(pc); //正确：但是通过p改变值是未定义的行为
```    
这样把常量对象转换为非常量对象的行为，我们一般称为去掉const性质，编译器也就不会再组织我们对该对象进行写操作。如果对象本身不是一个常量，这样的行为就是合法的，但是如果是一个常量，就容易会产生未定义的后果。    
const_cast的特殊之处就在于只有它能够改变表达式的常量属性，其他cast—name强制类型转换表达式的常量属性都会导致编译器错误。同理，也不能用const_cast改变表达式的类型：   
```
const char *cp;
char *q = static_cast<char*>(cp); //错误：static_cast不能转换掉const性质   
static_cast<string>(cp); //正确：将字符串字面值换为string类型
const_cast<string>(cp);  //错误：const_cast只能改变常量属性，而不能改变类型
```   
> Tip:const_cast常常用于有函数重载的上下文中，下文将会进行介绍   

reinterpret_cast:     
reinterpret_cast通常为对象的位模式提供较低层次上的重新解释，例如有以下转换：   
```
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```   
这里需要牢记pc所指向的真实对象是一个int而非字符，如果把pc当成普通的字符指针就可能在运行时发生错误。例如：   
```
string str(pc);
```     
可能导致异常的运行时行为。

> Suggestion:避免强制类型转换时对于检查类型的建议，这个建议对于reinterpret_cast尤其适用，因为这种类型转换总是充满了风险。比较无可厚非的使用是在有重载函数的上下文中使用const_cast，但是在其它情况下使用const_cast也就意味着程序存在某种设计缺陷。其它强制类型转换，例如static_cast和dynamic_cast，都不应该频繁使用。每书写一条强制类型转换语句，都应该反复斟酌是否能以其它方式事项相同目标。    
**应摒弃早期的强制转换写法**，即type(expr)或者(type)expr，因为这样的类型转换会带来不一样的结果，**完全应该使用static_cast或者const_cast替换**；   

## 第5章 条件语句    
当程序对的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时检测出问题的部分应该发出某种信号来表明程序遇到了故障，无法再继续下去了。**而且信号的发出方无需知道故障将在何处得到解决**。一旦发出异常信号，检测出问题的部分也就完成了任务。   
如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据，如果丢失了数据库连接，会发出报警信息。    
异常处理机制为程序中的异常检测和异常处理这两部分的协作提供支持，在C++语言中，异常处理包括：   
- throw表达式：异常检测部分使用throw表达式表示它遇到了无法处理的问题。   
- try语句块：异常处理使用try语句块处理异常。try语句块以关键字try开始，并以一个或者多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称为**异常处理代码**。   
- 一套异常类，用于在throw表达式和对应的catch子句之间传递异常的具体信息。   
1. throw表达式：程序的异常检测使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。   
举个例子，例如检查是否是同一种书籍，然后判断其是否能够相加：   
```
Sales_item item1, item2;
cin >> item1 >> item2;
//首先检查item1和item2是否表示同一种书籍
if (item1.isbn() == item2.isbn()) {
    cout << item1 + item2 << endl;
    return 0; //表示成功
} else {
    cerr << "Data must refer to same ISBN" << endl;
    return -1; //表示失败
}
```    
在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序使得检查完成后不再直接输出一条信息，而是抛出一个异常：   
```
//首先检查两条数据是否关于同一种书籍的
if (item1.isbn() == item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
//如果程序执行到这里，表示两个ISBN是相同
cout << item1 + item2 << endl;
```   
这段代码中，如果ISBN不一样就会抛出一个异常，该异常时类型runtime_error的对象，抛出异常就会**终止当前的函数，并且把控制权交给能处理该异常的代码**。   
类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。我们必须使用一个string对象或者一个C风格的字符串来初始化一个runtime_error对象。   

2. try语句块：其通常形式如    
```
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} //...
```     
在之前的例子里，我们使用了一个throw表达式来避免把两个代表不同书籍的Sales_item相加。我们假设执行Sales_item对象加法的代码时与用户交互的代码分离开来的。其中与用户交互的代码负责处理发生的异常，它的形式可能如下：   
```
while (cin >> item1 >> item2) {
    try {
        //执行添加两个Sales_item对象的代码
        //如果添加失败，代码抛出一个runtime_error
    } catch (runtime_error err) {
        //提醒用户两个ISBN必须一致，询问是否重新输入   
        cout << err.what() 
             << "\nTry Again? Enter y or n" << endl;
        char c;
        cin >> c;
        if (!cin || c == 'n')
            break;
    }
}

```   
程序本来要执行的任务出现在try语块中，因为这段代码可能会抛出一个runtime_error类型的异常。   
try语句块对应一个catch的子句，该子句负责处理类型为runtime_error的异常。如果try语句块的代码抛出了runtime_error异常，接下来执行catch块内的语句。在我们书写的catch子句中，输出一段提示信息要求用户指定程序是否继续。   
给用户的提示信息中最后输出了err.what()的返回值，其实就是其初始化的字符串。   
函数在寻找处理代码的过程中退出：在复杂系统中，程序在抛出异常代码之前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能又调用了一个包含新的含有try语句块的函数，依次类推。   
寻找处理代码的过程与函数的调用链正好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没有找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也会被终止，继续搜索调用它的函数。以此类推，沿着程序执行的路径逐层回退，直到找到适合类型的catch的子句为止。   
如果最终还是没找到与任何匹配的catch子句，程序转到名为terminate的标准库函数，该函数行为和系统有关，一般情况下执行该函数将会导致程序非正常退出。     
对于那些没有任何try语句块定义的异常，也按照类似的方式处理；毕竟，没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。    
3. 标准异常：
C++标准库定义了一组类，用于报告标准库函数中遇到的问题，这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中：   
- exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。   
- stdexcept头文件定义了几种常用的异常类，这些类会在下面表中列出。   
- new头文件定义了bad_alloc异常类型。   
- type_info头文件定义了bad_cast异常类型。   
    
## 第6章 函数
1. 函数基础：这里已经非常熟悉，不过有一些需要注意的点是   
- 传入函数的实参的顺序并没有规定，编译器可以以任何顺序对实参求值（这意味着传入的实参千万不能互相打架）    
- 函数的**返回类型不能是数组类型或者函数类型**，但是可以是指向数组或者函数的指针，下文会介绍如何返回数组的指针/引用以及函数的指针。   
> Tip:一个函数中的静态变量可以很方便的进行所谓次数统计的工作，这一点非常特别，当然它们只会在第一次运行时初始化一次。   
```
size_t count_calls()
{
    static size_t ctr = 0;  
    return ++ctr;
}

int main() {
    for (size_t i = 0; i != 10; i++)
        cout << count_calls() << endl;
    return 0;
}
//将会输出1到10的数字
```     
2. 参数传递：   
- 使用引用避免拷贝：除了已经熟知的原因（不复制对应的对象），还有一些原因例如某些类型根本不支持拷贝（例如IO类型）
- 利用引用返回多参数：一个经常使用的技巧就是使用引用来返回额外的信息     
- const形参和实参：顶层const只作用于对象本身   

```
const int ci = 42;  //不能改变ci，const是顶层的
int i = ci;  //正确：当拷贝ci时，会忽略它的顶层const
int * const p = &i;  //const是顶层的，不能给p赋值
*p = 0;
```     
- 尽量使用常量引用：应该从底层函数就注意使用该原则，这样避免设计高一阶函数时出现该问题；
- 数组形参：前面提过，数组有两个性质限制了其在函数使用中有区别——1) 不允许拷贝数组；2) 使用数组时通常会将其转换成指针；尽管不能以值传递的方式传递数组，但是我们可以把形参转换为类似数组的形式：   

```
//以下三个print函数等价
void print(const int*);
void print(const int[]);
void print(const int[10]); //这里的10只能表示我们希望的数组的大小，实际并不一定
```
随之而来的问题就是管理指针形参数量问题，通常使用：   
1) 使用标记指定数组长度：例如C风格字符串到\0之前确认为有效；   
2) 使用标准库规范:向函数传递数组的首元素和尾后元素的指针，这种方法收到标准库技术的启发，例如：   
```
void print(const int *beg, const int *end)
{
    while (beg != end)
        cout << *beg++ << endl;
}
```
调用时传入两个指针，可以使用标准库的begin和end函数：   
```
int j[2] = {0, 1};
print(begin(j), end(j));
```
3) 显示的传递一个数组的大小：这种方法在C和传统C++方法中非常常见     

**数组引用形参**：C++允许将变量定义为数组的引用,同理，函数形参也可以是数组是的引用。此时引用形参绑定到对应的实参上，也就是绑定到数组上：   
```
void print(int (&arr)[10])
{
    for (auto elem : arr)
        cout << elem << endl;
}
```   
> Tip:这里需要区分引用的数组和数组的引用之间的区别——f(int &arr[10]) //错误：arr为引用的数组、f(int (&arr)[10]) //z正确：arr为具有10个整数的整形数组的引用    
这里虽然没问题，但是由于指定了数组维度的大小，这样也限制了print函数的可用性，下文中还会给出不限大小形式的输出；    
  
传递多维数组：就像之前介绍的那样，C++语言中实际上没有真正的多维数组，所谓的多维数组其实是数组的数组。    
例子：   
```
//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组
void print(int (*matrix)[10], int rowSize);
{/*...*/}
```
> Tip:同上面的引用数组，注意括号是必须的。   
同样也可以使用数组的语法定义函数，此时编译器会一如既往的忽略掉第一个维度，所以最好不要把它包括在形参列表内：    
```
//等价定义
void print(int matrix[][10], int rowSize){}
```    

**main:处理命令行选项**：    
有时候，我们的确需要给main传递实参，常见的main带参形式我们已经很熟了：   
```
int main(int argc, char *argv[]){...}
```
argc等于记录argv中字符串的数量，因为第二个参数为数组，main函数也可以定义为：   
```
int main(int argc, char **argv){...}
```     
例如在一个可执行文件中传入main函数的内容，
```
prog -d -0 ofile data0
```
那么argc = 5，argv里包含以下C风格的字符串：   
```
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```
> Warning:当使用argv中间的实参时，一定要记得可选的实参从argv[1]开始，**argv[0]保存的是程序的名字，而非用户输入**。

**含有可变形参的函数**：C++11标准提供两种方法来解决编写处理不同数量实参的函数的问题：1) 如果所有是参类型相同，我们可以传递一个名为initializer_list的标准库类型；2) 如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，后面会介绍。    
C++还有一种**省略符**形参，用它可以传递可变数量的实参。下面会进行介绍，但是这种功能一般只用于和C函数的接口程序。    

#### initializer_list形参    
如上文所说，initializer_list针对的是类型相同的形参的模板，和vector一样，在定义时需要包含所属的元素例如：   
```
initializer_list<string> ls; 
initializer_list<int> li;
```    
但是和vector不一样的是，initializer_list对象中的元素永远是常量值。   
例如我们用它来输出错误信息：   
```
void error_msg(initializer_list<string> il)
{
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << " ";
    cout << endl;
}
```
如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内：    
```
if (excepted != actual)
    error_msg({"functionX", excepted, actual});
else 
    error_msg({"functionX", "okay"});
```    
当然，含有initializer_list形参的函数也可以拥有其他形参，例如调试系统可以有个名为ErrCode的类来表示不同类型的错误，因此我们可以改写之前的程序，使其包含一个initializer_list形参和一个ErrCode形参：   
```
void error_msg(ErrCode e, initializer_list<string> il)
{
    cout << e.msg() << ": ";
    for (const auto &elem : il)
        cout << elem << " ";
    cout << endl;
}
```
那么对应的调用形式可以写为：    
```
if (excepted != actual)
    error_msg(ErrCode(42), {"functionX", excepted, actual});
else
    error_msg(ErrCode(0), {"functionX", "okay"});
```    

#### 省略符形参：   
只用于兼容C的varargs的情况，其他情况基本不会使用，形式例如：    
```
void foo(parm_list, ...);
void foo(...);
```    

3. 返回类型和return语句：   
> Tip: **不要反悔局部对象的引用或者指针**，这是因为在生命周期结束后，局部变量所占用的空间也会被释放掉。     
> Tip: 那么什么时候反悔指针和引用呢？例如比较两个数，返回较大的那个数，就可以使用。    
```
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```     

#### 返回类型的函数和调用运算符     
首先调用运算符也有结合律，例如：   
```
auto sz = shorterString(s1, s2).size();
```
**引用返回左值**：函数的返回类型决定是否为左值，调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回的引用，特别是，能够给返回类型（非常量引用）直接赋值：   
```
char &get_val(string &str, string::size_type ix)
{
    return str[ix]; 
}

int main()
{
    string s("a value");
    cout << s << endl; //输出a value
    get_val(s, 0) = 'A';
    cout << s << endl; //输出A value
    
    return 0;
}
```    

**列表初始化返回值**：C++11规定，函数可以返回花括号的值的列表。和其他返回结果一样，此处的列表也用来表示函数返回的临时量进行初始化，例如：   
```
vector<string> process()
{
    if (excepted.empty())
        return {};
    else if (excepted == actual)
        return {"functionX", "okay"};
    else 
        return {"functionX", excepted, actual};
}
```    

递归：main函数不能递归    

**返回数组指针**：因为数组不能被拷贝，所以函数不能返回数组，但是函数**可以返回数组的指针或者引用**，有几个比较能够简化这个问题的方法，最简单的是使用类型别名：    
```
typedef int arrT[10]; 
using arrT = int[10];   //以上两条声明等价
arrT* func(int i);      //func返回一个指向含有10个整数的数组的指针
```    
因为arrT是含有10个整数的数组的别名，因为无法返回数组，因此返回一个数组指针。   
#### 声明一个返回数组指针的函数      
之所以推荐使用别名的方式来进行处理，是因为接下来所举的直接返回固定大小数组指针的例子会揭示这么做真的炒鸡烦。    
和上述例子相同，我们如果想要定义一个返回数组指针的函数，则**数组的维度必须跟在函数名字之后**。然后，函数的形参列表应该优先于数组的维度，这样就造成了函数的形式应该写成如下形式：    
```
Type (*function(parameter_list))[dimension]
```     
实例比如这个没有使用类型别名的func函数：   
```
int (*func(int i))[10];
```     
可以按照以下顺序理解这个声明的含义：   
- func(int i)表示调用func函数时需要一个int类型的实参；
- (*func(int i))表示我们可以对函数调用的结果进行解引用操作；   
- (*func(int i))[10]表示解引用func的调用将得到一个大小是10的数组；    
- int (*func(int i))[10]表示数组中元素是int类型。   
#### 使用尾置返回类型    
C++11标准中还提供了一种方法可以简化上述的func声明方法，就是使用**尾置返回类型**，任何函数都能使用尾置返回，但是对于比较复杂的类型最为有效。比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并且以一个->符号开头，为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto:      
```
//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组   
auto func(int i) -> int(*)[10]
```
#### 使用decltype   
还有一种情况，如果我们知道函数返回的指针指向哪个数组，就可以使用decltype关键字来声明返回类型，例如：    
```
int odd[] = {0, 1, 2, 3, 4};
int even[] = {5, 6, 7, 8, 9};
decltype(odd) *arrPtr(int i)
{
    return (i % 2) ? &odd : &even;
}
```     
decltype表示arrPtr返回类型是一个指针（不应该是一个数组吗），并且该指针所指的对象与odd类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组指针。    
> Tip:值得注意的是，declctype并不负责把数组类型转成对应的指针，所以decltype的结果是个数组，想要表示arrPtr返回指针还需要在函数声明时加一个*符号。    

4. 函数重载：    
定义：**如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载**。（关键词：名字相同、形参不同）    
**重载和const形参**：     
根据前文所说，**顶层const不影响传入该函数的对象** ，一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：   
```
Record lookup(Phone);
Record lookup(const Phone);  

Record lookup(Phone*);
Record lookup(const Phone*);
```    
以上两组都是重复声明，每一组的第二个声明和第一个声明都是等价的。      

另一方面，如果形参是某种类型的指针或者引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时const是底层的：    
```
//对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同   
//定义了4个独立的重载函数
Record lookup(Account&);  
Record lookup(const Account&);   //新函数，用于常量引用

Record lookup(Account*);
Record lookup(const Account*);   //新函数，作用于指向常量的指针
```     
之所以编译不报错的原因是，（**因为是通过是否为底层const来判断**）编译器可以通过实参是否为常量来推断应该调用哪个函数。因为const不能转化为其他类型，所以我们只能把const对象传递给const形参。相反的，因为非常量可以转化为const，所以上面的4个函数都能作用于非常量对象或者只想非常量对象的指针。不过下文中还会介绍，**当我们传递一个非常量对象或者非常量对象指针时，编译器会优先选用非常量版本的函数** 。     

const_cast和重载：     
上文中曾经提过，const_cast在重载函数的情景中最为有用，例如之前的shorterString函数：   
```
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```    
这个函数的参数和返回类型都是const string的引用，我们可以对两个非常量的string实参调用这个函数，但是返回的结果仍然是const string的引用。因此我们**需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用** ，使用const_cast可以做到这一点：   
```
string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1),
    const_cast<const string&>(s2)));
    return const_cast<string&>(r);
}
```    
在这���版本的函数中，首先将它的实参强制转化为对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以将其再转换为一个普通的string&，这显然是安全的。     

#### 调用重载函数        
调用重载函数时需要进行函数匹配，也叫重载确定。当调用重载函数时可能有三种结果：    
- 编译器找到了一个与实参的最佳匹配；
- 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误；   
- 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时就会发生**二义性调用** ；

### 重载和作用域：    
重载对于作用域的一般性质并没有什么改变，如果在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名：   
```
string read();    
void print(const string&);
void print(double);  //重载print函数
void fooBar()
{
    bool read = false;  //新作用域：隐藏了外部的read
    string s = read();  //错误：read是一个bool值
    //通常来说，在局部作用域中声明函数不是一个好的选择    
    void print(int);    //新作用域：隐藏了之前的print
    
    print("Value:");    //错误：print(const string &)被隐藏    
    print(ival);        //正确：当前print(int)可见
    print(3.14);        //正确，虽然调用的print(int)把print(double)屏蔽掉了
}
```     
说白了就是：**一旦编译器在局部找到了外部有的同名函数，将会屏蔽外面所有的同名函数**。    
> Tip：在C++语言中，名字查找发生在类型检查之前。   
5. 特殊用途的语言特性：   
- 默认实参：这个已经很熟了
- 内联函数和constexpr函数：    
> 使用内联函数的原因在于：调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。      
内联函数的作用就在于，在每个调用节点上采取类似inline的方式“内联的”展开。例如之前的shorterString函数，一般调用：   
```
cout << shorterString(s1, s2) << endl;
```    
将会在编译过程中展开为以下形式：   
```
cout << (s1.size() < s2.size() ? s1 : s2) << end;
```    
而创建内联函数只需要在函数一开始加上inline就可以。   
一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。    

- constexpr函数：指的是能用于常量表达式的函数。其和其他函数相比并没有特殊之处，不过需要遵守几项规定——首先函数的返回类型和所有形参都必须是字面值类型，而且函数体中只能有且只有一条return语句：   
```
constexpr int new_sz() {return 42;}
constexpr int foo = new_sz();  
```    
执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果只。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。   
constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行操作就行。例如可以有空语句、类型别名、using声明等。   
我们允许constexpr函数返回值并非一个常量：   
```
//如果arg是常量表达式，则scale(arg)也是常量表达式    
constexpr size_t scale(size_t cnt){ return new_sz() * cnt; }    
```    
当scale的实参是常量表达式时，它的返回值也是常量表达式，反之则不然：    
```
int arr[scale(2)];   //正确：sacle(2)是常量表达式    
int i = 2;           //i不是常量表达式   
int a2[scale(i)];    //错误：scale(i)不是常量表达式
```    
编译器会自动检查是否返回的非常量表达式会用到只能接受常量表达式的场合中，如果有错误，则会报错。     

> Tip: 内联函数和constexpr函数一般都定义在头文件内，这是由于其可以定义多次（而每个定义又必须完全一致）决定的。     

#### 调试帮助：   
C++程序员往往会用到类似头文件保护（#ifdef .h）的结束，以便有选择的执行调试代码。其基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码，这种方法涉及两种预处理功能：assert和NDEBUG;    
assert预处理宏：     
assert是一种预处理宏，其行为类似一个内联函数，使用一个表达式作为其条件：    
```
assert(expr);
```    
首先对expr求值，若表达式为假（即为0），则assert输出信息并且终止程序的执行。若为真(即非0)，则assert什么也不做。    
和预处理变量一样（#define xxx）一样，**宏名字在程序内必须唯一** 。   
          
NDEBUG预处理变量：    
assert行为依赖于一个名为NDEBUG的预处理变量的状态，如果定义了NDEBUG，则assert什么也不做。默认情况下NDEBUG没有定义，此时assert将会执行检查。     
定义NDEBUG能够避免检查各种条件所需的运行时开销，当然此时根本不会执行运行检查。因此，assert应该**仅用于验证那些不可能发生的事** ，我们可以把assert当成调试程序的一种辅助手段，但是并不能代替真正运行时的逻辑检查，也不能替代程序本身应该包含的错误检查。    
除了用于assert以外，也可以使用NDEBUG编写自己的条件调试代码，如果NDEBUG未定义，将执行#ifndef和#endif之间的代码，如果定义了NDEBUG，则这些代码被忽略：    
```
void print(const int ia[], size_t size)
{
#ifndef NDEBUG
    //__func__是编译器定义的一个局部静态变量，用于存放函数的名字   
    cerr << __func__ << ": array size is " << size << endl;  
#endif
}
```    
编译器为每个函数都定义了__func__，它是const char的一个静态数组，用于存放函数的名字。    
除了__func__，预处理器还预留了4个对于程序调试很有用的名字：    
__FILE__:存放文件名的字符串字面值   
__LINE__:存放当前行号的整形字面值
__TIME__:存放文件编译时间的字符串字面值
__DATE__:存放文件编译日期的字符串字面值
可以使用这些常量在错误消息中提供更多信息，例如在日志中的使用；     

6. 函数匹配：     
几个重载函数经常会出现转换困难的问题，例如：    
```
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
f(5.6);   //调用f(double, double)
```    
那么如何确定候选函数和可行函数呢？候选函数具有两个特征，一是与被调用的函数同名，二是声明在调用点可见。    
第二步就是挑出可行函数，也有两个特征：一是其形参数量和本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。    
经过上面两步，接下来需要考虑实参类型是否与形参匹配。既可能是它们具有相同的类型，也可能是实参类型和形参类型满足转换规则。上述例子中第二个和第四个也是符合的。    
如果到这里还没有决出最后的调用对象，那么需要寻找最佳匹配，下文会介绍这里使用的“最匹配”的细节，它的基本思想，实参类型与形参类型越接近，它们匹配的越好。    
含有多个形参的函数匹配：当实参的数量有两个或者更多时，函数匹配就比较复杂了。例如上面这个例子调用：   
```
f(42, 2.56);
```    
选择可行函数的方法只有一个实参时一样，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。此例中，可行函数包括f(int, int)和f(double,double)。接下来，编译器依次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功：    
- 该函数每个实参的匹配都不劣于其他可行参数的匹配；    
- 至少有一个实参的匹配优于其他可行函数提供的匹配。    
如果在检查了所有实参中没有任何一个函数脱颖而出，则该调用是错误的，编译器将会报二义性的错误。    
上面的调用中，只考虑第一个实参时我们发现函数f(int,int)能精确匹配，要相匹配第二个函数，则int类型必须转化为double类型，显然需要内置类型转换的匹配劣于精确匹配，故就第一个参数而言编译器认为第一个函数胜。    
接着考虑第二个参数，很明显编译器还会认为第二个函数优于第一个函数。    
所以，编译器只能老老实实的报出二义性错误，因为每个可行函数各自在一个实参上实现了更好的匹配。看起来我们似乎可以通过强制类型转换其中一个参数来实现函数的匹配，但是设计良好的系统中，不应该对实参进行强制类型转换。    
> Advice:调用重载函数时应该尽量避免类型转换，如果实际中确实需要强制类型转换，则说明设计的形参集合不合理。     

#### 实参类型转换：    
为了确定最佳匹配，编译器将实参类型到形参类型转换划分为了几个登记，如下所示：   
1) 精确匹配，包括以下情况：    
- 实参类型和形参类型相同；
- 实参从数组类型或函数类型转换为对应的指针类型；   
- 向实参添加顶层const或者从实参中删除顶层const。   
2) 通过const转换实现的匹配；   
3) 通过类型提升实现的匹配；    
4) 通过算数类型转换或者指针转换实现的匹配；   
5) 通过类类型转换实现的匹配；    

分析函数调用前，一般小整形都会提升到int类型或者更大的整形类型。假设有两个函数，一个接受int、另一个接受shrot。只有调用提供的是short类型的值才会选short版本的函数，有时候即使实参是一个很小的整数值，也会直接提升为int类型，此时使用short版本反而会导致类型转换：    
```
void ff(int);
void ff(short);
ff('a');
```    
**所有算数算数类型转换级别都一样，例如从int向unsigned int转换并不比从int向double转换级别高** ，，例如：    
```
void mainip(long);
void mainip(float);
mainp(3.14);   //错误：二义性调用
```    
字面值3.14类型是double，它既能转换为long也能转换为float，因此存在两种可能的算数类型转换，因此该调用具有二义性。      

7. 函数指针：    
函数指针指向的是函数而非对象，和其它指针相同。而和其返回类型无关，和函数名无关。例如：    
```
bool lengthCompare(const string &, const string &);    
```
该函数的类型是bool(const string&, const const string&)。要想声明一个可以指向该函数的指针，只需要用函数替换函数名就可以：    
```
//pf指向一个函数，该函数的参数是两个const string的引用，返回的是bool类型   
bool (*pf)(const string&, const string&); //未初始化的函数指针
```    
> Note:注意，一定要在*pf两端必不可少，如果**不写这对括号，则pf是一个返回为bool指针的函数** 。   
     
当我们把函数名作为一个值使用时，该函数会自动的转化为指针，例如：    
```
pf = lengthCompare;   //pf指向名为lengthCompare的函数
pf = &lenghtCompare;  //等价的赋值语句：取地址符是可选的    
```
此外可以直接使用指向函数的指针调用该函数，无需提前解引用指针：   
```
bool b1 = pf("hello", "goodbye");    //调用lengthCompare函数   
bool b2 = (*pf)("hello", "goodbye"); //等价调用    
```    
在往不同函数类型的指针间不存在转换规则，但是和往常一样，我们可以为函数赋一个nullptr或者值为0的整形常量表达式，表示该指针没有指向任何一个函数：   
```
string size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0; //正确
pf = sumLength; //错误：返回类型不匹配
pf = cstringCompare;  //错误：形参类型不匹配
pf = lengthCompare;   //正确：函数和指针类型精确匹配    
```    
重载函数的指针：当我们使用重载函数时，如果定义了指向重载函数的指针，将会通过精准匹配来指定指针调用的哪一个函数：   
```
void ff(int*);
void ff(unsigned int);

void (*pf1)(unsigned int) = ff;
```   
函数指针形参：和数组类型类似，虽然不能定义函数类型的形参，但是形参可以是指向函数类型的指针。此时看上去形参是函数类型，但是实际上是指针：    
```
//第三个形参是函数类型，它会自动地转成指向函数的指针
void useBigger(const string &s1, const string &s2, 
                bool pf(const string&, const string&));
//等价的声明：显式的将形参定义成指向函数的指针
void useBigger(const string &s1, const string &s2, 
                bool (*pf)(const string &, const string &));
```    
我们可以直接把函数当做实参使用，它会自动转化为指针：   
```
//自动将函数lengthCompare转换成指向该函数的指针
useBigger(s1, s2, lengthCompare);    
```    
但是这么写又写的太过于冗长，为了避免如此繁琐，可以利用别名和decltype进行简化：
```
//Func和Func2是函数类型：   
typedef bool Func(const string&, const string &); //这句话的意思是，定一个函数，类似一个函数的声明，下面还需要给出Func的定义
typedef decltype(lengthCompare) Func2;  //等价类型

//FuncP和FuncP2是指向函数的指针
typedef bool (*FuncP)(const string&, const string&);
typedef decltype(lengthCompare) *FuncP2; 
```     
值得注意的是，decltype返回函数类型不会将函数类型自动转换成指针类型（类似数组），因为decltype的结果是函数类型，只有在结果前面加上*才能得到指针。这样可以使用如下的形式重新声明useBigger:   
```
//useBigger的等价声明，其中使用了类型别名
void useBigger(const string&, const string&, Func);
use useBigger(const string&, const string&, FuncP2);
```    
返回指向函数的指针：   
和数组类似，虽然不能返回一个函数，但是可以返回指向函数类型的指针。最简单的方法仍然是使用别名：   
```
using F = int(int*, int); //F为函数类型，不是指针
using PF = int(*)(int*, int); //PF为指针类型
```     
必须注意的是，**和作为函数类型的形参不一样，返回类型不会自动转换成指针**，我们必须显式的将返回类型定义为指针：    
```
PF f1(int);    //正确：PF是指向函数的指针，f1返回指向函数的指针
F f1(int); //错误：F是函数类型，不能返回一个函数类型
F *f1(int);   //正确：显式的定义返回指向函数的指针    
```    
当然更麻烦的方法就在于用以下的形式声明f1：   
```
int (*f1(int))(int*, int);
```    
以上的类型阅读应该按照由内而外的顺序：我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回了一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此函数指向函数，该函数的返回类型为int。   
另一个最讨喜的方法应该是后置返回类型了：   
```
auto f1(int) -> int(*)(int*, int);
```    
将auto和decltype用于函数指针类型：如果我们明确知道返回函数是哪一个，就能用decltype简化书写函数指针返回类型的过程。假定有两个函数，它们的返回类型都是string::size_type，并且各有两个const string&类型的形参，此时我们可以编写第三个函数，它接受一个string类型的参数，返回一个指针,此指针指向前两个函数中的一个：   
```
string::size_type sumLength(const string&, const string&);
string::size_type largerLength(const string&, const string&);
//根据其形参的取值，getFcn函数返回指向sumLength或者largerLength的指针   
decltype(sumLength) *getFunc(const string &);
```     
唯一需要注意的是，和上面一样，得显式的加上*来表明我们需要返回指针，而非函数本身。    
      
## 第7章 类
类的基本思想是**数据抽象**和**封装**，而数据抽象是一种依赖于**接口**和**实现(implementation)**分离的技术，类的接口包括用户所能执行的惭怍，类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。    
封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现的部分。    
类想要实现数据抽象和封装，首先需要定义一个抽象数据类型，在抽象数据类型中，由类的设计者负责思考类的实现过程；使用该类的程序员只需要抽象的思考类型做了什么，而无需了解类型的工作细节。    

### 7.1 定义抽象数据类型   
我们在第一章当中的Sales_item类是一个抽象数据类型，我们通过它的接口来使用一个Sales_item对象，我们不能通过访问Sales_item对象的数据成员，实际上，我们连这个类有哪些数据成员都不太知晓。    
相反的，Sales_data类就不是一个抽象的数据类型，它能够允许用户直接访问它的数据成员，并且要求 用户来编写操作。要想把Sales_data编程抽象数据类型，我们就需要定义一些操作来供类的用户使用。一旦Sales_data定义了它自己的操作，我们就可以封装（隐藏）它的数据成员了。   
#### 7.1.1 设计Sales_data类
我们的最终目的是令Sales_data支持与Sales_item类完全一样的操作集合。Sales_item类有一个名为isbn的成员函数，并且支持+、=、+=、<<和>>运算符。    
我们将会在接下来的章节介绍如何自定义运算符。现在我们先为这些运算定义普通的函数形式。执行加法和IO的函数我们将会不作为Sales_data的成员，相反的，我们会将其定义为普通的函数；执行复合复制运算的函数是成员函数。Sales_data类无需专门定义赋值运算，其原因会在下文介绍。   
总结至今，有以下功能需要实现：   
- 一个isbn成员函数，用于返回isbn号
- 一个combine成员函数，用于将一个Sales_data对象加到另一个对象上
- 一个名为add的函数，执行两个Sales_data对象的加法
- 一个read函数，将数据从istream读入到Sales_data对象中去   
- 一个print函数，将Sales_data对象的值输出到ostream

##### 使用改进的Sales_data类   
在考虑实现我们的类之前，先看看如何使用以上这些接口函数。举个例子，我们使用这写函数来编写书店程序的另一个版本，转而使用Sales_data对象：   
```
Sales_data total;           
if (read(cin, total)) {  //读入一笔交易
    Sales_data trans;    
    while (read(cin, trans)) {  //读入剩余交易
        if (total.isbn() == trans.isbn())
            total.combine(trans);
        else {
            print(cout, total) << endl;   
            total = trans;
        }
        print(cout, total) << endl;  
} else {
    cerr << "No data?!" << endl;
}
```     
#### 定义改进的Sales_data类   
需要分清接口和类实现的区别，有些除了基础实现的内容，额外的内容需要在类中实现。   
作为接口组成部分的非常远函数，例如add、read和print等，它们的定义和声明都在类的外部。改进的Sales_data类应该如下所示：   
```
struct Sales_data {
    //新的操作对象
    std:string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_pricef() const;

    //旧数据成员
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

//Sales_data的非成员接口函数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &print(std::istream&, Sales_data&);
```
> 定义在类内部的函数是隐式的inline函数（例如上文中的isbn()方法）   

#### 定义成员函数——引入this
这里Premier抛出了一个问题，对于isbn函数：   
```
std::string isbn() const { return bookNo; }
```   
如何知道bookNo成员所依赖的对象？   
这里成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如，如果调用``total.isbn()``,则编译器负责把total的地址传递给isbn的隐式形参this,可以等价地认为编译器将该调用重写成了如下的形式：    
```
//伪代码，用于说明调用成员函数的实际执行过程
Sales_data::isbn(&isbn);
```    
其中，调用Sales_data的isbn成员时传入total的地址； 同理，我们当然可以对隐式它的this进行显式的调用，例如：    
```
std::string isbn() const { return this->bookNo; }
```
因此this就是一个**总是指向“这个”对象的常量指针**，C++不会允许this中保存的地址；      

#### 引入const成员函数     
isbn函数的另一个关键之处是紧随参数列表之后的const关键字，**这里const的作用是修改隐式this指针的类型**。     
默认情况下，this类型是指向类类型非常量版本的常量指针，例如在Sales_data成员函数中，this的类型是Sales_data *const。尽管this是隐式的，但是它仍然要遵循初始化规则，意味着默认情况下我们不能把this绑定到一个常量对象上调用普通的成员函数。    
如果isbn是一个普通函数而且this是一个普通的指针参数，那么我们应该把this声明成const Sales_data *const。毕竟，在isbn的函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。    
由于this是隐式的，并且不会出现在参数列表中，所以在哪里将this声明为指向常量的指针就成为必须面对的问题。C++的做法是允许吧const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后的const表示this是一个指向常量的指针，像这样使用const的成员函数称为**常量成员函数（const member function）**。即等价于以下形式：    
```
std::string Sales_data::isbn(const Sales_data *const this)
{
    return this->isbn;
}
```
> Tip: 常量对象，以及常量对象的引用或者指针都只能调用常量成员函数；
    
#### 定义一个返回this对象的函数    
函数combine的设计初衷类似于复合赋值运算符+=，调用该函数的对象代表的是赋值运算符左侧的运算对象，右侧运算对象则通过显式的实参被传入函数：    
```
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
    units_sold += rhs.units_sold; 
    revenue += rhs.revenue;
    return *this;
}
```     
当我们的交易处理程序调用以下函数：    
```
total.combine(trans);  //更新变量total当前的值
```    
该函数最值得关注的部分是它的返回类型和返回语句。*一般来说，当我们定义的函数类似某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左侧运算对象当成左值返回*，因为为了与它保持一致，combine函数必须返回引用类型，因为此时的左侧运算对象是一个Sales_data的对象，所以返回类型应该是Sales_data&。（简单来说，传统运运算符就是返回左值的引用）     
     
### 7.1.3 定义类相关的非成员函数
类的作者常常需要定义一些辅助函数，例如add、read和print，尽管这些函数定义的操作从概念上来说属于类的接口部分，但是它们实际上并不属于类本身。    
> Tip: 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。    
#### 定义read与print函数   
```
//输入的信息包含ISBN、售出总数和售出价格
istream &read(istream &is, Sales_data& item)
{
    double price = 0;
    is >> item.bookNo >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}
ostream &print(ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
        << item.revenue << " " << item.avg_price();
    return os;
}
```
以上代码有两点值得注意，第一，read和print分别接受一个各自IO类型的引用作为其参数，这是因为IO类属于不能够被拷贝的类型，因此我们只能通过引用来传递它们。而且，因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通饮用，而非对常量的引用。    
第二点，print函数不负责换行。一般来说，执行输出任务的函数应该尽量减少对格式的控制，这样可以由用户确定是否换行。     
#### 定义add函数    
add函数与combine函数略有区别，它是接受两个Sales_data对象作为参数，返回的是一个新的Sales_data，用于表示前两个对象的和：    
```
Sales_data add(const Sales_data &lhs, const Sales_data &rhs)
{
    Sales_data sum = lhs;   
    sum.combine(rhs); 
    return sum;
}
```    

### 7.1.4 构造函数    
每个类都分别定义了它的对象被初始化的方式，类通过一个或者几个成员函数来控制其对象的初始化过程，这些函数叫做**构造函数(Constructor)**。 构造函数的任务是初始化对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。    
构造函数非常复杂，接下来会在多个章节接触到关于构造函数的知识。当然，我们从最简单的开始。构造函数名字与类名相同，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。类可以包含多个构造函数，类似重载函数，不同的构造函数必须在参数数量或者参数类型上有所区别。    

#### 合成的默认构造函数    
先前的total和trans没有构造函数，那么它们是如何初始化的呢？我们没有为这些对象提供初始值，因此我们知道他们执行了默认初始化。类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做**默认构造函数**，默认构造函数无需任何实参。    
如我们缩减，默认构造函数在很多方面都有其特殊性，其中之一就是，如果我们的类没有显式的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。    
编译器创建的构造函数又被称为**合成的默认构造函数(synthesized default constructor)**。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：
- 如果存在类内初始值，用它来初始化成员；
- 否则，默认初始化该成员；    
例如Sales_data为units_sold和revenue提供了初始值，所以合成的默认构造函数将使用这些值来初始化对应的成员；同时，它把bookNo默认初始化为一个空字符串。    
#### 某些类不能依赖于合成的默认构造函数     
合成的默认构造函数只适合非常简单的类。对于一个普通的类来说，必须定义其默认构造函数，原因有三：    
1. 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。这条规则的依据是——如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。    
> Tip: 只有当类没有声明任何构造函数，编译器才会自动地生成默认构造函数（这一点挺有意思，这意味着一旦有一个构造函数，就不会支持默认的构造函数）    
2. 第二个原因在于，对于某些类来说，能合成的默认构造函数可能执行错误的操作。例如之前介绍的，如果定义在块中的内置类型或复合类型（例如数组和指针）的对象被默认初始化，那么它们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。*因此，含有内置类型或者复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数*，否则，用户在创建类对象时就可能得到未定义的值了。   
> Warning: 如果类包含有内置类型或者复合类型的成员，则只有当这些成员全部被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。    
(以上的这个问题在之前编程中很常见，例如使用一个vector是必须是每个对象必须有实例化的能力，即有默认构造函数)     
3. 编译器有时候不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员并且整个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类来说，我们必须自定义默认构造函数，否则该类讲没有可用的默认构造函数。     
##### 定义Sales_data的构造函数    
对于我们Sales_data类来说，我们将使用下面的参数定义4个不同的构造函数：    
- 一个istream&，从中读取一条交易信息；   
- 一个const string&,表示ISBN编号；一个unsigned，表示售出的图书数量；以及一个double，表示图书的售出价格。    
- 一个const string&, 表示ISBN编号；编译器将赋予其他成员默认值；   
- 一个空参数列表（即默认构造函数），这样得到：   
```
struct Sales_data {
    //构造函数
    Sales_data() = default;
    Sales_data(const std::string &s) : bookNo(s) {}
    Sales_data(const std::string &s, unsigned n, double p) : 
                bookNo(s), units_sold(n), revenue(p * n) {}
    Sales_data(std::istream &);

    //之前已有的其他成员……
};
```
##### =default的含义   
形如``Sales_data() = default;``首先明确一点，因为该构造函数不接受任何实参，所以它是一个默认构造函数。我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数，我们希望这个函数的作用完全等同于前面提到的合成默认构造函数。    
在C++11标准中，如果我们需要默认行为，那么可以通过在参数列表后面写上``=default``来要求编译器生成构造函数。其中=default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，在内部则是内联，在外部则不是内联。    
##### 构造函数初始值列表     
接下来我们介绍类中定义的两个构造函数：    
```
Sales_data(const std::string &s) : bookNo(s) {}
Sales_data(const std::string &s, unsigned n, double p) : 
            bookNo(s), units_sold(n), revenue(p * n) {}
```    
按照以上形式，出现的新的部分包含了冒号后的部分以及花括号之间的代码，其中花括号定义了空的函数体。我们吧冒号后的内容称为**构造函数初始值列表（constructor initialize list）**,它负责为新创建的一个或者几个数据成员赋初值。构造函数初始值时成员名字的一个列表，每个名字后面紧跟括号括起来（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。     
只有一个string类型参数的构造函数使用这个string对象初始化bookNo，对于units_sold和revenue则没有显式地初始化。当某个数据成员被构造函数初始值列表被忽视时，它将以与合成默认构造函数相同的方式隐式初始化。在此例中，这样的成员使用类内初始值初始化，因此只接受一个string参数的构造函数等价于：    
```
Sales_data(cosnt std::string &s) : 
            bookNo(s), units_sold(0), revenue(0) {}
```     
> Advice: 构造函数不应该轻易的覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。     
##### 在类外部定义构造函数     
与其它构造函数不同，以istream为参数的构造函数需要执行一些实际的操作。   
```
Sales_data::Sales_data(std::istream &is)
{
    read(is, *this); 
}
```
构造函数没有返回类型，所以上述定义从我们指定的函数名字开始，和其他成员函数一样，当我们在类外定义构造函数时，必须指明该构造函数是哪个类的成员。因此，Sales_data::Sales_data的含义是我们定义Sales_data类的成员，它的名字是Sales_data，所以其是一个构造函数；    
这个构造函数没有构造函数初始值列表，或者说的更明确一点，它的构造函数初始值列表示空的，但是由于执行了构造函数体，所以对象的成员仍然能够被初始化。    
这里使用了*this来把this对象作为引用实参传递给read函数。    

### 拷贝、赋值与析构    
除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。对象在几种情况下会被拷贝，例如初始化变量以及以值的方式传递或者返回一个对象等。当我们使用了赋值运算符时都会发生赋值操作。当对象不再存在时执行销毁的操作，比如一个局部对象会在创建它的块结束时被销毁，当vector对象销毁时其存储在其中的对象也会被销毁。    
如果我们不主动去定义这些操作，那么编译器会替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。     
#### 某些类不能依赖合成的版本     
尽管编译器能够替我们合成拷贝、赋值和销毁的操作，但是必须要清楚一点，对于某些类来说合成的版本无法正常工作，特别是当类需要分配对象之外的资源时，合成的版本会常常是小。举个例子，接下来会介绍C++是如何分配和管理动态内存的，而我们会看到，管理动态内存的类通常不能依赖于上述操作的合成版本。    
不过值得注意的是，很多需要动态内存的类能（而且应该）使用vector对象或者string对象管理必要的存储空间，使用vector或者string类能够避免分配和释放内存带来的复杂性。    
进一步讲，如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版本能够正常工作。当我们对含有vector成员的对象执行拷贝或者赋值操作时，vector类会设法拷贝或者赋值成员中的元素。当这样的对象被销毁时，将销毁vector对象，也就是依次销毁vector中的每一个元素，这一点与string非常类似。    

## 7.2 访问控制与封装     
C++语言中，使用**访问说明符（access specifiers）加强类的封装性**：    
- 定义在public说明符之后的成员可以在整个程序内被访问，public成员往往定义类的接口；
- 定义在pirvate说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，即private封装（或者说隐藏了）类的实现细节；    
一个类中对于访问说明符的出现次数并没有规定，反正只要从出现开始，就开始了这个说明符有效范围一直持续到下一个说明符或者结尾。     
#### 使用class或struct关键字    
两种形式的定义其实仅仅是形式上的区别，唯一的区别是：**struct和class默认访问权限不太一样**。class是pricate，struct是public。    

### 7.2.1 友元    
上文中，我们把Sales_data的数据成员变成了private的，那么read、print和add函数也就无法正常编译了，因为尽管这几个函数是该类接口的一部分，但是它们并不是类的成员。    
类因此提出了友元的概念，一个类可以允许其他类或者函数访问它的非公有成员，方法是将其它类或者函数添加为友元（frined）。如果类想要把一个函数作为他的友元，只需要增加一条以friend关键字开始的函数声明即可：    
```
class Sales_data {
    friend Sales_data add(const Sales_data&, const Sales_data&);
    friend std::istream &read(std::istream&, Sales_data&);
    friend std::ostream &print(std::ostream&, const Sales_data&);

    //接下来声明照旧……
};
```
友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限，不过一般来说，最好在类开始或者结束的时集中声明友元。      
> Tip: 友元不是类的成员，也不受它所在区域访问控制级别的约束。     

## 7.3 类的其他特性    
### 7.3.1 类成员再探
我们定义一对相互关联的类，分别为Screen和Window_mgr。    
#### 定义一个类型成员    
Screen表示显示器中的一个窗口，每个Screen包含一个用于保存Screen内容的string成员和三个string::size_type类型的成员，它们分别表示光标的位置以及屏幕的高和宽。   
除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其它成员一样存在访问限制，可以是public或者private中的一种：  
```
class Screen {
public:
    typedef std::string::size_type pos;
private: 
    pos cursor = 0; 
    pos height = 0, width = 0;
    std::string contents;
};
```     
关于pos的声明有两点需要注意，首先使用了typedef，当然我们可以等价的使用新标准的类型别名：    
```
using pos = std::string::size_type;
```    
其次，用来定义类型的成员必须先定义后使用，这一点和普通成员函数有所区别（后文中会介绍），因此类型成员通常出现在类开始的地方。    

#### Screen类的成员函数
为了使类更加使用，还需要添加一个构造函数来使用户能够定义屏幕的尺寸和内容，以及其他两个成员分别负责移动光标和读取给定位置的字符：   
```
class Screen {
public: 
    typedef std::string::size_type pos;
    Screen() = default; //因为Screen有另一个构造函数，所以本函数必须
    //cursor被其类内初始值初始化为0
    Screen(pos ht, pos wd, cahr c) : height(ht), width(wd), contents(ht *wd, c) {}
    char get() const { return contents[cursor]; } //隐式内联
    inline char get(pos ht, pos wd) const;  //显示内联
    Screen &move(pos r, pos c);             //能在其后设置为内联

privaet: 
    pos cursor = 0; 
    pos height = 0, width = 0;
    std::string contents;
};
```
如上文所示，因为定义了一个三参数的构造函数，我们也必须要提供一个=default的默认构造函数。    
#### 令成员作为内联函数    
类内类外同样能显示的定义内联函数（内联函数的定义有灵活性）：    
```
inline Screen &Screen::move(pos r, pos c) //定义处指定
{
    pos row =  r * width;
    cursor = row + c;
    return *this;
}

char Screen::get(pos r, pos c) const  //类声明时指定
{
    pos row = r * width;
    return contents[row + c];
}
```
虽然在定义和声明的地方都说明inline是完全合法的，但是一般只在类外部定义时说明inline，这样更容易理解。    

#### 可变数据成员    
有时候（但是不频繁）会发生这种情况，**我们希望能够修改类的某个数据成员，即使是在一个const成员函数内**。可以通过在变量的声明中加入mutable关键字来做到这点。    
一个可变数据成员（mutable data member）永远不会是const，即使是const对象中的成员。因此一个const成员函数可以改变一个可变成员的值。例如，我们给Screen添加一个名为access_ctr的可变成员，来追踪每个Screen成员函数被调用了多少次：    
```
class Screen {
public: 
    void some_member() const;
private: 
    mutable size_t access_ctr; //即使在一个const对象内也能被修改
    //......
};

void Screen::some_member() const
{
    ++access_ctr;
}
```    

#### 类数据成员的初始值    
在定义好Screen类之后，我们将继续定义一个窗口管理类并用它表示显示器上的一组Screen。这个类将包含一个Screen类型的vector，每个元素表示一个特定的Screen。默认情况下，我们希望Window_mgr类开始时总是拥有一个默认初始化的Screen。在C++11标准中，最好的方式就是把这个默认值声明为一个类内初始值：    
```
class Window_mgr {
private: 
    std::vector<Screen> screens{Screen(24, 80, ' ')};
};
```
> Tip： 当提供一个类内初始值时，必须以=或者花括号表示。    

#### 7.3.2 返回*this的成员函数    
```
class Screen {
public:  
    Screen &set(char);
    Screen &set(pos, pos, char);
    //......
}

inline Screen &Screen::set(char c)
{
    contents[cursor] = c;   //设定当前光标所在位置为新值
    return *this;           //将this对象当做左值进行返回
}
inline Screen &Screen::set(pos r, pos col, char ch)
{
    contents[r * width + col] = ch;
    return *this;
}
```    
为什么要刻意返回引用而非对象呢？原因在于，如果需要进行类似的连续操作：   
```
myScreen.move(4, 0).set('#');
```
那么，不使用引用的后果就是只最后改变了副本而非对象本身。    
#### 从const成员函数返回*this    
所以稍微有点点新的冲突发生了，如果我们定义了一个新的display函数用于显示，我们令其为const成员，而此时返回的this将会变成一个常量指针，那么再执行以下操作就会引发错误：   
```
myScreen.display(cout).set('*');
```    
这个例子总体就是提醒我们const成员函数返回的*this将会是常量引用。   
#### 基于const的重载    
通过区分成员函数是否为const，我们可以对其进行重载，其原因和我们之前说判断指针参数是否指向const而重载函数的理由差不多，具体说来，因为非常量版本的函数对于常量对象不可用，所以我们只能在一个常量对象上调用const函数。另一方面，虽然非常量对象调用常量版本或者非常量版本都可以，但是很明显调用非常量版本是一个更好的选择。    
这里我们将会定义一个do_display的私有函数，用它来负责实际的打印Screen的操作，所有的display操作都会调用这个函数，然后返回执行的对象： 
```  
class Screen {
public:   
    Screen &display(std::ostream &os)
    {
        do_display(os); return *this;
    }
    const Screen &display(std::ostream &os) const 
    {
        do_display(os); return *this;
    }
private:
    //该函数负责显示Screen的内容
    void do_display(std::ostream &os) const {os << contents;}
};
```
这里透露的信息是，当一个成员调用另一个成员时，this指针会在中间隐式的传递。例如非常量版本传递了非常量的this，而常量的恰恰相反。最后合法的调用就变成了：      
```
Screen myScreen(5, 3);
const Screen blank(5, 3);
myScreen.set('#').display(cout);    //调用的非常量版本
blank.display(cout);                //调用的常量版本
```   
> Important Advice: 为什么要在私有函数中再定义一个小的do_display函数？这是因为：   
> - 避免在多处使用同样代码；
> - 我们预期随着类规模的发展，display函数可能会变得更加复杂，此时把功能相同的操作写在一处而非两处就很有用了；   
> - 我们可能在do_display中添加某些调试信息，但是这些信息会在最终的发布版本中去掉。显然只在do_display中对其进行添加或者删除会方便很多。   
> - 额外的函数调用不不会增加开销，尤其是我们还使用了隐式的内联函数来定义do_display。   
> 实践中，设计良好的C++代码通常包含大量类似do_display的小函数；    

### 7.2.3 类类型
每个类定义了唯一的类型，**即使两个类的成员完全一样，这两个类也是完全不同的类型**。   
我们可以把类名作为类型的名字使用，从而直接指向类类型。或者我们可以把类名跟在关键字class或者struct后面：    
```
Sales_data item1; 
class Sales_data item1;  //等价声明
```   
就是下面这种声明方式从C语言继承而来，不是那么常用罢了。    

#### 类的声明    
经常在各种程序中看到光秃秃的声明一个类名：    
```
QT_BEGIN_NAMESPACE
class Screen;
QT_END_NAMESPACE
```    
这种声明就是**前向声明**，在它定义后，该类只是一个不完全类型，编译器完全不了解其包含了哪些成员，所以，这决定了它使用的场景是有限的：**只能定义指向这种类型的指针或者引用，或者以指针或者引用作为返回类型的函数**。    
当然，另一种特殊的应用就在于，一个类虽然在定义时不能在自身成员函数中定义自己，但是一旦一个类的名字出现过后，它就会被认为是声明过了，因此类允许包含指向它自身类型的引用或者指针(就像数据结构的Node一样)：    
```
class Link_screen {
    Screen window;
    Link_screen *next;
    Link_screen *prev;
};
```    

### 7.3.4 友元再探    
除了先前提到的非成员函数可以定义成友元，也可以定义友元类，也可以定义某个类的某个成员函数为友元（必须编译器之前已经定义过）。此外，友元函数本身还能够定义在类的内容，而且这样也是隐式内联的。    
#### 类之间的友元关系    
例如我们的Window_mgr类有一个clear函数，想要把指定的Screen清空，那么需要把Window_mgr设定为友元：   
```
class Screen {
    friend class Window_mgr;
};
```    
这样，友元类的成员函数可以访问包含该类非公有成员在内的全部成员，因此Window_mgr的clear方法实现如下：   
```
class Window_mgr {
public: 
    using ScreenIndex = std::vector<Screen>::size_type;
    void clear(ScreenIndex);

private: 
    std::vector<Screen> screens{(Screen(24, 80, ' '))};
};

void Window_magr::clear(ScreenIndex i)
{
    Screen &s = screens[i];
    s.contents = string(s.height * s.width, ' ');
}
```    
值得注意的是，**友元并不具有传递性**，即如果Window_mgr有它自己的友元，这些友元并不能理所当然的访问Screen的全部成员。（每个类负责控制自己的友元类或者友元函数）   
#### 令成员函数作为友元   
显而易见的，可以模仿上面的形式，定义成这样来实现成员函数是友元函数：   
```
class Screen {
    friend void Window_mgr::clear(ScreenIndex);
};
```    
但是稍微需要注意的是，这样对程序结构也提出了一定的要求：   
- 首先定义Window_mgr类，并声明clear函数，但不能定义；
- 接下来声明定义Screen，包括对clear的友元声明；    
- 最后定义clear,此时它才可以使用Screen的成员；     

## 7.4 类的作用域    
我们经常说namespace命名空间，但是很少谈及**类本身就是一个作用域**，比较明显的例子就例如上面的ScreenIndex类，即使clear函数中未曾定义，但是编译器已经知道它属于Window_mgr类作用域中。**另一个例子是，我们通常在cpp文件（即类的声明之外）定义类成员函数的内容，那么这样就不能单纯的使用Screen，而要指明其类型属于哪个类**，例如：
```
class Window_mgr {
public:   
    ScreenIndex addScreen(const Screen&);
};

Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s)
{
    screen.push_back(s);
    return screens.size() - 1;
}
```    

### 7.4.1 名字查找与类的作用域    
到目前为止，名字查找过程比较简单，趋向于先从所在块中找声明语句，再逐渐到外层，如果一直没找到，则报错。    
对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别。类的定义分两步处理：    
- 首先，编译成员的声明；   
- 直到类全部可见后才编译函数体；    

注意：尽管类内类外声明同名变量遵循所谓的覆盖原则，类型名是不可以在类内类外同名定义的。    
同样可以运用作用域运算符访问::，例如：   
```
void Screen::dummy_fcn(pos height) {
    cursor = width * ::height;  //是全局的那个
}
```    

## 7.5 构造函数再探    
### 7.5.1 构造函数初始值列表
类对象的成员初始化为啥要用初始化列表？原因在于不这样去做几乎就等价于二次赋值了：   
```
Sales_data::Sales_data(const string &s, unsigned cnt, double price)
{
    //这种写法没有问题，但是比较草率：没有使用构造函数初始值
    bookNo = s;
    units_sold = cnt;
    revenue = cnt * price;
}
```
#### 构造函数的初始值有时候必不可少    
大部分情况我们能忽略输出成员初始化和赋值之间的差异，但是并非总能这样。如果成员是const或者引用的话，也必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化，例如：    
```
class ConstRef {
public: 
    ConstRef(int ii);
private:
    int i;
    const int ci;
    int &ri;
};
```
如果我们在构造函数中不给它们提供初始值，就会发生错误：   
```
ConstRef::ConstRef(int ii)
{
    i = ii;
    ci = ii;   //错误
    ri = i;    //错误
}
```   
正确的方式是：   
```
ConstRef::ConstRef(int ii) : i(ii), ci(ii), ri(i) {}
```
总而言之，如果成员是const、引用或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表来为这些函数提供初始值。   
> Advice: 在很多类中，初始化和赋值的区别会影响底层效率：前者直接初始化数据成员，后者则属于先初始化再赋值（脱裤子放屁）。   
> 此外除了效率问题外，有些数据成员必须要被初始化，所以一定建议大家养成使用初始值列表的构造函数书写方式。    

#### 成员初始化的次序    
令人稍感意外的是，构造函数初始值列表只用于说明用于初始化成员的值，**而不会限定初始化的具体执行顺序**，真正的初始化顺序是由它们在类定义中出现的顺序一致。这一点通常不会有啥毛病，但是如果遇到一个成员是用另一个成员初始化，那么这两个的定义顺序就要考究一点了：   
```
class X {
    int i;
    int j;
public: 
    X (int val) : j(val), i(j) {} //i的值是不定的
};
```
比较人性化的编译器，会在初始值列表顺序和声明顺序不一致的时候给个警告。平时编程最好令构造函数初始值顺序和成员声明的顺序保持一致，而且尽量避免使用某些成员初始化其他成员。   

#### 默认实参和构造函数   
一个构造默认构造函数比较通常的思路，就是使用带默认实参的构造函数：   
```
Sales_data (std::string s = "") : bookNo(s) {}
```  
如果一个构造函数为所有参数都提供了默认实参，那么它实际上也定义了默认构造函数；   

### 7.5.2 委托构造函数   
C++11新标准提出委托构造函数，可以使用其它构造函数来完成自己的初始化过程，或者说它把它部分（或全部）职责委托给了其它构造函数。   
那样，我们可以重写Sales_data的构造函数为：   
```
class Sales_data {
//非委托构造函数使用对应实参来初始化成员   
Sales_data(std::string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt * price){}
//其余构造函数均委托给另一个构造函数   
Sales_data() : Sales_data("", 0, 0){}
Sales_data(std::string s) : Sales_data(s, 0, 0) {}
Sales_data(std::istream &is) : Sales_data() {read(is, *this);}
};
```   

### 7.5.3 默认构造函数   
当对象被默认初始化或者值初始化时自动执行默认构造函数，在以下情况发生：   
- 当我们再块作用域内不使用任何初始值来顶一个非静态变量或者数组；
- 当一个类本身含有类类型成员，并且使用合成的默认构造函数时；
- 当类类型成员没有在构造函数初始值列表中显式的初始化时；    
值初始化则发生在：   
- 在数组初始化过程中我们提供的初始值数量小于数组大小时；
- 当我们不使用初始值定义一个局部静态变量时；
- 当我们通过书写形如T()的表达式显式地请求值初始化时，其中T是类型名；   
上述情况都还算好判断，不过有些情况会比较晦涩难发现缺少默认构造函数，例如：
```
class NoDefault {
public: 
    NoDefault(const std::string&);
    //..
}
strct A {
    NoDefault my_mem;
};
A a;  //错误：不能给A合成构造函数
struct B {
    B() {} //错误：b_member没有初始值
    NoDefault b_member;
};
```   

### 7.5.4 隐式的类类型转换   
同C++内置类型的隐式转换，我们也能为类定义隐式转换定义。如果构造参数只接受一个实参，其实也就定义了该类类型隐式转换机制，有时候我们把它称作为**转换构造函数**。
实际上上文中，接受单个string 的构造函数和接受单个istream的构造函数已经分别定义了各自想Sales_data隐式转换的规则，也就是说，**在需要使用Sales_data的地方，我们可以使用string或者istream作为替代**：   
```
string null_book = "9999";
item.combine(null_book);
```    
但是几点原则需要注意：  
- 只允许一步转换：例如如果我们直接写``item.combine("9999");``就会报错，为啥，因为只允许一步转换，所以如果要合法必须手动写为``item.combine(string("9999"))``;
- 类类型转换未必总有效；   

#### 抑制构造函数的隐式转换    
在要求隐式转换的上下文中，我们可以将构造函数加**explicit**加以阻止：   
```
class Sales_data {
public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p * n) {}
    explicit Sales_data(cosnt std::string &s) : bookNo(s) {}
    explicit Sales_data(std::istream&);   
};
```   
那么这时候，就没法儿用任何构造函数隐式的构造Sales_data对象，之前的两种方法就无法通过编译：   
```
item.combine(null_book);  //错误
item.combine(cin);  //错误
```
注意，关键字explicit**只对一个实参的构造函数有效**，需要多个实参的构造函数不嗯呢该用于执行隐式转换，所以无需将其指定为explicit。而且，**只需要在声明处**指定就可以，不应该在定义时重复写出：
```
//错误
explicit Sales_data::Sales_data(istream& is)
{
    read(is, *this);
}
```   

#### explicit构造函数只能用于直接初始化   
另一个explicit构造函数的特殊之处在于不能够使用拷贝形式初始化，而只能直接初始化，例如：   
```
Sales_data item1(null_book); //正确：直接初始化
Sales_data item2 = null_book; //错误：不支持拷贝形式初始化；   
```   

#### 为转换显式地使用构造函数    
另一个避免隐式转换错误的好方法，当然也是最傻的，就是强制类型转换：   
```
item.combine(Sales_data(null_book));
item.combine(static_cast<Sales_data>(cin));
```   

> 我们接触的一些标准库中有单参数构造函数的：string接受一个const char*参数的不是explicit的函数；
> 接受一个容量参数的vector构造函数是explicit的；    

### 7.5.5 聚合类   
**聚合类**是的用户可以直接访问其成员，并且拥有特殊的初始化语法形式。当一个类满足以下条件时，我们称之为聚合的：   
- 所有成员都是public的；
- 没有定义任何构造函数；
- 没有定义任何类内初始值；
- 没有基类，也没有virtual函数（后面会介绍）   
例如下面就是个聚合类： 
```
struct Data { 
    int val;
    string s;
};
```   
聚合类的初始化可以使用一个花括号括起来的成员初始值列表，并且用它初始化聚合类的初始化成员：    
```
Data val1 = { 0, "Anna"};
```    
初始值的顺序必须与声明的顺序一致。但是稍微注意的是，显式的初始化对象成员存在三个明显的缺点：   
- 要求所有成员都是public的；
- 将正确初始化每个对象的重任交给了类的用户；因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，这样的初始化过程冗长而且易出错；   
- 添加或者删除一个成员后，所有初始化语句都需要更新；   

### 7.5.6 字面值常量类    
之前有提到过,constexpr的参数和返回值必须是字面值类型。除了算数类型、引用和指针外，**某些类也是字面值类型**。和其他类不同，字面值类型的类可能含有constexpr成员函数，这样的成员必须符合constexpr函数的所有要求，它们是隐式const的。   
**数据成员都是字面值类型的聚合类是字面值常量值**。如果一个类不是聚合类，但是它符合以下要求，则它也是一个字面值常量类：    
- 数据成员都必须是字面值类型；   
- 类必须至少含有一个constexpr构造函数；   
- 如果一个数据成员含有类内初始值，则内置类型初始值必须是一条常量表达式；或者如果成员属于某种类类型，初始值则必须使用自己的constexpr构造函数；    
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象；   

#### constexpr构造函数     
尽管构造函数不能const（构造函数本来就是设计出来改变类的），但是字面值常量类构造函数可以是constexpr函数。事实上一个字面值常量类必须至少提供一个constexpr构造函数。   
constexpr构造函数可以声明为=default的形式，否则，constexpr构造函数就必须即符合构造函数的要求，又符合constexpr函数的要求（意味着唯一可执行语句就是返回语句）。综合两点可知，constexpr构造函数体一般来说应该是空的。我们通过前置关键字constexpr就可以声明一个constexpr构造函数：   
```
class Debug {
public: 
    constexpr Debug(bool b = true) : hw(b), io(b), other(b) {}
    constexpr Debug(bool h, bool i, bool o) : hw(h), io(i), other(o) {}
    constexpr bool any() {return hw || io || other; }
    void set_io(bool b) { io = b; }
    void set_iw(bool b) { hw = b; }
    void set_other(bool b) { hw = b;}
private:
    bool hw;     //硬件错误
    bool io;     //IO错误
    bool other;  //其他错误
};
```    
constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。    
constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或者返回类型：   
```
constexpr Debug io_sub(false, ture, false); //调试IO
if (io_sub.any())                           //等价于if(true)
    cerr << "print appropriate error messages" << endl;
constexpr Debug prod(false);                //无调试
if (prod.any())                             //等价于if(fales)
    cerr << "print an error message" << endl;
```

## 7.6 类的静态成员     
类的静态成员出现意义在于**该成员与类本身直接相关，而不是与类的某个对象保持关联**。例如，一个银行账户类可能需要一个数据成员来表示当前的基准利率。这个利率很明显不需要每个账户都要变动，更关键的是，我们希望一旦利率改变，所有对象都能使用新值。    
#### 声明静态成员     
我们通过在成员的声明之前加上static使得其余类关联在一起。和其他成员一样，静态成员可以使public或者private的。静态数据成员的类型可以是常量、引用、指针、类类型等；例子：     
```
class Account {
public: 
    void calculate() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void rate(double);
private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
};
```    
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据相关的数据；因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且被所有Account对象共享。    
类似的，静态成员函数也不和任何对象绑定到一起，**它们不包含this指针**。作为结果，静态成员函数不能声明为const的，而且也不能在static函数体内使用this指针，这一个限制适用于this的显式调用，也对调用非静态成员的隐式使用有效。     

#### 使用类的静态成员
可以直接使用作用域运算符直接访问静态成员：   
```
double r = Account::rate();
```    
虽然今天成员不属于类的某个对象，但是仍然可以用类的对象、引用或者指针来访问，这里不做赘述；   

#### 定义静态成员
和其他成员函数一样，我们既可以在内部也可以在外部定义一个静态成员函数，不能重复static关键字，该关键字只出现在类内部的声明语句：   
```
void Account::rate(double newRate)
{
    interestRate = newRate;
}
```
类内静态变量最特殊之处在于，因为静态数据成员不属于任何一个对象，所以它们并不是在创建类对象的时候被定义的，恰恰相反，我们一般不能在类的内部初始化静态变量，而必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能够定义一次。   
类似于全局变量，静态数据成员定义在任何函数之外，因此一旦它被定义，就存在于程序的整个生命周期之中。   
我们定义静态数据成员的方式和外部定义成员函差不多，指定类型名、类名、作用运算符以及成员自身的名字：    
```
double Account::interestRate = initRate();
```   
有个有意思的事儿是，这句话看似没有指定initRate的范围，但是其实是没有错的，因为从Account::之后指的就是该类内部成员，而此时interestRate为类的内部成员，也可以访问类的私有成员。     

#### 静态成员的内部初始化    
通常情况下，类的静态成员不应该在类的内部初始化，但是我们可以给静态成员提供const整数类型的类内初始值，**不过要求静态成员必须是字面值常量类型的constexpr**。初始值必须为常量表达式（这是因为这些成员本身就是常量表达式），所以它们能用在所有适合于常量表达式的地方，例如我们可以用一个初始化了静态数据成员指定数组成员的维度：   
```
class Account {
public:
    static double rate() {return interestRate;}
    static void rate(double);
    static constexpr int period = 30;  //period是常量表达式
    double daily_tbl[period];
};
```    
> Tip: 即使一个常量静态数据成员在类内部被初始化了，通常情况也应该在类外部定义一下该成员。   

#### 静态成员能够用于某些场景，但是普通成员不能    
例如，静态数据成员可以是不完全类型，特别的，静态数据成员的类型还就可以是它自己所属的类类型，而非静态数据成员则会受到限制，只能声明它自身的引用或者指针：   
```
class Bar {
public:
    //
private: 
    static Bar mem1;   //正确
    Bar *mem2;         //正确
    Bar mem3;          //不正确
};
```   
静态成员和普通成员的另一个区别就在于我么可以使用静态成员作为默认实参：   
```
class Screen {
public: 
    //bkground表示一个类中稍后定义的静态成员
    Screen& clear(char = bkground);
private:
    static const char bkground;
};
```   
非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果就是自己给自己反复调用下套，无法真正提供一个对象以便从中获取成员的值，最终引发错误。   

# 第二部分 C++标准库    

# 第8章 IO库    
## 8.1 IO类
为了支持不同种类的IO处理操作，标准库还规定了一些其他IO类型，其中iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型,sstream定义了读写内存string对象的类型；同时还定义了w开头的宽字符对象来处理宽字符数据，例如wcin、wcout等。    
### 8.1.1 IO对象无拷贝或赋值   
我们不能拷贝或者对IO对象赋值；    
### 8.1.2 条件状态    
IO设置了多种条件状态，用于修正和访问状态。注意，*一个流一旦发生错误，其后续的IO操作都会失败* ，因此最好的办法就是将流每次的结果当做一个条件来使用：    
```
while (cin >> word)
    //ok：继续读……
```    
#### 查询流的状态     
将流作为条件使用，只能知晓流是否有效，但是无法知道具体发生了什么；有时候我们还是需要知道发生了什么的，例如，键入了文件结束标示后我们的应对措施，可能和遇到一个IO设备错误的处理方式是不同的。    
IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。IO类型定义了4个iostate类型的constexpr值来表示特定的位模式，这些值用来表示特定类型的IO条件，可以用与位运算符一起来进行一次性检测或者设置多个标志位：     
- badbit： 表示系统级错误，一旦badbit被置位，流就无法使用了；      
- failbit: 这表示如果被置位，那么流遇到了一个字符错误，但是还可以继续使用；
- eofbit: 尾部标识符。到达尾部时会和failbit一起被置位；
- goodbit: 为0，表示流未发生错误；    
#### 管理条件状态     
流对象的rdstate成员返回一个iostate值，对应流当前状态,setstate操作将给特定的位定条件位置位。clear成员是一个重载的成员，他有一个不接受参数的版本，而另一个版本接受一个iostate类型的参数，前者清除所有错误标志位：     
```
//记住cin当前状态
auto old_state = cin.rdstate();  
cin.clear();
process_input(cin);
cin.setstate(old_state);   //恢复cin状态
```     
至于局部，下面例子将failbit和badbit复位，但保持eofbit不变：    
```
//复位faildbit和badbit，保持其他标志位不变   
cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit); //~取反符号，X & ~X = 0可以作为一个复位的写法
```    

### 8.1.3 管理输出缓冲     
计算机有个特定的机制在于，每个输出流都有一个缓冲区，例如cout一个东西，但是文本串既可能直接打印出来，也可以被保存在缓冲区中，等会儿再打印。这种操作最大的好处是某些系统写入很慢，但是如果能允许操作系统将多个输出操作组合为单一的设备写操作就可以带来很大的性能提升。    
导致缓存区刷新的原因很多：
- mian函数return
- 缓冲区满
- endl操作符
- unitbuf设置流的内部状态，例如cerr是立即刷新的，就是因为cerr是设置unitbuf的
- 一个输出流可能会被关联到另一个流
> Warning:如果程序崩溃，输出缓冲区不会被刷新    

### 关联输入和输出流    
当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输入流。标准库将cout和cin关联到一起，因此下面语句：   
```
cin >> ival;
```    
导致cout的缓冲区被刷新。     
> 交互式系统通常应该关联输入流和输出流，但是这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。    
tie有两个重载版本：一个版本不带参，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是这个流的指针，如果未关联到流，则返回空指针。 tie的第二个版本接受一个指向ostream的指针，将自己关联倒刺ostream。即x.tie(&o)将流x关联到输出流o。   
我们既可以把一个istream对象关联到另一个ostream，也可以讲一个ostream关联到连一个ostream:   
```
cin.tie(&cout);   //可以但是一般不会这么做
ostream *old_tie = cin.tie(nullptr); //cin不再与其它流关联
cin.tie(&cerr); //读取cin会刷新cerr而不是cout
cin.tie(old_tie);  //重建cin和cout间的正常关联
```
每个流最多关联到一个流，但是多个流可以绑定到同一个ostream。     

## 8.2 文件输入输出     
使用ifstream从一个给定文件读取数据,ostream给一个特定文件写入数据，以及fstream可以读写给定文件。    
### 8.2.1 使用文件流对象   
```
ifstream in(ifile);  //构造一个ifstream并打开给定文件
ofstream out;        //输出文件流未关联到任何文件
```    
我们可以用main函数来传递参数指定的：    
```
ifstream input(argv[1]);  //打开销售记录文件
ofstream output(argv[2]); //打开输出文件
Sales_data total;         //保存销售额的总量    
if (read(input, total)){
    Sales_data trans;
    while (read(input, trans)) {
        if (total.isbn() == trans.isbn())
            total.combine(trans);
        else {
            print(output, total) << endl;
            total = trans;
        }
        print(output, total) << endl;
    }
} else
    cerr << "No data?!" << endl;
```
除了读写是命名文件以外，这段程序与229页的加法程序几乎完全一样，虽然read和print定义的时候都是istream&和ostream&，但是我们仍然能够传递fstream的对象。    
#### open和close    
```
ifstream in(ifile);   //构筑一个ifstream并打开给定文件
ofstream out;         //输出文件流未与任何文件关联
out.open(ifile + ".copy");  //打开指定文件

if (out)  //检查是否打开成功
    //执行
in.close(); //一旦文件被打开，再open就会错误，所以需要先close再open
in.open(ifile + "2");
```    
此外fstream的自动析构函数中，会自动调用close()，所以无需担心局部变量未被关闭。   
### 8.2.2 文件模式
每个流都有一个关联的**文件模式**：   
- in: 以读方式打开
- out: 以写方式打开
- app: 每次写操作均定位到文件末尾
- ate: 打开文件后立即定位到文件末尾
- truc: 截断文件    
- binary: 以二进制方式进行IO    
默认情况下，文件会以truc模式打开（out清空先前全部内容，重新指向文件头开始写入）解决问题的方式是使用app模式同时打开：   
```
ofstream app("file2", ofstream::app); //隐含为输出模式
ofstream app2("file2", ofstream::out | ofstream::app);
```        

## 8.3 string流    
sstream定义了三个类型支持string的IO，istringstream、ostringstream、stringstream。    
### 8.3.1 使用istringstream    
当某些工作是对郑航文本处理，而其他一些工作是处理单行内的单个单词，通常可以使用istringstream;     
例如输入一个表格，每行都是一个人带他的几个号码。首先定义一个简单的类来描述输入数据：   
```
struct PersonInfo {
    string name;
    vector<string> phones;
};
```    
我们读取该数据文件，并且在一个循环中反复读取一条记录，提取一个人名和若干号码：   
```
string line, word;
vector<PersonInfo> people;
while (getline(cin, line)) {
    PersonInfo info;
    istringstream record(line);
    record >> info.name;      //这里解释为读到空格截止   
    while (record >> word)
        info.phones.push_back(word);
    people.push_back(info);
}
```    

### 8.3.2 使用ostringstream    
当我们希望一起打印信息时，ostringstream是很有用的。例如我们希望验证每个电话格式，然后进行打印。我们先将所有输出内容“写入”到一个内存ostringstream中：   
```
for (const auto &entry : people) {
    ostringstream formatted, badNums;  //每个循环步创建的对象
    for (const auto &num : entry.phones) {
        if (!valid(nums)) {
            badNums << " " << nums;
        }
        else
        {
            formatted << " " << format(nums);
        }
    }
    if (badNums.str().empty())
        os << entry.name << " " << formatted.str() << endl;
    else
        cerr << "input error:" << entry;
}
```

# 第9章 顺序容器
这章我们首先着重介绍**顺序容器(sequential container)**。    
## 9.1 顺序容器概述：    
顺序容器有很多，但是在不同方面性能又有折中：   
- 向容器添加或从容器中删除元素的代价；
- 非顺序访问容器中元素的代价；   
有以下顺序容器：    
- vector: 可变大小数组；支持随机快速访问，在尾部之外的位置或删除元素变得很慢；   
- deque: 双端队列。支持快速随机访问。在头尾位置插入、删除速度很快；   
- list: 双向链表；只支持双向顺序访问，在list的任何位置插入/删除都很快   
- forward_list: 单向链表。只支持单向顺序访问，在链表的任何位置插入/删除都很快
- array: 固定大小数组，支持快速随机访问，不能添加或者删除元素。   
- string: 与vector类似的容器，但是专门用于保存字符。随机访问快。在尾部插入/删除的速度快。    
#### 确定使用哪种顺序容器    
通常使用vector是最好的选择，以下是一些选择容器的基本原则：    
- 如果有很多小的元素，并且空间的额外开销很重要，不要使用list或者forward_list;
- 若果要求随机访问元素，应该使用vector或者deque；
- 如果程序要求中间插入或者删除元素，应该使用list或者forwardlist；   
- 如果程序需要在头尾位置插入或者删除元素，但是不会在中间插入或者删除，使用dequeue；    
- 如果程序只有在数据读入的时候才需要在容器中间位置插入元素，随后需要随机访问元素：   
首先需要去定是否真的是需要在容器中间添加元素。如果一般要得到有序的序列，应该使用vector添加数据，然后调用标准库的sort函数来重排；   
如果硬要在中间位置插入元素，则考虑在输入阶段使用list，一旦输入完成，将会把list中的内容拷贝到一个vector中。    

## 9.2 容器库概览    
#### 对容器可以保存的元素类型的限制    
虽然我们可以在容器中保存几乎任何类型，但是有些情况需要单独讨论，例如顺序容器有一个版本的构造函数接受容器大小的参数，它就会使用了元素类型的默认构造函数。所以这种类型的容器在构造时不能只传递一个元素数目参数：   
```
//假设noDefault是一个没有默认构造函数的类型   
vector<noDefault> v1(10, init);    //正确：提供了元素初始化器（init是个noDefault类型的值）
vector<noDefault> v2(10);          //错误：必须提供一个元素初始化器
```    

### 9.2.1 迭代器    
这里基本都知道，唯一有些区别的是，forward_list的迭代器不支持递减运算符（--）   
#### 迭代器范围     
这里提到C++的一个重要概念，**左闭合区间**：   
[begin, end)
这里end可以和begin指向相同的位置，但是不能指向begin之前，这反映到迭代器中就是begin()和end()所分别代表的迭代器；    

### 9.2.2 容器类型成员    
我们已经见过几个类型：size_type、iterator和const_iterator;当然其实一般还提供了反向迭代器(reverse_iterator)，如果对一个反向迭代器++，那么会得到上一个元素。    
剩下的就是类型别名。我们可以在不了解元素类型的情况下使用它，例如如果我们需要知道元素类型，我们使用value_type；如果需要元素类型的一个引用，可以使用reference或者const_reference。这样的元素相关的类型别名在**泛型编程**中相当有用，后面我们会介绍它。    
这些类型再使用时，我们必须显式的使用其类名：   
```
list<string>::iterator iter;
vector<int>::difference_type count;
```   

### 9.2.3 begin和end成员    
没啥好说的     

### 9.2.4 容器的定义和初始化    
这里指出，除了array之外，其他类容器的构造函数都支持创建一个指定类型的空容器：   
- C c         使用默认构造函数的空容器；    
- C c1(c2)    c1初始化为c2的拷贝,c1和c2必须是相同的类型；写成C c1=c2也可以；
- C c{a, b, c}或者c = {d, e} 列表初始化   
- C c(iter_b, iter_e) 使用迭代器进行指定范围内的初始化    
顺序容器才支持的初始化：
- C seq(n)    seq包含n个元素；   
- C seq(n, t) seq包含n个初始化为值t的元素；    

这里尤其推荐迭代器初始化的方式，因为这样**可以方便的跨不同顺序容器之间初始化**；    

#### 标准库array具有固定大小    
array最特殊的就在于固定大小，当定义一个array时，除了指定元素类型，还需要指定容器大小：   
```
array<int, 42>      //类型为：保存了42个int的数组
array<string, 10>   //类型为：保存了10个string的数组

array<int, 10>::size_type i; //数组包含了元素类型和大小
array<int>::size_type j;     //错误，因为前者不是一个类型！
```
同时，由于array默认构造特性，它一定是非空的，如果初始化列表数量不够，则会在后面跟着使用默认初始化函数构造到填满array元素：   
```
array<int, 10> ia3 = {42};  //ia3[0]为42，剩余元素为0
```    
有意思的是，虽然array各方面和数组非常像，但是**数组不支持的拷贝或者赋值操作**，在array里行得通：   
```
int digs[2] = {1, 2};
int cpy[2] = digs;
array<int, 10> digits = {1, 2};
array<int, 10> copy = digits;
```    

### 9.2.5 赋值和swap    
赋值运算符可以用于所有的容器，赋值运算符可以把左边容器中的全部元素换成右边容器中元素的拷贝：   
```
c1 = c2;   //不管c1和c2之前大小如何，赋值后大小和数量和c2一模一样
c1 = {a, b, c}; //赋值后，c1大小为3
```   
另一个操作是swap，stl中的调用形式为：   
```
swap(c1, c2); //swap比c2向c1拷贝要快得多
```    
此外还有assign操作，类似迭代器构造函数，例如：   
```
seq.assign(itb, ite);
```    
这里给出一个例子，注意assign同样是对象完全被覆盖：   
```
list<string> names;
vector<const char*> oldstyle;   
names = oldstyle;  //错误：容器类型不匹配    
names.assign(oldstyle.cbegin(), oldstyle.cend());
```    
swap的隐藏陷阱：因为swap是内存数据结构的整体交换，这意味着，（除了string以外）指向容器的迭代器、引用和指针在swap操作之后都不会失效，但时实际上它们已经不属于容器了。当然string的迭代器啥的均已失效。这点尤其要注意，否则很容易出现一些奇怪的bug;    
swap对array是稍有不同的，它是真正的会交换元素，时间和array中元素数量成正比。   
在新标准中，容器既提供了成员函数版本的swap，也提供了非成员版本的swap，而早期的标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的，所以尽量用非成员版本吧~    
    
### 9.2.7 关系运算符     
每个容器都支持==和!=,除了无序关联容器，都支持关系运算符（>、<、>=、<=）,其比较策略类似string的比较。   
> Note:只有当其元素类型定义了相应的比较运算符只有，我们才可以使用关系运算符来比较两个容器；    
     
## 9.3 顺序容器的操作    
### 9.3.1 向顺序容器添加元素    
- push_back/emplace_back: 在c的尾部创建一个值为t或者由args创建的元素，返回void；    
- push_front/emplace_front: 与上面相反，在头部添加；   
- insert(p, t)/emplace(p, args)：在迭代器p指向的元素**前**创建一个值为t或者由args创建的元素，返回指向新添加元素的迭代器；    

> 关键概念——容器元素是拷贝：当我们用一个对象来初始化容器时，实际上放入容器的是对象的一个拷贝，而非对象本身；    

#### 使用insert的返回值    
使用insert的返回值，作用是可以反复的在同一个位置进行插入：   
```
list<string> lst;
auto iter = lst.begin();
while (cin >> word)
    iter = lst.insert(iter, word);
```    

#### 使用emplace操作    
新标准的三个新成员函数——emplace_front、emplace和emplace_back，这些操作构造不是拷贝元素，而是分别将参数擦混递给元素类型的构造函数，并用其直接构造元素，例如：   
```
c.emplace_back("89757", 25, 15.99);
```
其传递的参数类型必须和类型的构造函数类型相匹配；    

### 9.3.2 访问元素    
除了forward_list，包含array在内的顺序容器都有front和back成员函数，来返回首元素和尾元素的引用：   
```
if (!c.empty()) {
    auto val = *c.begin(), val2 = c.front();
    auto last = c.end();
    auto val3 = *(--last); //注意，此处不能递减forward_list的迭代器
    auto val4 = c.back();    
}
```    
这里有两点需要注意：   
1. 迭代器的end一定是指向尾元素后的空元素，为了获取尾元素，必须先递减该迭代器；   
2. 进行任何操作前，需要确保c非空；否则后面的操作都可能是未定义的；    

此外注意，**访问成员函数返回的是引用**：   
```
if (!c.empty()) {
    c.front() = 42;
    auto &v = c.back();
    v = 1024;                //改变了c中的元素
    auto v2 = c.back();
    v2 = 0;                  //未改变
}
```     
#### 下标操作和安全的随机访问    
string、vector、deque和array均提供了下标运算符，我们永远希望下标时合法的，at函数可以略微规避一下类似的风险：    
```
vector<string> svec;   //空vector
cout << svec[0];       //运行错误
cout << svec.at(0);    //抛出一个out_of_range异常
```    

### 9.3.3 删除元素    
- pop_back()、pop_front() 
- erase(p): 
例如：    
```
while (!ilist.empty()) {
    process(ilist.front());  //对ilist的首元素进行一些处理
    ilist.pop_front();       //完成后删除首元素    
}
```    
如果从容器内部删除一个元素，erase既允许我们从指定位置删除元素，也可以删除一对迭代器指定的范围内所有元素，注意：**两种形式的erase都返回的是指向删除的（最后一个）元素之后位置的迭代器**，例如，这边给出了一个循环中删除list中所奇数元素的例子：    
```
list<int> lst = {0, 1, 2, 3, 4, 5};
auto it = lst.begin();
while (it != lst.end())
    if (*it % 2)  //若元素为奇数
        it = lst.erase(it);   //删除此元素，此时指向的是原it的下一个元素
    else
        ++it;
```    
如果要删除多个元素，例如：    
```
elem1 = slist.erase(elem1, elem2); //调用后,elem1 == elem2   
```
迭代器elem1指向我们要删除的第一个元素，而elem2指向我们要删除的最后一个元素之后的位置；     

### 9.3.5 改变容器的大小    
```
list<int> ilist(10, 42);  //10个int，每个值都是42
ilist.resize(15);         //后面跟5个0
ilist.resize(25, -1);     //添加10个-1
ilist.resize(20);         //删除后面20个元素
```    

### 9.3.6 容器操作可能使迭代器失效
这个是很明显的，尤其对于vector这种根据现有体积不断改变固定存储的结构类型；目前来看，vector、stirng或者deque这三种都必须要考虑迭代器、引用和指针失效的问题：   
```
//傻瓜循环，删除偶数元素，复制每个奇数元素   
vector<int > vi = {0~9};
auto iter = vi.begin(); 
while (iter != vi.end()) {
    if (*iter % 2) {
        iter = vi.insert(iter, *iter);  //复制
        iter += 2;                      //向前移动迭代器，跳过当前元素以及出插入到它之前的元素    
    }
    else
        iter = vi.erase(iter);
}
```   
这里最难理解的应该就是插入是在给定迭代器位置之前插入，而返回的是指向新数据位置的迭代器，因此要向后移动两位；而erase已经指向删除后的有效下一位了；       
#### 不要保存end返回的迭代器    
每次我们添加删除vector或者string的元素后，或者deque，原来的end返回的迭代器总会失效。因此我们需要反复调用end()，而不能只是在循环中使用之前end的返回值；C++考虑到这一点做了很多优化，end()操作都特别快的部分原因就在于此；    
例如：   
```
auto begin = v.begin(),
        end = v.end();
while(begin != end)
{
    //操作
    //插入新值，对begin重新复制，否则会失效
    ++begin;  //向前移动begin，因为想在此新元素之后插入元素
    begin = v.insert(begin, 42); //插入新值
    ++begin;  //移动到下一位
}
```   
在绝大多数的标准库是实现上，改代码会导致无限循环，因为这个end不会再指向v中任何元素，而是指向v中尾元素之后的位置；安全的方法是直接调用``while(begin != v.end())``    

## 9.4 vector对象是如何增长的    
总体来说，vector使用了“二倍法”的空间管理方式，在综合上甚至效率超过了deque和list。    

## 9.6 容器适配器     
除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。**适配器**是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一种适配器是一种机制，能够使某种事物行为看上去像是另一种事物一样。    
#### 定义一个适配器    
每个适配器都定义了两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝来初始化适配器。例如，假定deq是一个deque<int>，我们可以用一个deq来初始化一个新的stack,如下所示：    
```
stack<int> stk(deq);     //从deq拷贝元素到stk
```    
默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。    
```
//在vector上实现的空栈
stack<string, vector<string>> str_stk;
//str_stk2在vector上实现，初始化保存svec的拷贝
stack<string, vector<string>> str_stk2(svec);
```    
对于一个给定的适配器，可以
