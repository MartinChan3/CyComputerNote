# Primier C++

## 第1章 开始 
1. 除了cin、cout，还有两个标准输出对象为cerr(错误输出)和clog(日志输出)；
2. 提出了“流刷新”的概念，类似sql数据库的commit，如果一直不进行刷新，可能信息就会一直在内存中而没有显示出来；
3. 形如以下形式：    
```
while (std::cin >> value)
    sum += value;
```   
其实while后括号判断的是等式的最终结果，即std::cin的内容，一般输入一个合法结果，则返回为真，输入一个错误结果（例如回车符号），则返回为假；   

## 第2章 变量和基本类型
1. 基本类型中，比较少用的有wchar_t(宽字符，16位，对应1字节的char)，还有unicode字符char16_t和char32_t；（分别为16位和32位的Unicode字符）
2. 应该养成习惯，在明确知道数值不可能为负的情况下，应当选用无符号整形；   
3. 当给一个无符号数赋予一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数，例如``unsigned char c = -1  //char占8bit的情况下，c的值为255``，这意味着无符号数和有符号数一定不能够混用：   
```
uint u = 10;
int i = -42;
std::cout << u + i << std::endl; //结果为4294967264
```
4. 指定字面值类型：   
字符和字符串面值
| 前缀 | 含义 | 类型 |
| ---  | --- | --- |
| u    | Unicode16字符 | char16_t |
| U    | Unicode32字符 | char32_t |
| L    | 宽字符        | wchar_t  |
| u8   | UTF-8         | char     |   
整形字面值
|后缀|最小匹配类型|
|--|--|
|u or U|unsigned|
|l or L|long|
|ll or LL|long long|   
浮点型字面值
|--|--|
|f或F|float|
|l或L|long double|   
以上字面值都可以混合使用   
5. C++11新标准，确立了可以用花括号来初始化变量，这种初始化可以称为**列表初始化**，例如以下四个句子效果是一样的：   
```
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```   
这种初始化方式的一个特点在于，如果列表初始化中的数据有丢失信息的风险，则编译器就会报错，相反的，如果只是单纯的赋值，则会自动强制转换（伴随的就是精度丢失）
```
long double ld = 3.1415926;
int a{ld}, b = {ld}; //报错，因为存在信息丢失风险
int c(ld), d = ld; //正确，但丢失了精度
```    
6. 变量声明和定义中，如果想要声明一个变量而非定义它，则需要加extern关键字，并且不要显式的初始化变量，因为任何包含显式初始化的声明即会变成定义（C++使用分离式编译的原则，将声明和定义区分开来）
> 变量只能被定义一次，但是可以被多次声明。   
看上去丝毫不重要的声明和定义也许微不足道，但是非常重要。**如果要在多个文件中使用同一个变量，则必须将声明和定义分离**。此时变量的定义必须且只能出现在一个文件中，而其他用到该变量的文件必须进行声明，但是绝不能重复定义。   
7. 标识符：C++规定了用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外在函数体外的标识符不能以下划线开头。   
8. C++11使用nullptr来初始化指针，替代了原先的NULL；
9. void *指针可以存放任意对象的地址，但是并不能知晓对象的类型；   
10. 指向指针的引用：   
```
int i = 42;
int *p;       //p是一个int型指针
int *&r = p;  //r是一个对指针p的引用

r = &i;       //r引用了一个指针
*r = 0;
```
要理解r的类型到底是什么，最简单的办法是**从右至左阅读r的定义**。离变量名最近的符号（此例中为&）对变量类型有着最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中*说明&引用的是一个指针。最后，声明的基本数据类型部分指出r是一个int型指针。   
11. const限定符: 
```
int i = 42;
const int ci = i;
int j = ci;
```
const类型可以直接赋给非const的原因在于,ci的常量特性只在执行改变ci的操作中才会发挥作用，拷贝一个对象并不会改变它。   
另一个值得注意的是，const对象仅仅在文件内有效，事实上，编译使用了类似define的方法，将const类变量先用数值进行替代，因此每个用到的const变量都应该有所定义（有初始值）。   
有一种特殊情况在于需要共享const变量，做法是在一个.h和.cpp文件中进行定义即可： 
```
//file_1.h 
extern const int bufSize;
//file_1.cc
extern const int bufSize = fcn();
```   
12. const引用（常引用）： 常引用非常类似普通变量的常指针   
```
int i = 0;
const int &ip = i;
```
一般情况下，引用的类型必须和其所引用的对象类型一致，但是有两种特殊情况：1) 初始化常量引用时允许任意表达式作为初始值，只要表达式的结果能够转换为引用结果即可；   
```
int i = 42;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 * 2; //正确，为一常量引用
int &r4 = r1 * 2; //错误
```
这样能够产生的原因是因为编译器引入了**临时量**对象，即编译器用一个空间来暂存表达式的求职结果时临时创建的一个未命名的对象。
```
double dval = 3.14;
const int &ri = dval;

//编译器处理为
const int temp = dval;
const int &ri = temp;
```   

13. const指针：指针是对象，而引用不是，因此指针就和其他对象类型一样，可以把指针视作为常量。**常量指针**必须进行初始化，而且一旦完成，和其他常量一样，就无法改变了（即存放在常量指针中的地址无法改变了）。把*放在const之前说明指针是一个常量，这里暗含着不变的是指针本身的值而不是指向的那个值：   
```
int errNumb = 0;
int *const curErr = &errNumb;   //curErr将一直指向errNumb
const double pi = 3.14159;
const double *const pip = &pi; //pip是一个指向常量对象的常量指针
```   
如果先前所讲，判断复杂的变量类型依然遵循**由右向左**的阅读顺序。此例中，离curErr最近的是const，意味着本身是一个常量对象，对象的类型由声明符的其余部分决定，下一个符号是*，意思是curErr是一个常量指针。最后，声明语句的基础数据部分类型指明了它指向一个int对象。    
另一个注意点是指针本身是个常量并不意味着不能通过指针修改其所指向的对象的值。例如：    
```
if (*curErr)
{
    errorHandler();
    *curErr = 0;
}
```   

14. 顶层const：指针本身就是一个对象，而它又可以指向另一个对象，因此这是两个独立的问题。用名词**顶层const(top-level const)**来表示指针本身是一个常量，而用名称**底层const(low-level const)**表示指针所指向的对象是一个常量。更一般的，顶层const可以表示任何对象是常量，这一点对于任何数据类型适用。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类既可以是顶层const也可以是底层const,这一点和其他类型区别相比明显：    
```
int i = 0;
int *const p1 = &i;  //p1值不能被改变，是一个顶层const
const int ci = 42;  //ci值不能被改变，是一个顶层const
const int *p2 = &ci;  //p2的值可以被改变,是一个底层const
const int *const p3 = p2;  //靠右的const是顶层const,靠左的const是底层const   
const int &r = ci; //用于声明引用的const都是底层const
```    
顶层const有什么用呢？当执行对象拷贝操作时，常量是顶层还是底层区别明显，其中顶层const不受太多影响：   
```
i = ci;  //正确：ci是一个顶层const，无影响
p2 = p3; //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响
```   
另一方面，底层的const的限制却不容忽视，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的const资格，或者两个对象的数据类型必须能够相互转换。一般来说，非常量可以向常量转换，但是反之不行：   
```
int *p = p3;   //错误：p3包含了底层const定义，而p没有
p2 = p3;  //正确:p2和p3都是底层const（注意，这里把一个常指针赋给了非常指针，没有问题）
p2 = &i;  //正确：int*能够转换为const int*
int &r = ci; //错误:普通的int&不能够绑定到int常量上去   
const int &r2 = i;  //正确：const int&可以绑定到一个普通的int上
```   
p3既是顶层const又是底层const,拷贝p3时可以不在乎它是一个顶层const，但是必须清楚它指向的对象是一个常量。因此不能用p3去初始化p，因为p指向的是一个（非常量）整数，另一方面，p3的值也可以赋给p2，是因为这两个指针都是底层const，尽管p3本身是一个常量指针（顶层const），但是就这次赋值而言，不会有什么影响。

15. 新特性constexpr和常量表达式：常量表达式指的是值不变且在编译过程中就能得到计算结果的表达式，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。一个对象（或表达式）是不是常量表达式是由它的数据类型和初始值共同决定的，例如：   
```
const int max_files = 20;  //max_files是常量表达式
const int limit = max_files + 1;  //limits是常量表达式   
int staff_size = 27; //staff_size不是常量表达式
const int sz = get_size();  //sz不是常量表达式
```
尽管staff_size的初始值是个字面值常量，但是其数据本身只是一个普通非const int。而sz本身是一个常量，但是其具体值需要运行时才能获取，所以也不是常量表达式。   
引入constexpr变量的原因在于，在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式，实际使用中即使定义了一个const变量并且将其设定为一个我们认为是常量表达式的值，但实际使用过程中并非如此。   
C++11新标准规定，允许声明变量为constexpr类型以便由编译器来验证变量值是否为一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：    
```
constexpr int mf = 20; //20是常量表达式
constexpr int limit = mf + 1; //mf+1是常量表达式
constexpr int sz = size(); //只有当size是一个constexpr函数时才是一条正确的声明语句
```   
尽管不能使用普通函数作为constexpr变量的初始值，但是新标准允许一种特殊的constexpr函数，应该足够简单到编译时就可以计算它的结果，也就能用constexpr函数去初始化constexpr变量了。   

16. 字面值类型：类型简单，值显而易见的类型被称为“字面值类型”(literal type)。目前接触的数据类型中，算数类型、引用和指针都属于字面值类型，string\IO库和自定义类则不属于，也就不能被定义为constexpr。这里值得注意的是，尽管指针和引用都能被定义为cosntexpr，但是他们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或是存储于某个固定地址中的对象。
Tip:函数体内的变量一般来说并非存在固定的地址中，因此constexpr指针不能指向这样的变量。相反，定义于函数体外的对象其固定地址不变，则能够用来初始化constexpr指针。但是，C++允许函数定义一类超出函数本身的变量，这些变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的指针。   

17. 指针和constexpr:const和constexpr区别在哪儿？如果使用了constexpr定义了一个指针，那么constexpr仅对指针有效，而对指针所指的对象无关（这一点和const相反）：   
```
const int *p = nullptr; //p是一个指向整形常量的指针
constexpr int *q = nullptr; //q是一个指向整数的常量指针
```   
p和q的类型相差甚远，关键就在于constexpr是把它所定义的对象定义为了顶层const，这样意味着它可以随便指向常量或者非常量:   
```
constexpr int *np = nullptr;  
int j = 0;
constexpr int i = 42;  //i的类型是整形常量
//i和j都必须定义在函数体之外
constexpr const int *p = &i; //p是常量指针，指向整形常量i 
constexpr int *p1 = &j; //p1是常量指针，指向整数j
```   

18. 类型别名（type alias）: 有两种方法实现类型别名。一种方法是使用传统的``typedef``：
```
typedef double wages;  
typedef wages base, *p; //base是double的同义词，p是double*的同义词
```
C++11新的声明方法，使用别名声明（alias declaration）来定义类型别名:   
```
using SI= Sales_item;  //SI是Sales_item的同义词
```    

19. 指针、常量和类型别名：   
如果某个类型别名指代的是复合类型或者常量，那么把它运用到声明语句里就会产生意想不到的后果，例如下个例子当中的pstring实际上是char*的别名：   
```
typedef char *pstring; 
const pstring cstr = 0; //cstr是指向char的常量指针
const pstring *ps; //ps是一个指针，它的对象是指向char的常量指针
```   
这里极其容易混淆的是，pstring实际上是指向char的指针，因此const pstring指的是指向char的常量指针（**因为const是对给定类型的修饰符**）, 而非指向常量字符的指针。   
遇到一条使用了类型别名的声明语句，人们往往会错误地尝试把别名替换成它本来的样子，来理解该语句的含义：   
```
const char *cstr = 0;
```
而这样的展开或者替换完全错误，这是因为const char连写注定了后面的*修饰的是这个整体；   

20. auto类型说明符：
auto让编译器通过初始值来推断变量的类型，显然，**auto定义的变量必须有初始值**：
```
auto item = val1 + val2; //item初始化为val1和val2相加的结果
```   
使用auto也能在一条语句中声明多个变量，但是同一个声明语句中只能有一个基本数据类型，所有该语句中所有变量的初始基本数据类型都必须一样：   
```
auto i = 0, *p = &i;  //正确：皆为整形数据或指针
auto sz = 0, pi = 3.14; //错误：sz和pi类型不一致
```    
编译器推断出的auto类型有时候和初始值类型会不完全一样。
首先，由于使用引用时直接使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：   
```
int i = 0, &r = i;
auto a = r; //a是一个整数
```
其次，auto一般会忽略顶层const，同时底层const会保留下来，例如初始值是一个指向常量的指针时：   
```
const int ci = i, &cr = ci;
auto b = ci; //b是一个整数（ci顶层const特性被忽略）
auto c = cr; //c是一个整数（cr是别名，ci本身是一个顶层const）
auto d = &i; //d是一个整形指针（整数的地址就是指向整数的指针）
auto e = &ci; //e是一个指向整数常量的指针（对常量对象取地址是一种底层的const）
```   
(这里从b可以看出顶层const既可以是指针，还可以是引用的形式)   
如果希望推断的auto类型是一个顶层const，则需要进行明确指出：   
```
const auto f = ci;  //f是const int
```   
还可以将引用的类型设定为auto，此时原来的初始化规则依然适用：   
```
auto &g = ci;   //g是个整形常量引用，绑定到ci
auto &h = 42;   //错误：不能将非常量引用绑定字面值
const auto &j = 42; //正确：可以为常量引用绑定字面值
```   
设定一个类型为auto引用时，初始值中的顶层常量属性依然保留。和往常一样，**如果我们给初始值绑定一个引用，此时的常量就不是顶层常量了**（说白了最后发现auto引用是整体引用，和auto本身有一定差别）。   
同上，如果要在一个语句中定义多个变量，需要记住&和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一个类型：   
```
auto k = ci, &l = i;  //k为整数，l为整形引用   
auto &m = ci, *p = &ci; //m是对整形常量的引用，p是指向整形常量的指针
auto &n = i, *p2 = &ci; //错误，因为i的类型为int而&ci的类型为const int
```   

21. decltype类型指示符：有时候会遇到希望从表达式类型推断出要定义的变量的类型，但是又不想用该表达式的值初始化变量的情况。这里C++11引入``decltype``作为返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，但是却不计算表达式的值：   
```
decltype(f()) sum = x; //sum的类型就是函数f返回的类型
```   
编译器并不会直接调用函数f，而是使用当调用发生时f的返回类型作为sum的类型。   
decltype处理顶层const和引用方式和auto略有不同，如果decltype使用的表达式是一个变量的话，那么decltype返回该变量的类型（包含顶层const和引用在内）：   
```
const int ci = 0, &cj = ci;
decltype(ci) x = 0;  //x类型为const int
decltype(cj) y = x;  //y类型为const int&, 绑定到变量x
decltype(cj) z;  //错误：z是一个引用，必须进行初始化处理
```    
需要指出的一点是，引用从来都是作为其所指向的对象的同义词出现，只有在decltype处是一个例外，下面会进行解释。   
如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。而有些表达式会返回一个引用类型，一把来说这种情况发生时，意味着该表达式的结果对象能够作为一条赋值语句的左值：   
```
//decltype的结果可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; //正确：加法结果为0，所以b为一个int（没有初始化）
decltype(*p)       //错误：？c是int&,必须进行初始化
```
因为r是一个引用，因此decltype(r)的结果是引用类型。如果想让结果类型是r所指向的类型，可以将r作为表达式的一部分，例如r + 0。这样就巧妙的将表达式的结果表示为一个具体值而不是一个引用。    
另一方面，如果表达式内容**是解引用操作, 则decltype将得到引用类型**，正如我们熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，所以decltype(*p)的结果类型就是int&而非int。   
> Tip: 解引用操作符指的是\*在C++中，用于得到操作数所指向变量的引用（这说明\*不是单纯的指向原操作数，而是一个引用）   
decltype和auto另一处区别在于变量加上括号后可能结果类型会发生改变：   
```
decltype((i)) d;  //错误：d是int&,必须初始化
decltype(i) e;    //正确：e是一个未初始化的int
```   
原因在于给变量套上括号后，编译器就会把它当做一个表达式。   

22. 自定义数据结构：   
如果数据结构一上来就准备好使用对应的变量，一般可以写成：   
```
struct Sales_data {/**/} accum, trans, *salesptr;
//也可以写成
struct Sales_data {/**/};
Sales_data accum, trans, *salesptr;
```   
C++11规定，可以为数据成员提供一个**类内初始值**。   
    
## 第3章 字符串、向量和数组    
1. using形式不仅可以使用整个命名空间，更可以单独指定某个符号：   
```
using std::cout; 
using std::endl;
```   
Tip:头文件不应该包含using声明，这是因为头文件的内容会被拷贝到所有引用它的文件中去。如果头文件中有某个using声明，则会导致所有使用该头文件的文件都有这个声明，这样就会导致可能的冲突。    

2. 直接初始化和拷贝初始化：使用等号，即为拷贝初始化，如果不使用等号，则执行的是直接初始化。   

3. 使用getline读取一整行数据：   
```
int main()
{
    string line;
    //每次读入一整行，直到到达文件末尾
    while (getline(cin, line))
        cout << line << endl;
    return 0;
}
```    
注意，保存到line当中的对象并不包括换行符，哪怕一开始为换行符（这种情况下为空）   

4. string::size_type:这体现了标准库类型是与机器无关的特性，如果一条表达式中已经有了size()函数就不要再使用int了，可以避免混用int和unsigned可能带来的问题。 可以使用decltype来解决这个问题  
```
for (decltype(s.size()) index = 0; index != s.size() && isspace(s[index]); ++index)
    s[index] = toupper(s[index]); //将当前字符改成大写形式
```

5. 字面值不可以直接相加：   
```
string s7 = "hello" + "," + s2; //字面值必须和string类型相邻相加才可以继续进行
```   

6. 新的for使用准则：C++11中引入了新范围语句    
```
for (declaration: expression)
    statement
```   
例如：    
```
string str("some string");
//每行输入str中的一个字符
for (auto c : str)
    cout << c << endl;
```    

7. vector对象初始化： C++11支持使用花括号来进行vector对象初始化：   
```
vector<string> articles = {"a", "an", "the"};
vector<string> v0{"a", "an", "the"};
```   
使用花括号或者圆括号来区分列表初始值还是元素数量：    
```
vector<int> v1(10);  //v1有10个元素，每个值都是0
vector<int> v2{10};  //v2有1个元素，值为10
vector<int> v3(10, 1); //v3有10个值为1的元素
vector<int> v4{10, 1}; //v4有2个元素，值分别为10为1
```   
某些操作可能会让迭代器操作失效（pushback在遇到一定体量后，会重新修改了迭代器所指的空间内容）   

8. 迭代器的运算：迭代器可以和一个整数值相加（或相减），其返回值为一个移动了若干位置的迭代器。例如要获得一个指向vector对象中间位置的元素：    
```
//计算得到最接近vi中间元素的一个迭代器
auto mid = vi.begin() + vi.size() / 2;
```    
两个迭代器类型相减，得到的类型是名为**difference_type**的带符号整数型。   
这里给出一个迭代器用于二分搜索：   
```
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg) / 2;
while (mid != end && *mid != sought)
{
    if (sought < *mid)
        end = mid;
    else 
        beg = mid + 1;
    mid = beg + (end - beg) / 2; 
}
```

9. 数组：大小不变的存储结构，可用花括号进行初始化。**并且不支持拷贝给其他数组或者赋值**（有些支持该操作的编译器称之为编译器扩展，应当避免使用）；   
复杂数组声明的例子：   
```
int *ptrs[10];   //ptrs是含有10个整形指针的数组
int &refs[10] = /*?*/; //错误，不存在引用的数组
int (*Parray)[10] = &arr;  //Parray是指向一个含有10个整数的数组
int (&arrRef)[10] = arr;   //arr引用一个含有10个整数的数组
```   
一般的，依据**类型符由右向左绑定**的规律。例如ptrs由右向左：首先是一个10大小的数组，它的名字是ptrs，然后知道其指向类型为指向int的指针。   
特例在于Parray，由右向左理解似乎不太合理，更合理的方式在于**由内向外的顺序**。首先*Parray意味着Parray是一个指针，接下来看右侧，知道Parray是个指向大小为10的数组的指针。最后观察左边，可以知道数组中的元素是int。   
总结：判断数据类型由**先由内至外，后从右至左**来进行判断。    
```
int *(&arry)[10] = ptrs; //arry是数组的引用，该数组有10个指针
```    

10. size_t:使用数组下标时，通常定义为size_t类型，它是一种及其相关的无符号类型(类似difference_type)，它被设计得足够大来表示内存中任意对象大小。    
同样可以使用新for语句适用于数组的遍历：   
```
for (auto i : scores)
    cout << i << " ";
```

11. 指针和数组：首先auto是支持指针的
```
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia); //ia2是一个整形指针，指向ia第一个元素
ia2 = 42; //错误：ia2作为一个指针，不可以用int值给指针赋值
```   
必须支出的是，如果使用decltype关键字时上述转换不会发生，decltype(ia)返回的是10个整数构成的数组:   
```
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
ia3 = p; //错误：不能将整形指针给数组赋值
ia3[4] = i; //正确：吧i赋值给ia3的一个元素
```   
总结：decltype覆盖范围没有auto大    

12. 指针也是迭代器：虽然说我们一般不会使用指向尾元素的下一个元素，但是可以用于模仿迭代器模式对数组进行遍历
```
int *e = &arr[10]; //指向arr尾元素的下一个位置的指针
for (int *b = arr; b != e; ++b)
    cout << *b << endl;
```   

13. 标准库函数begin和end：为了减少尾后指针极可能使用出错的情况，C++11引入了标准库函数begin和end，包含在iterator头文件中：    
```
int ia[] = {0,1,2,3,4,5,7,8,9};
int *beg = begin(ia); //指向ia首元素
int *last = end(ia); //指向arr尾元素下一位置的指针
```    
例如寻找到一个数组中的第一个负数：   
```
int *pbeg = begin(arr), *pend = end(arr);
while (pbeg != pend && *pbeg >= 0)
    ++pbeg;
```   

14. 指针运算：众所周知指针可以进行运算。和迭代器的difference_type不同，两个指针相减结果是一种名为**ptrdiff_t**的标准库类型：   
```
auto n = end(arr) - begin(arr); 
```   
和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中机器相关的类型，因为其差值可能为一个负数，所以ptrdiff_t是一个带符号类型。     
只要两个指针指向同一个数组的元素（或者尾元素的下一个元素），就能利用关系运算符对其进行比较，例如下面这个遍历数组中元素的例子：       
```
int *b = arr, *e = arr + sz;
while (b < e) {
    //使用*b
    ++b;
}
```

15. 下标和指针：下标也可以及其自由的使用，例如：   
```
int ia[] = {0,2,4,6,8};
int *p = &ia[2];
int j = p[1];   //指向ia[3]
int k = p[-2];  //指向ia[0]
```
虽然string和vector也能执行下标运算，但是还是略有不同，标准库类型都限定了下标必须是无符号类型，而内置的下标没有这个限制。   

16. 与旧代码的接口：   
1) 混用string对象和C风格字符串：string提供了c_str()函数来转化为c风格的字符串类型：   
```
const char *str = s.c_str();
```   
2) 使用数组初始化vector对象：   
vector的初始化其实不用逐一赋值，用迭代器(指针)的方法非常便捷：   
```
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));
```   
这种方法另一个好处是可以提出中间一部分对象：   
```
vector<int> subVec(int_arr + 1, int_arr + 4); //拷贝了三个元素，分别为1、2、3
```     
> 建议：尽量使用标准库类型而非数组，例如C++程序应尽量使用vector和迭代器而非使用内置数组和指针，使用string而非c风格基于数组的字符串；   

17. 多维数组：严格来说C++语言中没有多维数组，通常说的多维数组本质是数组的数组，理解这一点对日后使用多维数组大有裨益。   
```
int ia[3][4];  //大小为3的数组，每个元素时含有4个整数的数组
int arr[10][20][30] = {0}; //大小为10的数组，每个元素为大小为20的数组，而这些数组元素是含有30个整数的数组，最终将每个元素初始化为0
```