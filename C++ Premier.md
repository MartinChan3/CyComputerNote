# Primier C++

## 第1章 开始 
1. 除了cin、cout，还有两个标准输出对象为cerr(错误输出)和clog(日志输出)；
2. 提出了“流刷新”的概念，类似sql数据库的commit，如果一直不进行刷新，可能信息就会一直在内存中而没有显示出来；
3. 形如以下形式：    
```
while (std::cin >> value)
    sum += value;
```   
其实while后括号判断的是等式的最终结果，即std::cin的内容，一般输入一个合法结果，则返回为真，输入一个错误结果（例如回车符号），则返回为假；   

## 第2章 变量和基本类型
1. 基本类型中，比较少用的有wchar_t(宽字符，16位，对应1字节的char)，还有unicode字符char16_t和char32_t；（分别为16位和32位的Unicode字符）
2. 应该养成习惯，在明确知道数值不可能为负的情况下，应当选用无符号整形；   
3. 当给一个无符号数赋予一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数，例如``unsigned char c = -1  //char占8bit的情况下，c的值为255``，这意味着无符号数和有符号数一定不能够混用：   
```
uint u = 10;
int i = -42;
std::cout << u + i << std::endl; //结果为4294967264
```
4. 指定字面值类型：   
字符和字符串面值
| 前缀 | 含义 | 类型 |
| ---  | --- | --- |
| u    | Unicode16字符 | char16_t |
| U    | Unicode32字符 | char32_t |
| L    | 宽字符        | wchar_t  |
| u8   | UTF-8         | char     |   
整形字面值
|后缀|最小匹配类型|
|--|--|
|u or U|unsigned|
|l or L|long|
|ll or LL|long long|   
浮点型字面值
|--|--|
|f或F|float|
|l或L|long double|   
以上字面值都可以混合使用   
5. C++11新标准，确立了可以用花括号来初始化变量，这种初始化可以称为**列表初始化**，例如以下四个句子效果是一样的：   
```
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```   
这种初始化方式的一个特点在于，如果列表初始化中的数据有丢失信息的风险，则编译器就会报错，相反的，如果只是单纯的赋值，则会自动强制转换（伴随的就是精度丢失）
```
long double ld = 3.1415926;
int a{ld}, b = {ld}; //报错，因为存在信息丢失风险
int c(ld), d = ld; //正确，但丢失了精度
```    
6. 变量声明和定义中，如果想要声明一个变量而非定义它，则需要加extern关键字，并且不要显式的初始化变量，因为任何包含显式初始化的声明即会变成定义（C++使用分离式编译的原则，将声明和定义区分开来）
> 变量只能被定义一次，但是可以被多次声明。   
看上去丝毫不重要的声明和定义也许微不足道，但是非常重要。**如果要在多个文件中使用同一个变量，则必须将声明和定义分离**。此时变量的定义必须且只能出现在一个文件中，而其他用到该变量的文件必须进行声明，但是绝不能重复定义。   
7. 标识符：C++规定了用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外在函数体外的标识符不能以下划线开头。   
8. C++11使用nullptr来初始化指针，替代了原先的NULL；
9. void *指针可以存放任意对象的地址，但是并不能知晓对象的类型；   
10. 指向指针的引用：   
```
int i = 42;
int *p;       //p是一个int型指针
int *&r = p;  //r是一个对指针p的引用

r = &i;       //r引用了一个指针
*r = 0;
```
要理解r的类型到底是什么，最简单的办法是**从右至左阅读r的定义**。离变量名最近的符号（此例中为&）对变量类型有着最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中*说明&引用的是一个指针。最后，声明的基本数据类型部分指出r是一个int型指针。   
11. const限定符: 
```
int i = 42;
const int ci = i;
int j = ci;
```
const类型可以直接赋给非const的原因在于,ci的常量特性只在执行改变ci的操作中才会发挥作用，拷贝一个对象并不会改变它。   
另一个值得注意的是，const对象仅仅在文件内有效，事实上，编译使用了类似define的方法，将const类变量先用数值进行替代，因此每个用到的const变量都应该有所定义（有初始值）。   
有一种特殊情况在于需要共享const变量，做法是在一个.h和.cpp文件中进行定义即可： 
```
//file_1.h 
extern const int bufSize;
//file_1.cc
extern const int bufSize = fcn();
```   
12. const引用（常引用）： 常引用非常类似普通变量的常指针   
```
int i = 0;
const int &ip = i;
```
一般情况下，引用的类型必须和其所引用的对象类型一致，但是有两种特殊情况：1) 初始化常量引用时允许任意表达式作为初始值，只要表达式的结果能够转换为引用结果即可；   
```
int i = 42;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 * 2; //正确，为一常量引用
int &r4 = r1 * 2; //错误
```
这样能够产生的原因是因为编译器引入了**临时量**对象，即编译器用一个空间来暂存表达式的求职结果时临时创建的一个未命名的对象。
```
double dval = 3.14;
const int &ri = dval;

//编译器处理为
const int temp = dval;
const int &ri = temp;
```   

13. const指针：指针是对象，而引用不是，因此指针就和其他对象类型一样，可以把指针视作为常量。**常量指针**必须进行初始化，而且一旦完成，和其他常量一样，就无法改变了（即存放在常量指针中的地址无法改变了）。把*放在const之前说明指针是一个常量，这里暗含着不变的是指针本身的值而不是指向的那个值：   
```
int errNumb = 0;
int *const curErr = &errNumb;   //curErr将一直指向errNumb
const double pi = 3.14159;
const double *const pip = &pi; //pip是一个指向常量对象的常量指针
```   
如果先前所讲，判断复杂的变量类型依然遵循**由右向左**的阅读顺序。此例中，离curErr最近的是const，意味着本身是一个常量对象，对象的类型由声明符的其余部分决定，下一个符号是*，意思是curErr是一个常量指针。最后，声明语句的基础数据部分类型指明了它指向一个int对象。    
另一个注意点是指针本身是个常量并不意味着不能通过指针修改其所指向的对象的值。例如：    
```
if (*curErr)
{
    errorHandler();
    *curErr = 0;
}
```   

14. 顶层const：指针本身就是一个对象，而它又可以指向另一个对象，因此这是两个独立的问题。用名词**顶层const(top-level const)**来表示指针本身是一个常量，而用名称**底层const(low-level const)**表示指针所指向的对象是一个常量。更一般的，顶层const可以表示任何对象是常量，这一点对于任何数据类型适用。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类既可以是顶层const也可以是底层const,这一点和其他类型区别相比明显：    
```
int i = 0;
int *const p1 = &i;  //p1值不能被改变，是一个顶层const
const int ci = 42;  //ci值不能被改变，是一个顶层const
const int *p2 = &ci;  //p2的值可以被改变,是一个底层const
const int *const p3 = p2;  //靠右的const是顶层const,靠左的const是底层const   
const int &r = ci; //用于声明引用的const都是底层const
```    
顶层const有什么用呢？当执行对象拷贝操作时，常量是顶层还是底层区别明显，其中顶层const不受太多影响：   
```
i = ci;  //正确：ci是一个顶层const，无影响
p2 = p3; //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响
```   
另一方面，底层的const的限制却不容忽视，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的const资格，或者两个对象的数据类型必须能够相互转换。一般来说，非常量可以向常量转换，但是反之不行：   
```
int *p = p3;   //错误：p3包含了底层const定义，而p没有
p2 = p3;  //正确:p2和p3都是底层const（注意，这里把一个常指针赋给了非常指针，没有问题）
p2 = &i;  //正确：int*能够转换为const int*
int &r = ci; //错误:普通的int&不能够绑定到int常量上去   
const int &r2 = i;  //正确：const int&可以绑定到一个普通的int上
```   
p3既是顶层const又是底层const,拷贝p3时可以不在乎它是一个顶层const，但是必须清楚它指向的对象是一个常量。因此不能用p3去初始化p，因为p指向的是一个（非常量）整数，另一方面，p3的值也可以赋给p2，是因为这两个指针都是底层const，尽管p3本身是一个常量指针（顶层const），但是就这次赋值而言，不会有什么影响。

15. 新特性constexpr和常量表达式：常量表达式指的是值不变且在编译过程中就能得到计算结果的表达式，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。一个对象（或表达式）是不是常量表达式是由它的数据类型和初始值共同决定的，例如：   
```
const int max_files = 20;  //max_files是常量表达式
const int limit = max_files + 1;  //limits是常量表达式   
int staff_size = 27; //staff_size不是常量表达式
const int sz = get_size();  //sz不是常量表达式
```
尽管staff_size的初始值是个字面值常量，但是其数据本身只是一个普通非const int。而sz本身是一个常量，但是其具体值需要运行时才能获取，所以也不是常量表达式。   
引入constexpr变量的原因在于，在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式，实际使用中即使定义了一个const变量并且将其设定为一个我们认为是常量表达式的值，但实际使用过程中并非如此。   
C++11新标准规定，允许声明变量为constexpr类型以便由编译器来验证变量值是否为一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：    
```
constexpr int mf = 20; //20是常量表达式
constexpr int limit = mf + 1; //mf+1是常量表达式
constexpr int sz = size(); //只有当size是一个constexpr函数时才是一条正确的声明语句
```   
尽管不能使用普通函数作为constexpr变量的初始值，但是新标准允许一种特殊的constexpr函数，应该足够简单到编译时就可以计算它的结果，也就能用constexpr函数去初始化constexpr变量了。   

16. 字面值类型：类型简单，值显而易见的类型被称为“字面值类型”(literal type)。目前接触的数据类型中，算数类型、引用和指针都属于字面值类型，string\IO库和自定义类则不属于，也就不能被定义为constexpr。这里值得注意的是，尽管指针和引用都能被定义为cosntexpr，但是他们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或是存储于某个固定地址中的对象。
Tip:函数体内的变量一般来说并非存在固定的地址中，因此constexpr指针不能指向这样的变量。相反，定义于函数体外的对象其固定地址不变，则能够用来初始化constexpr指针。但是，C++允许函数定义一类超出函数本身的变量，这些变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的指针。   

17. 指针和constexpr:const和constexpr区别在哪儿？如果使用了constexpr定义了一个指针，那么constexpr仅对指针有效，而对指针所指的对象无关（这一点和const相反）：   
```
const int *p = nullptr; //p是一个指向整形常量的指针
constexpr int *q = nullptr; //q是一个指向整数的常量指针
```   
p和q的类型相差甚远，关键就在于constexpr是把它所定义的对象定义为了顶层const，这样意味着它可以随便指向常量或者非常量:   
```
constexpr int *np = nullptr;  
int j = 0;
constexpr int i = 42;  //i的类型是整形常量
//i和j都必须定义在函数体之外
constexpr const int *p = &i; //p是常量指针，指向整形常量i 
constexpr int *p1 = &j; //p1是常量指针，指向整数j
```   

18. 类型别名（type alias）: 有两种方法实现类型别名。一种方法是使用传统的``typedef``：
```
typedef double wages;  
typedef wages base, *p; //base是double的同义词，p是double*的同义词
```
C++11新的声明方法，使用别名声明（alias declaration）来定义类型别名:   
```
using SI= Sales_item;  //SI是Sales_item的同义词
```    

19. 指针、常量和类型别名：   
如果某个类型别名指代的是复合类型或者常量，那么把它运用到声明语句里就会产生意想不到的后果，例如下个例子当中的pstring实际上是char*的别名：   
```
typedef char *pstring; 
const pstring cstr = 0; //cstr是指向char的常量指针
const pstring *ps; //ps是一个指针，它的对象是指向char的常量指针
```   
这里极其容易混淆的是，pstring实际上是指向char的指针，因此const pstring指的是指向char的常量指针（**因为const是对给定类型的修饰符**）, 而非指向常量字符的指针。   
遇到一条使用了类型别名的声明语句，人们往往会错误地尝试把别名替换成它本来的样子，来理解该语句的含义：   
```
const char *cstr = 0;
```
而这样的展开或者替换完全错误，这是因为const char连写注定了后面的*修饰的是这个整体；   

20. auto类型说明符：
auto让编译器通过初始值来推断变量的类型，显然，**auto定义的变量必须有初始值**：
```
auto item = val1 + val2; //item初始化为val1和val2相加的结果
```   
使用auto也能在一条语句中声明多个变量，但是同一个声明语句中只能有一个基本数据类型，所有该语句中所有变量的初始基本数据类型都必须一样：   
```
auto i = 0, *p = &i;  //正确：皆为整形数据或指针
auto sz = 0, pi = 3.14; //错误：sz和pi类型不一致
```    
编译器推断出的auto类型有时候和初始值类型会不完全一样。
首先，由于使用引用时直接使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：   
```
int i = 0, &r = i;
auto a = r; //a是一个整数
```
其次，auto一般会忽略顶层const，同时底层const会保留下来，例如初始值是一个指向常量的指针时：   
```
const int ci = i, &cr = ci;
auto b = ci; //b是一个整数（ci顶层const特性被忽略）
auto c = cr; //c是一个整数（cr是别名，ci本身是一个顶层const）
auto d = &i; //d是一个整形指针（整数的地址就是指向整数的指针）
auto e = &ci; //e是一个指向整数常量的指针（对常量对象取地址是一种底层的const）
```   
(这里从b可以看出顶层const既可以是指针，还可以是引用的形式)   
如果希望推断的auto类型是一个顶层const，则需要进行明确指出：   
```
const auto f = ci;  //f是const int
```   
还可以将引用的类型设定为auto，此时原来的初始化规则依然适用：   
```
auto &g = ci;   //g是个整形常量引用，绑定到ci
auto &h = 42;   //错误：不能将非常量引用绑定字面值
const auto &j = 42; //正确：可以为常量引用绑定字面值
```   
设定一个类型为auto引用时，初始值中的顶层常量属性依然保留。和往常一样，**如果我们给初始值绑定一个引用，此时的常量就不是顶层常量了**（说白了最后发现auto引用是整体引用，和auto本身有一定差别）。   
同上，如果要在一个语句中定义多个变量，需要记住&和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一个类型：   
```
auto k = ci, &l = i;  //k为整数，l为整形引用   
auto &m = ci, *p = &ci; //m是对整形常量的引用，p是指向整形常量的指针
auto &n = i, *p2 = &ci; //错误，因为i的类型为int而&ci的类型为const int
```   

21. decltype类型指示符：有时候会遇到希望从表达式类型推断出要定义的变量的类型，但是又不想用该表达式的值初始化变量的情况。这里C++11引入``decltype``作为返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，但是却不计算表达式的值：   
```
decltype(f()) sum = x; //sum的类型就是函数f返回的类型
```   
编译器并不会直接调用函数f，而是使用当调用发生时f的返回类型作为sum的类型。   
decltype处理顶层const和引用方式和auto略有不同，如果decltype使用的表达式是一个变量的话，那么decltype返回该变量的类型（包含顶层const和引用在内）：   
const int ci = 0, &cj = ci;
decltype(ci) x = 0;  //x类型为const int
decltype(cj) y = x;  //y类型为const int&, 绑定到变量x
decltype(cj) z;  //错误：z是一个引用，必须进行初始化处理
```    
需要指出的一点是，引用从来都是作为其所指向的对象的同义词出现，只有在decltype处是一个例外，下面会进行解释。   
如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。而有些表达式会返回一个引用类型，一把来说这种情况发生时，意味着该表达式的结果对象能够作为一条赋值语句的左值：   
```
//decltype的结果可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; //正确：加法结果为0，所以b为一个int（没有初始化）
decltype(*p)       //错误：？c是int&,必须进行初始化
```
因为r是一个引用，因此decltype(r)的结果是引用类型。如果想让结果类型是r所指向的类型，可以将r作为表达式的一部分，例如r + 0。这样就巧妙的将表达式的结果表示为一个具体值而不是一个引用。    
另一方面，如果表达式内容**是解引用操作, 则decltype将得到引用类型**，正如我们熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，所以decltype(*p)的结果类型就是int&而非int。   
> Tip: 解引用操作符指的是\*在C++中，用于得到操作数所指向变量的引用（这说明\*不是单纯的指向原操作数，而是一个引用）   
decltype和auto另一处区别在于变量加上括号后可能结果类型会发生改变：   
```
decltype((i)) d;  //错误：d是int&,必须初始化
decltype(i) e;    //正确：e是一个未初始化的int
```   
原因在于给变量套上括号后，编译器就会把它当做一个表达式。   

22. 自定义数据结构：   
如果数据结构一上来就准备好使用对应的变量，一般可以写成：   
```
struct Sales_data {/**/} accum, trans, *salesptr;
//也可以写成
struct Sales_data {/**/};
Sales_data accum, trans, *salesptr;
```   
C++11规定，可以为数据成员提供一个**类内初始值**。   
    
## 第3章 字符串、向量和数组    
1. using形式不仅可以使用整个命名空间，更可以单独指定某个符号：   
```
using std::cout; 
using std::endl;
```   
Tip:头文件不应该包含using声明，这是因为头文件的内容会被拷贝到所有引用它的文件中去。如果头文件中有某个using声明，则会导致所有使用该头文件的文件都有这个声明，这样就会导致可能的冲突。    

2. 直接初始化和拷贝初始化：使用等号，即为拷贝初始化，如果不使用等号，则执行的是直接初始化。   

3. 使用getline读取一整行数据：   
```
int main()
{
    string line;
    //每次读入一整行，直到到达文件末尾
    while (getline(cin, line))
        cout << line << endl;
    return 0;
}
```    
注意，保存到line当中的对象并不包括换行符，哪怕一开始为换行符（这种情况下为空）   

4. string::size_type:这体现了标准库类型是与机器无关的特性，如果一条表达式中已经有了size()函数就不要再使用int了，可以避免混用int和unsigned可能带来的问题。 可以使用decltype来解决这个问题  
```
for (decltype(s.size()) index = 0; index != s.size() && isspace(s[index]); ++index)
    s[index] = toupper(s[index]); //将当前字符改成大写形式
```

5. 字面值不可以直接相加：   
```
string s7 = "hello" + "," + s2; //字面值必须和string类型相邻相加才可以继续进行
```   

6. 新的for使用准则：C++11中引入了新范围语句    
```
for (declaration: expression)
    statement
```   
例如：    
```
string str("some string");
//每行输入str中的一个字符
for (auto c : str)
    cout << c << endl;
```    

7. vector对象初始化： C++11支持使用花括号来进行vector对象初始化：   
```
vector<string> articles = {"a", "an", "the"};
vector<string> v0{"a", "an", "the"};
```   
使用花括号或者圆括号来区分列表初始值还是元素数量：    
```
vector<int> v1(10);  //v1有10个元素，每个值都是0
vector<int> v2{10};  //v2有1个元素，值为10
vector<int> v3(10, 1); //v3有10个值为1的元素
vector<int> v4{10, 1}; //v4有2个元素，值分别为10为1
```   
某些操作可能会让迭代器操作失效（pushback在遇到一定体量后，会重新修改了迭代器所指的空间内容）   

8. 迭代器的运算：迭代器可以和一个整数值相加（或相减），其返回值为一个移动了若干位置的迭代器。例如要获得一个指向vector对象中间位置的元素：    
```
//计算得到最接近vi中间元素的一个迭代器
auto mid = vi.begin() + vi.size() / 2;
```    
两个迭代器类型相减，得到的类型是名为**difference_type**的带符号整数型。   
这里给出一个迭代器用于二分搜索：   
```
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg) / 2;
while (mid != end && *mid != sought)
{
    if (sought < *mid)
        end = mid;
    else 
        beg = mid + 1;
    mid = beg + (end - beg) / 2; 
}
```

9. 数组：大小不变的存储结构，可用花括号进行初始化。**并且不支持拷贝给其他数组或者赋值**（有些支持该操作的编译器称之为编译器扩展，应当避免使用）；   
复杂数组声明的例子：   
```
int *ptrs[10];   //ptrs是含有10个整形指针的数组
int &refs[10] = /*?*/; //错误，不存在引用的数组
int (*Parray)[10] = &arr;  //Parray是指向一个含有10个整数的数组
int (&arrRef)[10] = arr;   //arr引用一个含有10个整数的数组
```   
一般的，依据**类型符由右向左绑定**的规律。例如ptrs由右向左：首先是一个10大小的数组，它的名字是ptrs，然后知道其指向类型为指向int的指针。   
特例在于Parray，由右向左理解似乎不太合理，更合理的方式在于**由内向外的顺序**。首先*Parray意味着Parray是一个指针，接下来看右侧，知道Parray是个指向大小为10的数组的指针。最后观察左边，可以知道数组中的元素是int。   
总结：判断数据类型由**先由内至外，后从右至左**来进行判断。    
```
int *(&arry)[10] = ptrs; //arry是数组的引用，该数组有10个指针
```    

10. size_t:使用数组下标时，通常定义为size_t类型，它是一种及其相关的无符号类型(类似difference_type)，它被设计得足够大来表示内存中任意对象大小。    
同样可以使用新for语句适用于数组的遍历：   
```
for (auto i : scores)
    cout << i << " ";
```

11. 指针和数组：首先auto是支持指针的
```
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia); //ia2是一个整形指针，指向ia第一个元素
ia2 = 42; //错误：ia2作为一个指针，不可以用int值给指针赋值
```   
必须支出的是，如果使用decltype关键字时上述转换不会发生，decltype(ia)返回的是10个整数构成的数组:   
```
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
ia3 = p; //错误：不能将整形指针给数组赋值
ia3[4] = i; //正确：吧i赋值给ia3的一个元素
```   
总结：decltype覆盖范围没有auto大    

12. 指针也是迭代器：虽然说我们一般不会使用指向尾元素的下一个元素，但是可以用于模仿迭代器模式对数组进行遍历
```
int *e = &arr[10]; //指向arr尾元素的下一个位置的指针
for (int *b = arr; b != e; ++b)
    cout << *b << endl;
```   

13. 标准库函数begin和end：为了减少尾后指针极可能使用出错的情况，C++11引入了标准库函数begin和end，包含在iterator头文件中：    
```
int ia[] = {0,1,2,3,4,5,7,8,9};
int *beg = begin(ia); //指向ia首元素
int *last = end(ia); //指向arr尾元素下一位置的指针
```    
例如寻找到一个数组中的第一个负数：   
```
int *pbeg = begin(arr), *pend = end(arr);
while (pbeg != pend && *pbeg >= 0)
    ++pbeg;
```   

14. 指针运算：众所周知指针可以进行运算。和迭代器的difference_type不同，两个指针相减结果是一种名为**ptrdiff_t**的标准库类型：   
```
auto n = end(arr) - begin(arr); 
```   
和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中机器相关的类型，因为其差值可能为一个负数，所以ptrdiff_t是一个带符号类型。     
只要两个指针指向同一个数组的元素（或者尾元素的下一个元素），就能利用关系运算符对其进行比较，例如下面这个遍历数组中元素的例子：       
```
int *b = arr, *e = arr + sz;
while (b < e) {
    //使用*b
    ++b;
}
```

15. 下标和指针：下标也可以及其自由的使用，例如：   
```
int ia[] = {0,2,4,6,8};
int *p = &ia[2];
int j = p[1];   //指向ia[3]
int k = p[-2];  //指向ia[0]
```
虽然string和vector也能执行下标运算，但是还是略有不同，标准库类型都限定了下标必须是无符号类型，而内置的下标没有这个限制。   

16. 与旧代码的接口：   
1) 混用string对象和C风格字符串：string提供了c_str()函数来转化为c风格的字符串类型：   
```
const char *str = s.c_str();
```   
2) 使用数组初始化vector对象：   
vector的初始化其实不用逐一赋值，用迭代器(指针)的方法非常便捷：   
```
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));
```   
这种方法另一个好处是可以提出中间一部分对象：   
```
vector<int> subVec(int_arr + 1, int_arr + 4); //拷贝了三个元素，分别为1、2、3
```     
> 建议：尽量使用标准库类型而非数组，例如C++程序应尽量使用vector和迭代器而非使用内置数组和指针，使用string而非c风格基于数组的字符串；   

17. 多维数组：严格来说C++语言中没有多维数组，通常说的多维数组本质是数组的数组，理解这一点对日后使用多维数组大有裨益。   
```
int ia[3][4];  //大小为3的数组，每个元素时含有4个整数的数组
int arr[10][20][30] = {0}; //大小为10的数组，每个元素为大小为20的数组，而这些数组元素是含有30个整数的数组，最终将每个元素初始化为0
```   
阅读顺序依然遵照由内而外的规律，例如ia是一个3个元素的数组，同时这每一个元素本身都是含有4个元素的数组。   
多维数组的初始化类似普通数组，每一行都用花括号括了起来：   
```
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
};
```   
而事实上内嵌花括号并非必须，同样可以使用一位数组形式以更简洁的方式完成以上的初始化工作（前提是没有错误）：   
```
int ia[3][4] =  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
```    
也可以显示的初始化每行首元素（仅仅）：   
```
int ia[3][4] = {{0} , {4}, {8}};
```   
如果只是显式的初始化第一行元素，其它元素被初始化为0：    
```
int ix[3][4] = {0, 3, 4, 9};
```   
下标引用：**如果表达式含有的下标运算符和数组维度一样多，该表达式的结果将是给定类型的元素，如果比数组维度小，则将是返回一个给定索引处的一个内层数组**:   
```
ia[2][3] = arr[0][0][0]; //首元素赋给ia最后一个元素
int (&row)[4] = ia[1]; //将row绑定到ia的第二个4元素数组上
```   
另一个例子，常用两层嵌套来处理多维数组:   
```
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt]; 
for (size_t i = 0; i != rowCnt; ++i) //对于每一行
{
    for (size_t j = 0; j != colCnt; ++j)  //对于每一列
    {
        ia[i][j] = i * colCnt + j;
    }
}
```   
更简洁的，使用C++11的范围语句，可以简化为：   
```
size_t cnt = 0;   
for (auto &row : ia)
    for (auto &col : row) {
        col = cnt;
        cnt++;
    }
```   
这里有个很有意思的地方，为什么要强制使用引用？本质在于避免自动转化为指针：如果不使用引用类型，循环形式如下：
```   
for (auto row : ia)
    for (auto col : row)
```    
程序将会无法通过编译，这是因为，第一个循环ia所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类型，编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转换为指向给数组内首元素的指针，那么得到的row类型就是int*，因此内存循环就不合法了（编译器将试图在一个int*内进行遍历）   
> Note:要使用范围for语句处理更多的多维数组，除了最内层的循环外，其他所有的循环的控制变量都应该是引用类型。    
指针和多维数组：当程序使用多维数组的名字时，也会自动将其转换为指向数组首元素的指针。   
```
int ia[3][4];    //大小为3的数组，每个元素是含有4个整数的数组
int (*p)[4] = ia; //p指向含有4个整数的数组
p = &ia[2];  //p指向ia的尾元素
```  
> Note: 上述声明中，圆括号必不可少
> int *ip[4]; //包含4个整形指针的数组
> int (*ip)[4]; //指向包含4个整数的数组的指针    
C++11新标准可以使用auto或者decltype来避免对指针遍历时再定义一个指针类型了：   
```
for (auto p = ia; p != ia + 3; ++p)
    for (auto q = *q; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
```    
使用标准库函数begin和end可以获得同样的功能，而且形式表达上更加简洁：   
```
for (auto p = begin(ia); p != end(ia); ++p)
    for (auto q = begin(*p); q != end(*p); ++q)
        cout << *q << ' ';
    cout << endl;
```   
这样就既不用在乎size也不用在乎类型。如果需要更进一步，使用类型别名可以使这个过程更加简单一些，例如：   
```
using int_array = int[4]; //C++11新标准声明别名的形式
//或者使用
typedef int int_array[4]; 

for (int_array *p = ia; p != ia + 3; ++p)
    for (int *q = *p; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
```   

## 第4章 表达式
1. 基础：   
C++定义了一元(取地址符&/解引用符*)、二元、三元（A?B:C）运算符
左值右值：
C中，单纯的指左值只能位于赋值表达式的左侧，右值只能位于赋值表达式的右侧；   
C++中，当一个对象被用作右值时，用的是对象的内容（值）；而当对象被用作左值时，用的是对象的身份（在内存中的位置）；   
和C比起来，左值一方面在为常量时，并不能作为赋值语句的左侧运算对象，另一方面，虽然有些表达式求值结果是对象，但是它们是右值而非左值。   
运算符操作的一个重要原则在于**需要右值的地方，可以用左值代替，但是反之不成立**，并且当一个左值被当成右值使用时，实际使用的就是它的值（内容）。   
> Tip: 使用关键字decltype时，左值和右值也略有不同，如果求值结果为左值，则decltype作用于该表达式（非变量）得到一个引用类型。例如p的类型为int*,因为解引用符生成左值，故decltype(*p)得到一个int&。另一方面取地址运算符生成右值，故decltype(&p)的结果是int**, 也就是一个指向整形指针的指针。   
求值顺序：运算符的优先级决定了运算对象的组合方式，但是没有框定运算对象按什么顺序求值。**大多数情况下不会明确指定求值的顺序**，例如：   
```
int i = f1() * f2();
```   
这里对于不同的编译器来说，就无法判断是f1先调用还是f2先调用。还有例如：  
```
int i = 0; 
cout << i << " " << ++i << endl; //未定义
```
这种输入结果各种编译器也会有很大区别，完全不可预知。所以编程中尽量避免这种写法。**这给我们的启示是尽量在复杂的表达式中对同一个对象进行多次操作（至多一次）**，如果实在是需要，请用括号加以限制。  
但是有4种运算符明确了其运算对象的求值顺序，&&（逻辑与）规定了先求左侧并且只有左侧为真时才能继续求右侧（**这个很有用，尤其在判断输入变量是否满足标准的情况下**），另三种分别为逻辑或(||)、条件(?:)与逗号(,);   
2. 取余运算：取余运算的定义为，如果m和n是整数且n并非0，则m = (m/n) * n + m % n。其隐含意思为，**如果m % n不等于0，那么其结果应该始终和m的符号相同**，根据这个原则，我们不难求出：   
```
-21 % 8 = -5; -21 / -8 = 2;
21 % -5 = 1;  -21 / 5 = -4;
```   

3. 逻辑运算符：上面提过，对于逻辑与和逻辑或（&&和||）都是先求左侧对象值再求右侧对象之（除非左侧运算对象无法确定表达式才会计算右侧运算对象的值），这种策略称为短路求值（short-circuit evaluation）,一个示范可以用于指针为空和size的判断，这样可以显得语法更加简洁：   
```
bool isTen(QVector<int> *iptr){
    if (iptr && iptr->size() == 10)
        return true;
    return false;
}
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    qDebug() << isTen(Q_NULLPTR);
    return a.exec();
}
```   

4. 赋值运算符：赋值运算符合右结合律，这一点和其他的二元运算符不太一样，最常见的就是**多重赋值**，当然，这种语句必须类型转换正确：   
```
int ival, jval;
ival = jval = 0;  
```   
较低优先级的赋值运算带来的写法变换：**赋值语句经常出现在条件中**，这是因为赋值运算优先级低，通常需要给赋值语句加上括号来使得其符合我们的原意。下面给一个例子说明赋值语句放在条件语句中有什么用处，它的目的是反复调用一个函数直到返回期望的值为止：   
```
//以下为一个形式繁琐，易出错的写法
int i = get_value();   
while (i != 42)
{
    //其它处理...
    i = get_value(); //得到下一个值，继续判断
}
```   
实际上可以简化为：   
```
int i;
while ((i = get_value()) != 42)
{
    //其他处理...
}
```
这个处理更加简洁，也证明了赋值运算符本身较低的运算符。   
复合赋值运算符：+=、-=、*=、/=、%=、<<=、>>=、&=、^=、|=，其本质和其本身表达式只是稍有区别``a = a op b``，其实在很多地方，这种区别对于程序的影响几乎可以忽略不计。   

5. 递增与递减运算符（++/--）：除非必须，一般不使用递增递减运算符的后置版本，这里从另一个方面揭示了**为什么前置++的效率比后置++高？**，这是因为**前置直接返回了这个数自身+1的内容，而后置版本还需要先把原始值存储下来，用于返回这个未修改的内容**，如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。   
当然任何问题都不是绝对的，如果我们遇到在一条复合表达式中既将变量+1或减-1又能使用其原始值，这时候就可以使用递增和递减运算符的后置版本，例如以下这个例子：   
```
auto pbeg = v.begin();
while (pbeg != v.end() && *pbeg >= 0)
    cout << *pbeg++ << endl;
```   
> Tip: 虽然*pbeg++的表达式可能不太一定容易理解，但是其实这是一种更有效的写法，远比书写**cout << *pbgeg << endl; ++pbeg;**要更加简洁非，并且也更少出错。大多数C++程序追求简洁、摒弃冗长，应该习惯于这种写法。    
> Tip: 注意++极容易引起任意求值顺序问题的错误；   

6. 条件运算符：条件运算符(?:)已经非常常用，这里有两点注意点：   
1) 嵌套使用：
```
finalgrade = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : "pass";
```   
不过注意，如果超过两层，代码的可读性急剧下降；   
2) 在输出表达式中使用条件运算符：这里极其容易造成问题的原因是因为条件运算符的优先级很低，应该加以括号进行限制；   
```
cout << ((grade < 60) ? "fail" : "pass"); //输出pass或fail
cout << (grade < 60) ? "fail" : "pass"; //输出1或者0
cout << grade < 60 ? "fail" : "pass"; //错误，因为试图比较cout和60
```   

7. 位移运算符：位运算符作用于整数类型运算对象，并把运算对象看成是二进制位的集合。同时C++提供了bitset类（标准库）可以表示任意大小的二进制位集合，所以位运算符同样能用于bitset类型。   
有两个平时用的比较少的位运算符：**~求反运算符、^异或运算符**
> Warning: 位运算没有规定只能使用于有符号整形还是无符号整形，一般推荐仅将位运算符用于处理无符号整形。   
求反运算符:会将char类型的运算对象提升为int类型（向高位添加0即可），然后逐位求反。   
移位运算符（又叫IO运算符）满足左结合律，例如：   
```
cout << "hi" << "there" << endl;
```
等同于：   
```
((cout << "hi") << " there") << endl);
```     
移位运算符优先级不高不低，介于中间：比算术运算符优先级低，但是比关系运算符、赋值运算符和条件运算符的优先级高。    
```
cout << 42 + 10; //52
cout << (10 < 42); //1
cout << 10 < 42; //错误：试图比较cout和42
```   

8. sizeof运算符：返回一个表达式或者一个类型名字所占的字节数，其使用形式有两种：   
```
sizeof(type)
sizeo expr
```  
第二种形式中，sizeof返回的是表达式结果类型的大小，稍微不一样的是，sizeof并不计算其运算对象的值：   
```
Sales_data data, *p;  
sizeof(Sales_data); //存储Sales_data类型对象所占的空间大小   
sizeof data;        //data的类型大小，即sizeof p;           //指针所占空间大小
sizeof *p;          //p所指类型的空间大小，即sizeof(Sales_data)    
sizeof data.revenue;  //成员对应类型大小
sizeof Sales_data::revenue; //另一种获取revenue大小的方式
```   
其中最有意思的就是``sizeof *p``,其中即使p为空指针也不会影响最终的结果，因为sizeof根本也不需要通过运算值就可以知道类型的大小。   
最后一个例子则揭示了，C++11新标准中，使用了作用域运算符来获取类成员的大小。   
9. 逗号运算符：逗号运算符经常被人忽略。其运算遵循：先对左侧的表达式求值，然后将求值最终结果丢掉。逗号运算符的真正结果是右侧表达式的值，如果右侧表达式是一个左值，那么最终的求值结果就是个左值；   
最常见的逗号运算符的使用见于for循环中：     
```
vector<int>::size_type cnt = ivec.size();   
for (vector<int>::size_type ix = 0;ix != ivec.size(); ++ix, --cnt)
    ivec[ix] = cnt;
```   

10. 类型转换：任何编程语言都无法避免类型转换这个话题。首先最简单的是隐式转换（implicit conversion）。其次是算数转换。    
整形提升：false提升为0，true提升为1；小char型（bool、char、short等）都会转换为int，其余的提升为unsigned int。   
较大的char类型（wchar_t、char16_t、char32_t）提升为int、unsigned int、long、unsigned long、long long和unsigned long long中的最小的一种类型。

11. 显式转换：   
命名强制转换具有以下形式：   
```
cast-name<type>(expression);
```   
其中type是目标类型而expression是要转换的值，如果type是引用，则结果是左值。而cast-name会从**static_cast、dynamic_cast、const_cast和reinterpret_cast**
static_cast:    
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。例如：   
```
int i, j;
double slope = static_cast<double>(j) / i;
```   
当需要把一个较大的算数类型赋值给较小的类型时，static_cast非常有用。此时强制类型告诉程序阅读者和编译器：这里机器知道并且不在乎潜在的精度损失（这可以避免一大批warning）；     
static_cast对于编译器无法自动执行的类型转换也非常有用，例如找回存在于void*的指针：   
```
void *p = &d;   //正确：任何非常量对象的地址都能存入void*   
double *dp = static_cast<double*>(p); //转换为double类型指针
```     

const_cast:     
const_cast只能改变运算对象是底层const，例如：    
```
const char *pc;
char *p = const_cast<char*>(pc); //正确：但是通过p改变值是未定义的行为
```    
这样把常量对象转换为非常量对象的行为，我们一般称为去掉const性质，编译器也就不会再组织我们对该对象进行写操作。如果对象本身不是一个常量，这样的行为就是合法的，但是如果是一个常量，就容易会产生未定义的后果。    
const_cast的特殊之处就在于只有它能够改变表达式的常量属性，其他cast—name强制类型转换表达式的常量属性都会导致编译器错误。同理，也不能用const_cast改变表达式的类型：   
```
const char *cp;
char *q = static_cast<char*>(cp); //错误：static_cast不能转换掉const性质   
static_cast<string>(cp); //正确：将字符串字面值换为string类型
const_cast<string>(cp);  //错误：const_cast只能改变常量属性，而不能改变类型
```   
> Tip:const_cast常常用于有函数重载的上下文中，下文将会进行介绍   

reinterpret_cast:     
reinterpret_cast通常为对象的位模式提供较低层次上的重新解释，例如有以下转换：   
```
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```   
这里需要牢记pc所指向的真实对象是一个int而非字符，如果把pc当成普通的字符指针就可能在运行时发生错误。例如：   
```
string str(pc);
```     
可能导致异常的运行时行为。

> Suggestion:避免强制类型转换时对于检查类型的建议，这个建议对于reinterpret_cast尤其适用，因为这种类型转换总是充满了风险。比较无可厚非的使用是在有重载函数的上下文中使用const_cast，但是在其它情况下使用const_cast也就意味着程序存在某种设计缺陷。其它强制类型转换，例如static_cast和dynamic_cast，都不应该频繁使用。每书写一条强制类型转换语句，都应该反复斟酌是否能以其它方式事项相同目标。    
**应摒弃早期的强制转换写法**，即type(expr)或者(type)expr，因为这样的类型转换会带来不一样的结果，**完全应该使用static_cast或者const_cast替换**；   

## 第5章 条件语句   
