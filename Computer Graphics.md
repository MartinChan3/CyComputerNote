# 计算几何Note

## 应用领域
1. 计算机图形学：常见的视频输出、打印字体输出
2. 机器人学：路径规划问题
3. 地理信息系统（GIS）
4. CAD/CAM
5. 其他领域：分子建模、模式识别

## 第二章：线段求交：专题图叠合
### 2.1 线段求交
问题1： 线段集S={s1,s2,s3...}求解交集（多图层线段求解交集） 
分析：   
为了避免相距较远的线段，先排除简单情况，以y方向的正交投影来决定是否初步相交；这样的方法解释起来，可以使用一个平行于x轴的直线，从高到低的扫描所有平面，然后从相交的线段中，后续进行判断。该方法称为平面扫描算法（plane sweep algorithm）， 其中使用到的直线被称为扫描线，而与所有线段相交的集合，称为扫描线的状态(status)。随着扫描线的不断向下推进，状态不断变化，不过变化不会连续；只有在某些特定的**状态**才需要更新。对于本算法，事件点就为各线段的端点。   
只有在扫描线触及到某个事件点时，算法才会进行实质性的处理——更新扫描线状态，并且进行一定的相交测试。具体来说，若某事件点为某条线的上端点，这意味着该线段开始与扫描线相交，因此需要将该线段插入到(status structure)中。然后，需要将改线段与当前那些扫描线相交的其他线段进行比较，确定是否相交。如果事件点为某条线的下端点，则意味着该直线不再与扫描线相交，则需要从状态表中删除。   
该算法其实还不完善，例如所有线段都是垂直于x轴是就仍然要计算n平方次；另一方面，即使是与同一条扫描线水平方向相邻，但是在竖直方向，仍然可能会有特别远的距离。   
在考虑到水平方向的邻近性之后，可以沿着扫描线，将与之相交的所有线段由左向右排序，则只有其中两条线段沿水平方向相邻时，才需要对它进行测试。这就意味着，每引入一条新的线段，只需要将它与相邻的（**新线段上端点左、右相邻的两条线段**）进行测试。因此，当扫描线向下推进到一个新的位置时，和某条线段紧邻的邻居可能会发生变化，这时候就只需要对它和新邻居进行测试就可以。   
现在，新的策略有了新的要求——当前状态结构不仅要求记录与当前扫描线相交的所有线段，而且在各个交点处，也要求进行更新——因为交点与各线段相交的次序必然有变化。然而在这种情况下，需要找出位置发生变化的两条线段，然后将它们和各自的新邻居进行测试。这样，就出现了一类新的事件点。   
在将这些构思落实为高效的算法之前，需要考虑部分可能会出错的特殊情况：在任意两个相交的线段si和sj，是否总是存在某个位置，当扫描线1到达该位置的时候， si、sj沿着直线1是紧邻着的？同时我们需要忽略一些特殊情况： 1）没有水平线段； 2）任何两条直线最多相交于一点；（即任何两条线段）； 3）任何三条线段不会相交于同一点；虽然后来我们会看到，这些情况都相对比较好处理，但是目前先不会处理；这样的话，问题只剩下：线段之间在内部每一个交点，是否都能被检测出？   
> 引理 2.1    
> 设两条非水平的线段si和sj相交于其内部一点p，并且，任何第三条线段都不经过p。那么，在（扫描线到达）高于p的某个事件点处（时）， si和sj必然紧邻，并且接受相交测试（于是对应的交点将被发现）。   

就目前算法进行简要概述：如果有一条水平线1由上至下扫过平面，在某些事件点，扫描线会停留片刻；目前算法而言，事件点包含了（事先可以确定的）各个线段端点，也包含了（在算法过程中逐步发现的）交点。在扫描线的移动中，要维护一个有序序列，该序列由所有与当前扫描线相交的线段组成。每遇到一个事件点，扫描线都会停留片刻，此时上述线段序列会有所变化。因此必须通过一定动作对结构状态进行更新，并且检测出新的交点——具体的处理方法，取决于事件点的类型：   
1） 如果事件点对应于某条线段的上端点，意味着有一条新的线段开始与扫描线相交。新引入的这条线必须经过测试，用来验证它与相邻的另外两条线段相交；   
2） 只有位于当前扫描线下方的那些交点，才需要进行考虑；至于高于扫描线的那些交点，在此之前必然已经被检测出来。   
3） 与上方同理，我们只对位于当前扫描线下方的交点感兴趣。   
4） 若事件点对应于某条线段的下端点，那么它此前的两个邻居就会变成现在时相邻，因此也需要对两者的内容进行相交测试。如果确实相交，并且相交线位于当前扫描线的下方，则该交点亦为一个事件点（当然，该事件点可能先前已经计算过）。
5） 在扫描完整个平面以后（准确的说，是处理完所有事件点之后），就确定了所有的交点。

接下来，针对可能出现的退化的情况，我们将要讨论使用到的数据结构，这里使用事件队列（event queue）来存放所有的事件，该事件记作为Q。此外，我们需要一种操作——能够把即将发生的下一个事件从Q中删除掉，并将它返回给主程序，以便于对它的处理。这个事件，就是指位于扫描线下方、位置最高的那个事件。如果**两个事件点的y坐标相同，则约定返回x坐标更小的事件点。**也就是说，位于同一条水平线上的事件点，将按照从左到右的次序依次进行处理。按照这个约定，若为一条水平线，则应当将其左端点视为上端点（同时右端点视为下端点）。同理该约定可以理解为：实际中的扫描线并非是水平的，而是**沿逆时针方向略微向上倾斜**。因此对于水平线段，扫描线会先触及到左端点，再触及到右端点；并且，在这两个位置之间，不会触及其他任何事件点；同时该事件队列必须支持插入操作——因为新的事件可能随时会需要插入。   
值得注意的是， 不同事件点的位置可能重合，例如：两条不同的线段，其上端点可能重合，很明显，这要求**插入操作时，必须检查待插入事件是否已经在Q中了**。   
我们这样处理。首先，各事件点之间定义次序<,并且所有的事件点将会按照这个顺序接受处理。对于任何两个事件点p和q，定义“p < q当且仅当py > qy，或者py = qy且 px < qx”。所有的事件点将按照由<确定的次序，组织为一棵平衡二叉查找树(balanced binary search tree)。对于Q中每个事件点p，我们还需要记下始于p的（即以p为上端点的那条线段）。这两种操作——取出下一个事件与插入新的事件——每次需要O(logm)时间，其中m为Q中的事件数目。（这里没有使用堆来实现队列事件，是因为还需要测试某个给定的事件是否已经存在于Q之中。）   
其次，另一方面需要进行维护的是算法的状态，即当前扫描线相交的所有线段构成的有序序列。借助一个状态结构（status structure），可以访问某个给定线段s的左右邻居2——这样在插入s后，就可以立即进行相交测试。该状态结构称为T。它必须是动态的——一旦有某条线段开始/不再与扫描线相交，就应该插入到状态结构/从状态结构中删除。因此使用一棵**平衡二分查找树**来实现状态结构。最下方的各个子叶，按照二叉查找树的左右子叶规律进行排序。而其根节点，则存储各左子树的最右侧子叶（分界点）来用于判断。这样每次进行操作（更新还是查找），只需要O(logN)的时间。

```
算法 FINDINTERSECTIONS(S)   
输入：平面线段集S   
输出：S中各线段之间的所有交点（以及穿过各交点）   
1. 初始化一个空事件队列Q。然后将所有线段的上下端点插入到Q中，对于上端点，还需要记录对应的线段；
2. 初始化一个空状态结构T。
3. while(Q非空)
4.   do 找出Q中下一个事件点p，将其删除
5.      HANDLEEVENTPOINT(p)
```

总结不同事件的处理办法：如果是线段端点，则需要在状态结构T中插入或者删除线段；如果是交点，则需要交换（对应的）两条线段的次序。无论何种情况，在事件发生后，对每一对新近成为邻居的线段，都需要进行相交测试。在退化情况下——即某个事件点涉及到多条线段时——具体的实现将会更加微妙。下面的子程序，将会描述处理的流程；
```
算法 HANDLEEVENTPOINT(p)
1. 令U(p)为所有以p为上端点的线段构成的集合；   
    这些线段都与事件点p存放于一起（如果为水平线段，则以其左端点作为上端点）
2. 在T中找出包含p的所有线段
    （* 在T中，这些线段都是相邻的）
    在找出的线段中
        将那些以p为下端点的线段构成集合L(p)
        将那些在内部包含p的线段构成集合C(p)
3. if (L(p) ∪ U(p) ∪ C(p)包含不止一条线段)
4.  then 报告“发现交点p”；同时返回L(p)、U(p)和C(p)
5. 将L(p) ∪ C(p)中的线段从T中删除   
6. 将U(p) ∪ C(p)中的线段插入到T中   
    （*T中各线段的次序，必须和它们和扫描线离开p之后的相交次序一致*）
    （* 若存在水平线段，则将它排在包含p的所有线段的最后 *）
7. （* 将C(p)中的线段删除，然后按照逆序重新插入*）
8. if (U(p) ∪ C(p) = ∅)
9.   then 在T中，找出p的左右邻居sl和sr
10.       FindNewEvent(sl,sr,p)
11.  else 在T中，找出U(p) ∪ C(p)最左边的线段s'
12.       在T中，找出与s'紧邻于左侧的线段sl
13.       FindNewEvent(sl,s',p)
14.       在T中，找出U(p) U C(p)里最右边的线段s''
15.       在T中，找出与s''紧邻于右侧的线段sr
16.       FindNewEvent(s'',sr,p)
```

查找新交点的几个子程序非常简单：他们只需要对两条线段进行判断，即可判断它们是否相交。唯一需要小心的是：一旦找到某个交点，该交点只存在两种可能——要么已经事先处理过，要么还没有。如果没有水平线段，那么只要交点位于当前扫描线的下方，它就还没有被处理过。然而，对于水平线段，又该如何处理呢？请记住这里的约定：对y-坐标相同的事件，我们由左往右进行处理。这意味着，对处于当前事件点（水平）右方的交点，我们依然会感兴趣，因此，FindNewEvent子程序应该做如下定义：   
```
算法 FINDNEWEVENT(sl,sr,p)
if (sl和sr相交于当前扫描线的下方（或者交点正好落在当前扫描线上且在当前事件点的右侧），并且该交点尚未作为一个事件出现在Q中)
    then 将这个交点作为一个事件，插入到Q中
```

> 引理2.2 算法FINDINTERSECTIONS能够正确的计算出所有的交点，并且同时给出穿过各交点的线段。

所得的结果是输出敏感的，其时间复杂度为**O((n+I)logn)**，其中n为线段数目，I为实际交点的数目。

### 2.2 双向链表
问题2： 为了表示区域的叠合/划分，需要建立起表示区域划分的方式。（因为简单的将子区域存储为一组线段，并不能反映结构性和拓扑性的信息，例如哪些给定的区域是线段围成的，哪些是相邻的）   
引入了顶点（vertex）和边（edge）的概念。
![screenShot.png](https://i.loli.net/2018/12/11/5c0f6502443b7.png)
本例给出的结构体，有以下作用：围绕指定的某张面，沿边界遍历一周；或在指定一条公共边之后，通过与其相邻于一侧的面，找到另一侧的那张面；或者在指定一个顶点后，（依次）枚举出与之关联的所有边。该结构体称为**双向链接边表(doubly-connected edge list)**。
对于任何一个子区域划分，与之相对应的双向链接边表为每张面、每条边和每个顶点都设置了一个记录，记录除了包含集合、拓扑信息，也包含了一些附加信息，例如如果是一张植被分布图的话，每张面都应该还记录对应的子区域的植被类型。这些附加信息也被称为属性信息（attribute information）。   
一个比较好的办法是视每条边的两端分别视作为一个半边（half-edge）。这样任何一条半边都有唯一一条后继半边、唯一一条前驱半边。


