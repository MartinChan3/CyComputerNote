# 正则表达式（Regular Expression）

## 简介
正则表达式描述了一种字符串匹配的模式，可以用来：
1. 检查一个字符串是否含有某种字符串
2. 匹配的字符子串进行匹配
3. 从某个串中提取出符合条件的子串
总而言之本质是匹配作用。正则表达式由**普通字符**和**元字符（特殊字符）**组成，两者组成一个模板（pattern）来在长字符串中进行匹配；

## 包含字符类型

### 1. 普通字符
包含可打印字符（日常所见的A-Z、a-z、各类标点符号等） + 非打印字符

#### 1) 非打印字符
非打印字符往往以转义序列的形式出现在队列中，如下
|字符|描述|
|---|---|
|\cx|指匹配由x部分指明的控制字符|
|\f|匹配一个换页符。等价于\cL或者\x0c|
|\n|匹配一个换行符。等价于\cJ或者\x0a|
|\r|匹配一个回车符。等价于\cM或者\x0d|
|\s|匹配任意空白字符，包括空格、制表符、换页符等（即非可打印字符）|
|\S|匹配任何非空白字符|
|\t|匹配一个制表符，等价于\cI或者\x09|
|\v|匹配一个水平制表符，等价于\cK或者\x0b|

这里第一行例子：\cM可以匹配一个Control-M或者回车符（ASCII码中回车键的值大小为13）

### 2. 特殊字符
特殊字符是用来指明特殊含义的字符，为了和其普通字符的含义进行区分，往往之前会加上``\``来进行转义(Escape Character转义字符,这里转义是指如果要匹配原来的字符的话)，常用的转义字符如下：
|特别字符|描述|
|---|---|
|$|匹配输入字符串的结尾位置。如果设置了RegExp对象的Multiline属性，那么$也会匹配'\n'或者'\r'。若匹配本身，则使用\$|
|()|标记一个子表达式的开始和结束的位置。子表达式可以提出出来供之后的匹配进行使用。使用\(和\)来对括号本身进行匹配|
|*|匹配前方子表达式零次或者多次。使用\*来匹配本身。|
|+|匹配前方子表达式1次或者多次。使用\+来匹配本身。|
|.|匹配除了换行符'\n'以外任何单字符。使用\.来匹配本身|
|[|标记一个中括号表达式开始，使用\[匹配本身|
|?|匹配前方子表达式零次或者1次，或者指明一个贪婪限定符。使用\?来匹配本身|
|\|对下一个标记字符标记为特殊字符、或者转义处理、或者向后引用、或者八进制转义符。使用\\来匹配本身|
|^|匹配输入字符串的开始位置，除了在方括号表达式中使用，此时它表示不接受该字符集合。使用\^来匹配本身|
|{|标记限定符表达式开始的位置，使用\{来匹配本身|
|\||指明两项之间的一个选择，使用\|来匹配本身|

### 限定符
除了特殊字符，还有一类限定符，用来**指定一个给定的模板需要匹配的次数**
|字符|描述|
|---|---|
|*|匹配前面的子表达式零次或者多次。例如'zo*'能匹配“z”和"zoo"。它等价于{0,}|
|+|匹配前面的子表达式1次或者多次。例如，'zo+'能匹配“zo”和“zoo”。它等价于{1,}|
|?|匹配前面的子表达式零次或者1次。例如'do(es)?'能匹配“do”和“does”中的“does”，以及“doxy”中的“do”。？等价于{0,1}|
|{n}|n为一个非负整数，来匹配确定的n次，例如‘o{2}’不能匹配“Bob”，但是能匹配"book"中的两个"o"|
|{n,}|n是一个非负整数，表示至少匹配n次。例如'o{2,}'不能匹配“Bob”中的'o',但是能匹配“fooood”中的所有的o。'o{1,}'等价于'o+'。而'o{0,}'等价于'o*'|
|{n,m}|m和n均为非负整数，其中n<=m，表示最少匹配n次并最多匹配m次。例如o{1,3}能匹配“foooood”中的前三个o。'o{0,1}'等价于o?。需要注意的是在逗号以及两个数之间都不能存在空格|

**举例**：
面对可能超过个位数大小的章节数如何处理，例如以下公式代表匹配任何位数的章节标题
```
Chapter [1-9][0-9]*
```

**贪婪匹配：例如/*和+都是贪婪的，它们都会尽可能的匹配更多的文字，需要在它们后面添加一个？就可以实现非贪婪或者最小匹配**

### 定位符
定位符是用来**将正则表达式来固定到行首或者行尾的，即表示字符串或者单词的边界**，使得用户来指明一个表达式出现在一个单词内的具体什么位置上。``^``和``$``来代指字符串的开始和结束，``\b``来描述单词的前后边界，而``\B``来表示非单词边界。有以下定位符：
|字符|描述|
|---|---|
|^|匹配输入字符串的开始的位置。如果设置了RegExp对象的Multiline属性，^还会和\n或者\r之后的位置匹配|
|$|匹配输入字符串的结尾位置。如果设置了RegExp对象的Multiline属性，那么$还会和\n或者\r之前的位置相匹配|
|\b|匹配一个字边界，即字与空格之间的位置|
|\B|非字边界匹配|
**注意：**不能够将限定符和定位符一起使用。
如果是想要匹配一行文本开始处的文本，要在正则表达式的开始使用^字符，不能和中括号表达式用混。同样的如果是匹配一行结束时的文本，在结束时使用$字符。
例如``^Chapter [1-9][0-9]{0,1}``用于匹配章节标题，该标题只能出现在行首，并且只能有两位数字

### 选择
一般来说使用圆括号将所有的选择项括起来，相邻的选择项之间用``|``分隔；但圆括号有个副作用：会是的相关匹配项被缓存。使用``?:``放在第一个选项之前来消除该副作用；
**非捕获元：** ``?:``/``?=``/``?!``这三个符号为非捕获元，后两者分别为正向预查和负向预查；

### 反向引用
对于一般的正则表达式中使用圆括号将会导致相关的匹配存储到一个临时的缓存区中，其所捕获的每个自匹配都**按照在正则表达式模式中从左到右出现的顺序存储**。缓冲区编号从1开始，最多可以存储99个捕获的子表达式。每个缓冲区都可以使用``\n``访问，其中n为一个标示特定缓冲区的一个两位以内十进制数；
可以使用非捕获元来忽略对相关的匹配的保存。
反向引用最常见应用于查找文本中两个相同的相邻单词的匹配，例如查找
```
var str = "Is is the cost of of gasoline going up up";
var patt1 = /\b([a-z]+) \1\b/ig;
document.write(str.match(patt1));
```
解析:``[a-z]+``代指一个或者多个字母，第二个部分是代指对之前子匹配项的引用（指圆括号）。``\1``指定第一个匹配项，而前后的``\b``代指边界即只检测整个单词而不是一个单词中的部分；后面的全局标志``g``指定该表达式应用到输入字符串中能够查到尽可能多的匹配。结尾处的``i``大致不区分大小写。

例子：解析URL
```
var str = "http://www.runoob.com:80/html/html-tutorial.html";
var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;
arr = str.match(patt1);
for (var i = 0; i < arr.length ; i++) {
    document.write(arr[i]);
    document.write("<br>");
}
```
分析：
1. 第一个括号中``\w``代指匹配所有单词（包含下划线），随后匹配一个冒号和两个斜杠；
2. 第二个括号子式是用来匹配地址的域地址部分。子式匹配冒号后方的一个或者多个字符；^代指从整个字符串开头来看，
3. 第三个括号代指提取Web指定路径。其中#代指移动到URL页面锚点

### 字符簇
使用一个方括号内的使用的特定集合来代指要匹配的单个字母。例如``[AaEeIiOoUu]``
其余常见的比如
```
[a-z] //匹配所有小写字母
[A-Z] //匹配所有大写字母
[a-zA-Z] //匹配所有字母
[0-9] //匹配所有数字
[0-9\.\-] //匹配所有的数字、句号和减号
[ \f\r\t\n] //匹配所有白字符
```

例如使用``^[a-z][0-9]$``来匹配一个由小写字符和一个数字组成的字符串；
这里值得一提的是，尽管^表示字符串开头，但是它在方括号[]内开头常常用来表示“非”的概念。例如``^[^0-9][0-9]$``是无法匹配66或者12这样的数字的
有以下几个例子非常值得参考：
```
[^a-z] //除了小写字母以外的所有字符 
[^\\\/\^] //除了(\)(/)(^)之外的所有字符 
[^\"\'] //除了双引号(")和单引号(')之外的所有字符
```

特殊字符.代指除了“新行”以外的所有字符，所以``^.5$``可以匹配任何两个以5结尾的字符。而模式“.”可以匹配所有字符串。