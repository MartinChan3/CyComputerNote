Vatti's Clipping Algorithm   
一个多边形可以是一个单独的多边形，也可以是一个连续的多边形序列。在多边形序列中，每一个多边形可能是凸多边形，也可能是凹多边形，甚至自交。图一显示了其内部被着色的状态。    
![screenShot.png](https://i.loli.net/2019/03/12/5c8756e98101f.png)   
本文所使用的算法适用于求从一个多边形被另一个多边形截取的部分。该算法同样适用于给2D的布尔运算——例如求交或者求反；   
一个多边形可以被认为是由一系列的左边界和右边界组成的。每条边界都从一个局部最小点开始，最后在一个局部最大点结束。所有在左边界的边被称为左边，右边同该定义。左右两条都是相。对于内部（填充）来进行定义的。多边形的边可能相交，这种情况下算法会通过插入点的方式将自交多边形转换为一个非自交多边形进行处理。   
目标多边形（被裁剪的那个）和裁剪多边形（进行裁剪的那个）的所有多边形都是封闭的(formed?)。每条边都会被分配一个标志表示边的属性。   
多边形的扫描由底至顶，使用了扫描柄（scanbeam）。每个扫描柄都是一个水平的扫描区域（在两个连续的ev点之间）。换句话说，一个扫描柄就是连续的水平扫描线之间的区域。一张AET表（活动边表）用来维护保存当前扫描线相交的边。AET边表中的边被按照x坐标的大小递增排序。当扫描线移动到下一条时，x坐标大小会被更新；    
每条边界的第一个顶点都是个局部最大值，同时最后一个顶点为局部最小值。剩余的顶点被称为中间点，自然而然的，左边界的中间点就被称为左侧中间点，右边界的就是右侧中间点。本文中对于水平边的处理被视作为额外的处理（寓意会单独处理）；   
在扫描过程中边的交点会被计算。每个计算到的边交点都会被视作为点的声明。这种点声明的操作会根据Clipping的属性操作而进行一些改变，稍后会针对该类问题进行具体的阐释。   
在AET表扫描的时候，第一条边被视作为左边，第二条边被视作为右边。这种规则主要基于相对于剩余线段的奇偶性原则。局部最低点被视作为一个有贡献或无贡献的点，这主要基于它相对于其他类型顶点的位置。如果这个点有贡献，那么一个多边形结点就会被创建，同时分配给两条边，这两条边也会被视作为有贡献的边。如果该点不是有贡献的点，则会给一个空指针，表明这个相关的边是没有贡献的。一条有贡献的边表示该边当前对输出是有影响的。当扫描线到达一条边的顶部，这条边就会被它的继承边替代，同时左右指针会被被指向继承边。因此继承边继承了它继承的边的属性。   
多边形指针指明了是否需要输出一个给定边的给定点。点可能是一条边的终点或者自交点。顶点的类型指明了输出如何进行，这样会影响到裁剪操作最后的闭环。   
顶点必须按照一定特定的规律被写入一个有序表中。当我们到达了贡献边的顶点，我们需要决定顶点的类型来产生输出。在这个时候我们会引入一个简单的检查来决定给定顶点的类型。如果边没有任何继承边(空指针)，那么它就会被认为是一个局部最大点。对于每个顶点的处理，取决于它的类型，处理方法如下：   
1. 局部最小点：创建一个多边形结点，并且分配局部最小值给多边形的顶点表。就像先前提到的，额外的局部最小值可能不会像边自交点那样进行处理。这些局部最小值应当被视作为有贡献的局部最小值。在分配输出这些多边形的时候，连接到有贡献的局部最小点的边会变为有贡献的边。     
2. 左中间点和右中间点：当一个中间点被发现时，顶点仅仅需要被添加到左（或者右）顶点列表的终点，这取决于边的在左侧还是右侧。   
3. 局部最大值：在局部最大值处，会发现一对边界，这对边界可能会属于同一个多边形（当这个多边形有一个封闭的边界）。如果它们属于不同的多边形，其中一个就会属于另一个多边形。对于一个给定的多边形结点，在任何时候都会有两条它的贡献边：一条边贡献于左边表终点，另一条边贡献于右边表的终点。当多边形P在多边形Q的最大值处被添加，将会产生4个贡献边，每个多边形有两条，以Ep1,Ep2,Eq1,Eq2来进行表示。当我们把P添加到Q之后，中间两条边Ep2和Eq1成为了非贡献边，同时Ep1将会成为Q的贡献边。因此多边形Ep1的指针会被设定到Q上。


   

