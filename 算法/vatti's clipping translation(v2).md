已经发布了很多多边形裁剪算法。我们讨论了几个问题。Liang Barsky和Mailot算法比Sutherland算法更好-霍奇曼算法，但这些算法只剪辑简单矩形多边形。这对于图形中的许多情况都是足够的。另一方面，Sutherland Hodgman和Cyrus Beck算法更为通用，允许对任何凸多边形进行剪裁。对凸多边形的限制是由于该算法针对一系列半平面进行剪裁，因此仅适用于半平面相交的集合，即凸（线性）多边形。但是，在某些情况下，凸性要求过于严格。Weiler算法更通用，适用于非凸多边形。我们所看到的最后两种算法，Vatti和Greiner-Hormann算法，也是非常通用的。此外，它们是这些通用算法中效率最高的。多边形现在不以任何方式受到约束。它们可以是凹的或凸的。它们可以有自己的交叉点。事实上，可以很容易地处理多边形列表。我们从Vatti的算法（[Vatt92]）开始。    

如果多边形的内部分别位于右侧或左侧，则将多边形的边称为左边或右边。水平边被视为左右边。Vatti算法使用的一个关键事实是，多边形可以通过一组左边界和右边界来表示，左边界和右边界分别是成对的左边和右边的连接列表。每个边界都从多边形的局部最小值开始，到局部最大值结束。考虑具有顶点P0，P1，…的多边形。p8如图3.18（a）所示。两个左边界分别具有顶点p0、p8、p7、p6和p4、p3、p2。两个右边界具有顶点p0、p1、p2和p4、p5、p6。    
![图片.png](https://i.loli.net/2021/09/17/eBWTCkfntiF8Ovr.png)      

**注意**：在本节中，y轴将指向上（而不是视口中通常的向下）。

下面是Vatti算法的概述。该算法的第一步是确定剪辑多边形和主题多边形的左右边界，并将该信息存储在局部极小值表（LML）中。该表包含一个左右边界配对表，并且按照相应局部最小y坐标升序来进行排列。将初始水平边放入左边界还是右边界并不重要。图3.18（b）显示了图3.18（a）中多边形的LML。构造LML的算法是一个相对简单的编程练习，这里将不进行描述。它可以通过一次Clip和Subject多边形来完成。      

LML上的边界被指定为具有其边为所有左边或所有右边的属性。然而，对于左边界或右边界有一个更一般的概念是很方便的。因此，从现在起，左边界或右边界将表示仅其第一条边要求分别为左边界或右边界的任何连接的边序列。我们仍然假设一个界从局部最小值开始，到局部最大值结束。例如，我们将允许图3.18（a）中的多边形由一个具有顶点p0、p8、p7、p6、p5、p4、p3、p2的左边界和一个具有顶点p0、p1、p2的右边界来描述。    

我们所追求的剪裁或输出多边形将从“部分”多边形序列分阶段构建，每个多边形都是一个“V形”顶点列表，左侧的顶点来自左边界，右侧的顶点来自右边界，两个边界有一个共同的顶点，即，“V”底部的一个，为局部最小值。让我们使用符号P[p0p1…pn]表示顶点为p0，p1，…，的部分多边形，pn，其中p0是第一个点，pn是最后一个点。点p0和pn分别位于部分左边界和右边界的顶部。某些顶点pm将是连接两个边界的局部最小值处的顶点，但由于它不会用于任何东西，因此无需在符号中指示此索引m。例如，图3.18（a）中表示多边形的一种方法是P[p6p7p8p0p1p2p3p5p6]（本例中m为3）。请注意，左侧和右侧边界中的边并不总是位于多边形内部的右侧或左侧。在“完成”多边形的情况下，p0和pn在局部最大值处是相同的顶点，但在多边形构造的所有其他中间阶段，顶点p0和pn可能不相等。然而，p0和pn将始终分别对应于当前左侧和右侧部分边界的顶部顶点。例如，P[p7p8p0p1]（m等于2）是一个合法表达式，用于描述图3.18（a）中多边形的部分左右边界。实现这些部分多边形的一个好方法是通过循环链接列表或循环，以及指向列表最后一个元素的指针。    

该算法现在通过使用所谓的扫描光束从下到上扫描世界来计算LML输出多边形的边界。扫描光束是两条扫描线（不一定相邻）之间的水平部分，因此这些扫描线中的每一条都包含来自多边形的至少一个顶点，但它们之间没有顶点。图3.18（a）显示了确定特定多边形的扫描光束和扫描线。扫描光束是水平线之间的区域。这里应该注意的是，确定扫描波束的扫描线不是一次性全部计算的，而是以自底向上的方式递增计算的。有关扫描光束的信息保存在扫描光束列表（SBL）中，SBL是一个按定义扫描光束的所有扫描线的y坐标排序的有序列表。此递增值列表将被视为一个堆栈。当我们扫描世界时，我们还维护一个活动边列表（AEL），它是一个有序列表，由当前扫描光束相交的所有边组成。

当我们开始处理扫描光束时，我们要做的第一件事就是检查LML，看看它的绑定对是否从扫描光束的底部开始。这些边界对应于局部最小值，可能会开始一个新的输出多边形或将一个多边形拆分为两个，具体取决于局部最小值是从左-右边缘对开始还是从右-左边缘对开始。将LML中的任何新边添加到AEL后，我们需要检查扫描光束中边的交点。这些交点影响输出多边形，并首先单独处理。最后，我们处理AEL上的边。算法3.3.5.1总结了Vatti算法的概述。

```
{ Global variables }
real list       SBL; { an ordered list of distinct reals thought of as a stack}
bound pair list LML; { a list of pairs of matching polygon bounds }
edge list       AEL; { a list of nonhorizontal edges ordered by x-intercept
with the current scan line}
polygon list PL; { the finished output polygons are stored here as algorithm
progresses }

polygon list function Vatti_Clip (polygon subjectP; polygon clipP)
{ The polygon subjectP is clipped against the polygon clipP.
The list of polygons which are the intersection of subjectP and clipP is returned to the
calling procedure. }
begin
    real yb, yt;
    Initialize LML, SBL to empty;

    { Define LML and the initial SBL }
    UpdateLMLandSBL (subjectP, subject);{ subject and clip specify a subject }
    UpdateLMLandSBL (clipP, clip);      { or clip polygon, respectively }

    Initialize PL, AEL to empty;

    yb := PopSBL ();                    { bottom of current scan beam }
    repeat
        AddNewBoundPairs (yb);          { modifies AEL and SBL }
        yt := PopSBL ();                { top of current scan beam }
        ProcessIntersections (yb,yt);
        ProcessEdgesInAEL (yb,yt);
        yb := yt;
    until Empty (SBL);
    return (PL);
end;
```  

为了更好地理解这个算法，我们看了更多的细节。感兴趣的读者可以在随附CD上的VattiClip文档中找到关于抽象程序和显式数据结构的更深入的讨论。算法3.3.5.1中的UpdateLMLandSBL过程查找多边形的边界，将其添加到LML，并更新SBL。寻找边界涉及到找到构成边界的边，并初始化它们的数据结构，该数据结构在进行过程中维护我们所需的信息。例如，我们跟踪它们与当前扫描光束底部相交的x坐标。我们称之为边的x值。AEL的边缘按这些值排序，并使用其坡度断开连接。我们还记录了一条边的类型，它是指它是属于剪辑还是主体多边形。如果两条边的类型相同，但在其他方面不同，则称之为相似边。构建的部分多边形以及最终可能成为构成剪裁多边形的多边形的部分多边形称为其边的相邻多边形。      

由于水平边使问题复杂化，为了使处理水平边更容易，我们假设LML列表中匹配的左边界对和右边界对是“规范化”的。规范化的左、右边界对满足以下属性：
（1） 将所有连续的水平边合并为一条，以便边界在一行中没有两条水平边。     
（2） 没有左边界具有底部水平边（任何此类边都会移动到右边界）。     
（3） 没有右边界具有顶部水平边（任何此类边都会移动到左边界）。     

我们将介绍更多的术语。为输出多边形遇到或创建的某些边和顶点将属于剪裁多边形的边界，而其他边和顶点则不属于剪裁多边形的边界。让我们根据顶点或边是否属于输出多边形，将其称为贡献顶点或边或非贡献顶点或边。关于顶点，如果顶点不是局部最小值或最大值，则它将被称为左或右中间顶点，具体取决于它分别属于左边界还是右边界。基于遇到的顶点的适当操作，我们将看到它因此基本上简化为对以下三种情况的仔细分析：      
（1） 顶点是局部极小值。     
（2） 该顶点是左或右中间顶点。     
（3） 顶点是局部最大值。    

当LML上的元素激活时，会遇到局部极小值。扫描AEL时会遇到中间顶点和局部极大值。边的交点也会导致这三种情况。     
回到算法3.3.5.1，主循环中发生的第一件事是检查从当前扫描光束底部开始的新绑定对。如果存在任何这样的对，那么我们有一个从顶点p开始的两个边界的情况，这是一个局部极小值。我们将它们的第一条非水平边添加到AEL，并将它们的顶部y值添加到SBL。这些边被标记为左边或右边。我们通过奇偶校验来确定边是否有贡献，并相应地标记它们。如果AEL中剪辑多边形左侧的边数为奇数，则主体多边形的边起作用。类似地，如果AEL中对象多边形左侧的边数为奇数，则剪辑多边形的边也会起作用。如果顶点起作用，则创建一个新的部分多边形P[P]，并将该多边形与两条边关联。请注意，要确定边是否有贡献，我们实际上必须只查看每个边界的第一条非水平边的几何体。绑定的其他边将与该边的类型相同。   

Vatti算法中主循环的中心任务是处理AEL上的边。如果边相交，我们将不得不进行一些预处理（过程ProcessCrossons），但现在让我们跳过它，描述实际的处理，即过程ProcessEdgeInael。由于水平边缘会导致严重的并发症，我们将讨论分为两种情况。我们将首先讨论没有水平边的情况。     

如果一条边没有在当前扫描光束的顶部结束，那么我们只需将其x值更新为该边与扫描光束顶部的扫描线相交的x坐标。如果一条边确实在扫描光束的顶部结束，那么我们采取的行动由顶端顶点p的类型决定。顶点可以是中间顶点或局部最大值。      

如果顶点p是左中间顶点或右中间顶点，则该顶点将分别添加到其相邻多边形的顶点列表的开始或结束处，具体取决于它是左边还是右边。AEL上的边将替换为继承相邻多边形和旧边的左/右标志的后续边。      

如果顶点p是原始剪辑或主题多边形的局部最大值，则两个边界的一对边在点p处相交。如果p是贡献顶点，则两条边可能属于相同或不同（部分）多边形。如果它们具有相同的相邻多边形，则一旦添加点p，该多边形将立即闭合。如果它们属于不同的多边形，比如P和Q，那么我们需要合并这些多边形。设e1和e2为P的顶边，f1和f2为Q的顶边，因此e1和f1在P中相交，f1在AEL中为e1的后续。见图3.19。图3.19（a）和（c）显示了具体示例和（b）和（d）一般情况。如果e1是P的左边缘（图3.19（a）和（b）），那么我们将Q的顶点附加到开始处-102 3 P的顶点列表的裁剪。如果e1是P的右边缘（图3.19（c）和（d）），那么我们将P的顶点附加到Q的顶点列表的末尾。注意，每个多边形都有两条顶部贡献边。在这两种情况下，在组合P和Q的顶点后，两条边e1和f1将成为非分配边。如果e1是左边缘，则f2将对P起作用，f2的相邻多边形将变为P。如果e1是右边缘，则e2将对Q起作用。因此，e2的相邻多边形将变为Q。    
![捕获.PNG](https://i.loli.net/2021/09/17/oEmNVrDwxQgRtW7.png)   

当我们找到一个局部最大值时，我们马上知道两个顶边，但是如果它们有不同的相邻多边形，那么我们需要找到这些多边形的其他两个顶边。有两种方法可以解决这个问题。可以在多边形中保留指向其当前顶边的指针，也可以搜索AEL。第一种方法在不进行搜索的情况下为我们提供了边，但是当我们从一条边移动到下一条边时，必须维护指针。哪种方法更好取决于边的数量与局部极大值的数量。由于可能存在相对较少的局部极大值，建议使用第二种方法。     

最后，我们来看看如何处理扫描光束中边缘的交点。处理这些交叉点的方式取决于我们是否有相似或不同的边。只有当两条边都有贡献时，才需要考虑类似的交点，在这种情况下，交点应同时视为左侧和右侧中间顶点。（请注意，在类似交叉口的情况下，如果一条边起作用，那么另一条也会起作用。）必须始终处理不同的交叉口。如何处理它们的交点取决于它们在AEL中的类型、侧面和相对位置。      

对于如何对交点进行分类，可以给出一些精确的规则。分类规则以编码形式显示在表3.3.5.1中。使用以下两个字母代码指定了边：第一个字母表示边是左（L）边还是右（R）边，第二个字母表示边是属于主体多边形还是剪辑多边形。生成的顶点类型也由两个字母的代码指定：局部最小值（MN）、局部最大值（MX）、左中间值（LI）和右中间值（RI）。边缘代码按其边缘在AEL中的显示顺序列出。      
表3.3.5.1边缘交点分类规则      
![屏幕截图 2021-09-17 144458.png](https://i.loli.net/2021/09/17/MwaCEV7ujRNFnsJ.png)     
![捕获.PNG](https://i.loli.net/2021/09/17/vKs58jYVQ3qG6Cz.png)       

例如，规则1转化为以下内容：左剪辑边和左对象边的交点，或左对象边和左剪辑边的交点，生成3.3多边形剪辑算法103图3.19。合并多边形。左中间顶点。规则1-4如图3.20（a）所示。图3.20（b）显示了规则如何应用于某些实际多边形交点的示例。     

当从一个扫描光束移动到另一个扫描光束时，会更新所有边的x值（除非它们在扫描光束顶部结束）。尽管AEL在进入新扫描光束时进行排序，但如果在扫描光束中发现任何交点，则在更新x值后，AEL将不再进行排序。因此，必须使用列表，但这可以在处理交叉口的过程中完成。Vatti使用临时排序边缘列表（SEL）和交叉点列表（IL）来识别和存储当前扫描光束中的所有交叉点。SEL按边缘与扫描光束顶部相交的x坐标排序，类似于AEL按与扫描光束底部相交值排序的方式。IL是指定两条相交边以及相交本身的节点列表。它按交点的y坐标按递增顺序排序。SEL被初始化为空。然后，从SEL右侧开始，通过AEL比较当前边的顶部x值与SEL中边的顶部x值。每次AEL边的顶部x值小于SEL边时，都会有一个交点。请注意，找到的交叉点数量与AEL中的边缘交换数量相同，AEL需要将边缘置于扫描光束顶部的正确位置。      

边的交点基本上被视为顶点。此类“顶点”将以与常规顶点类似的方式进行分类。如果我们得到一个局部最大值，那么有两种情况。如果两条不同边相交，那么一条贡献边会变成一条非贡献边，相反则由非贡献边变为贡献边。这只需交换输出多边形指针即可实现。如果两条相似的边相交，则左边变为右边，右边变为左边。需要交换AEL中的相交边以保持x排序。     

这就结束了我们在没有水平边的情况下对Vatti算法的讨论。现在我们讨论更复杂的一般情况，即允许存在水平边。（但是，我们从不允许边重叠，也就是说，它们共享一个公共段。）我们只需在过程ProcessEdgeInael中进行更改。在抽象的层次上，很容易看到如何处理水平边。上面描述的顶点分类应继续进行，就好像这些边不存在一样（已收缩到一个点）。此外，如果水平边不与任何其他边相交，则出于所有实际目的，可以忽略这些边。当交叉口存在时，问题就会出现。      

假设多边形稍微旋转，因此没有水平边。过去水平的边缘现在可以毫无问题地处理。这表明当它们水平时应该如何处理。处理水平边的方式应与处理交叉点的方式相同。请注意，水平边缘交点仅出现在扫描光束的底部或顶部。应在AddNewBoundPairs程序中处理局部最小值处的水平边。在测试边缘是否在当前扫描光束中结束的算法部分中，其他部分作为特殊情况处理。如果是这样，我们还需要在当前扫描光束的顶部查找水平边，然后顶点的类型分类应区分局部最大值、左中间顶点或右中间顶点情况。相应的程序需要继续扫描AEL，寻找与水平边相交的边，直到有人通过它。最后一个问题是水平边向左。这些将被检测得太晚，也就是说，当我们找到它们是后续的边缘时，我们已经扫描过与它们相交的AEL边缘。为了避免这种情况，最简单的解决方案可能是在检查扫描光束顶部的事件之前，对所有此类边缘进行初始AEL扫描，并将其放入一个特殊的左向水平边缘列表（LHL），该列表按其左端点的x值排序。然后，当扫描AEL时，需要不断检查边的顶部x值是否位于其中一条水平边的内部。     

这就完成了我们对基本Vatti算法的描述。该算法可以在矩形剪辑边界的常见情况下进行优化。如果剪辑多边形是固定的（矩形或非矩形），则可以通过仅计算其边界一次并在调用剪辑算法开始时将LML初始化为这些边界来实现另一种优化。     

Vatti算法的一个吸引人的特点是，它可以很容易地修改以生成梯形。这对于面向扫描线的渲染算法特别方便。每个局部最小值都会启动一个梯形或将现有梯形一分为二，具体取决于局部最小值是从左-右（贡献情况）还是从右-左（非贡献情况）边对开始。在局部最小值处，我们创建一个梯形。梯形在局部最大值和左或右中间顶点处输出。非分配局部最小值应输出将要分割的梯形，并将相关边的梯形指针更新为两个新梯形。Vatti将梯形算法的性能与Sutherland Hodgman算法进行了比较，发现该算法的剪切速度大约是Sutherland Hodgman算法的两倍（边越多，改进越大），并且如果一个3.3多边形剪切算法105同时进行剪切和填充，则速度要快得多。由于第14.4节将描述用于修剪曲面的Vatti算法梯形形式的特殊情况，因此我们将推迟关于如何处理梯形的进一步细节。     

最后，我们还可以将Vatti算法用于除交叉点以外的其他操作。我们所要做的就是替换分类规则。例如，如果要输出两个多边形的并集，请使用规则：     
(1) (LC ∪ LS) or (LS ∪ LC) → LI     
(2) (RC ∪ RS) or (RS ∪ RC) → RI    
(3) (LS ∪ RC) or (LC ∪ RS) → MN    
(4) (RS ∪ LC) or (RC ∪ LS) → MX     
位于剪辑多边形外部的主题多边形的局部极小值和位于主题多边形外部的剪辑多边形的局部极小值应视为贡献局部极小值。     

对于两个多边形（主题多边形减去剪辑多边形）的差异，请使用规则：     
(1) (RC ∪ LS) or (LS ∪ RC) → LI     
(2) (RS ∪ LC) or (LC ∪ RS) → RI    
(3) (RS ∪ RC) or (LC ∪ LS) → MN    
(4) (RC ∪ RS) or (LS ∪ LC) → MX    
位于剪辑多边形外部的主题多边形的局部极小值应视为贡献局部极小值。     